
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 79 01 00 00       	call   c00202b6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020162:	55                   	push   %ebp
c0020163:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020165:	8b 45 08             	mov    0x8(%ebp),%eax
c0020168:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002016d:	5d                   	pop    %ebp
c002016e:	c3                   	ret    

c002016f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002016f:	55                   	push   %ebp
c0020170:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020172:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020179:	0f 97 c0             	seta   %al
}
c002017c:	5d                   	pop    %ebp
c002017d:	c3                   	ret    

c002017e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002017e:	55                   	push   %ebp
c002017f:	89 e5                	mov    %esp,%ebp
c0020181:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0020184:	8b 45 08             	mov    0x8(%ebp),%eax
c0020187:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002018c:	76 1e                	jbe    c00201ac <ptov+0x2e>
c002018e:	83 ec 0c             	sub    $0xc,%esp
c0020191:	68 20 ef 02 c0       	push   $0xc002ef20
c0020196:	68 3b ef 02 c0       	push   $0xc002ef3b
c002019b:	68 c8 f2 02 c0       	push   $0xc002f2c8
c00201a0:	6a 4a                	push   $0x4a
c00201a2:	68 52 ef 02 c0       	push   $0xc002ef52
c00201a7:	e8 76 9e 00 00       	call   c002a022 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00201af:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201b4:	c9                   	leave  
c00201b5:	c3                   	ret    

c00201b6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201b6:	55                   	push   %ebp
c00201b7:	89 e5                	mov    %esp,%ebp
c00201b9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201bc:	ff 75 08             	pushl  0x8(%ebp)
c00201bf:	e8 ab ff ff ff       	call   c002016f <is_kernel_vaddr>
c00201c4:	83 c4 04             	add    $0x4,%esp
c00201c7:	84 c0                	test   %al,%al
c00201c9:	75 1e                	jne    c00201e9 <vtop+0x33>
c00201cb:	83 ec 0c             	sub    $0xc,%esp
c00201ce:	68 68 ef 02 c0       	push   $0xc002ef68
c00201d3:	68 3b ef 02 c0       	push   $0xc002ef3b
c00201d8:	68 f0 f2 02 c0       	push   $0xc002f2f0
c00201dd:	6a 54                	push   $0x54
c00201df:	68 52 ef 02 c0       	push   $0xc002ef52
c00201e4:	e8 39 9e 00 00       	call   c002a022 <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00201e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00201ec:	05 00 00 00 40       	add    $0x40000000,%eax
}
c00201f1:	c9                   	leave  
c00201f2:	c3                   	ret    

c00201f3 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c00201f3:	55                   	push   %ebp
c00201f4:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00201f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00201f9:	c1 e8 0c             	shr    $0xc,%eax
c00201fc:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0020201:	5d                   	pop    %ebp
c0020202:	c3                   	ret    

c0020203 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020203:	55                   	push   %ebp
c0020204:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020206:	8b 45 08             	mov    0x8(%ebp),%eax
c0020209:	c1 e8 16             	shr    $0x16,%eax
}
c002020c:	5d                   	pop    %ebp
c002020d:	c3                   	ret    

c002020e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002020e:	55                   	push   %ebp
c002020f:	89 e5                	mov    %esp,%ebp
c0020211:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020214:	ff 75 08             	pushl  0x8(%ebp)
c0020217:	e8 46 ff ff ff       	call   c0020162 <pg_ofs>
c002021c:	83 c4 04             	add    $0x4,%esp
c002021f:	85 c0                	test   %eax,%eax
c0020221:	74 1e                	je     c0020241 <pde_create+0x33>
c0020223:	83 ec 0c             	sub    $0xc,%esp
c0020226:	68 80 ef 02 c0       	push   $0xc002ef80
c002022b:	68 3b ef 02 c0       	push   $0xc002ef3b
c0020230:	68 d0 f2 02 c0       	push   $0xc002f2d0
c0020235:	6a 48                	push   $0x48
c0020237:	68 91 ef 02 c0       	push   $0xc002ef91
c002023c:	e8 e1 9d 00 00       	call   c002a022 <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020241:	83 ec 0c             	sub    $0xc,%esp
c0020244:	ff 75 08             	pushl  0x8(%ebp)
c0020247:	e8 6a ff ff ff       	call   c00201b6 <vtop>
c002024c:	83 c4 10             	add    $0x10,%esp
c002024f:	83 c8 07             	or     $0x7,%eax
}
c0020252:	c9                   	leave  
c0020253:	c3                   	ret    

c0020254 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020254:	55                   	push   %ebp
c0020255:	89 e5                	mov    %esp,%ebp
c0020257:	83 ec 18             	sub    $0x18,%esp
c002025a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002025d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020260:	ff 75 08             	pushl  0x8(%ebp)
c0020263:	e8 fa fe ff ff       	call   c0020162 <pg_ofs>
c0020268:	83 c4 04             	add    $0x4,%esp
c002026b:	85 c0                	test   %eax,%eax
c002026d:	74 1e                	je     c002028d <pte_create_kernel+0x39>
c002026f:	83 ec 0c             	sub    $0xc,%esp
c0020272:	68 a5 ef 02 c0       	push   $0xc002efa5
c0020277:	68 3b ef 02 c0       	push   $0xc002ef3b
c002027c:	68 dc f2 02 c0       	push   $0xc002f2dc
c0020281:	6a 58                	push   $0x58
c0020283:	68 91 ef 02 c0       	push   $0xc002ef91
c0020288:	e8 95 9d 00 00       	call   c002a022 <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002028d:	83 ec 0c             	sub    $0xc,%esp
c0020290:	ff 75 08             	pushl  0x8(%ebp)
c0020293:	e8 1e ff ff ff       	call   c00201b6 <vtop>
c0020298:	83 c4 10             	add    $0x10,%esp
c002029b:	89 c2                	mov    %eax,%edx
c002029d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202a1:	74 07                	je     c00202aa <pte_create_kernel+0x56>
c00202a3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202a8:	eb 05                	jmp    c00202af <pte_create_kernel+0x5b>
c00202aa:	b8 00 00 00 00       	mov    $0x0,%eax
c00202af:	09 d0                	or     %edx,%eax
c00202b1:	83 c8 01             	or     $0x1,%eax
}
c00202b4:	c9                   	leave  
c00202b5:	c3                   	ret    

c00202b6 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202b6:	55                   	push   %ebp
c00202b7:	89 e5                	mov    %esp,%ebp
c00202b9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202bc:	e8 ae 00 00 00       	call   c002036f <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202c1:	e8 0e 02 00 00       	call   c00204d4 <read_command_line>
c00202c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202c9:	83 ec 0c             	sub    $0xc,%esp
c00202cc:	ff 75 f4             	pushl  -0xc(%ebp)
c00202cf:	e8 30 03 00 00       	call   c0020604 <parse_options>
c00202d4:	83 c4 10             	add    $0x10,%esp
c00202d7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202da:	e8 cc 05 00 00       	call   c00208ab <thread_init>
  console_init ();  
c00202df:	e8 a6 bd 00 00       	call   c002c08a <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c00202e4:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00202e9:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00202ec:	c1 e8 0a             	shr    $0xa,%eax
c00202ef:	83 ec 08             	sub    $0x8,%esp
c00202f2:	50                   	push   %eax
c00202f3:	68 b8 ef 02 c0       	push   $0xc002efb8
c00202f8:	e8 54 78 00 00       	call   c0027b51 <printf>
c00202fd:	83 c4 10             	add    $0x10,%esp

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020300:	a1 80 7b 03 c0       	mov    0xc0037b80,%eax
c0020305:	83 ec 0c             	sub    $0xc,%esp
c0020308:	50                   	push   %eax
c0020309:	e8 ed 34 00 00       	call   c00237fb <palloc_init>
c002030e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020311:	e8 f4 38 00 00       	call   c0023c0a <malloc_init>
  paging_init ();
c0020316:	e8 7e 00 00 00       	call   c0020399 <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002031b:	e8 71 16 00 00       	call   c0021991 <intr_init>
  timer_init ();
c0020320:	e8 b1 40 00 00       	call   c00243d6 <timer_init>
  kbd_init ();
c0020325:	e8 13 48 00 00       	call   c0024b3d <kbd_init>
  input_init ();
c002032a:	e8 86 6a 00 00       	call   c0026db5 <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c002032f:	e8 28 06 00 00       	call   c002095c <thread_start>
  serial_init_queue ();
c0020334:	e8 cc 4f 00 00       	call   c0025305 <serial_init_queue>
  timer_calibrate ();
c0020339:	e8 d9 40 00 00       	call   c0024417 <timer_calibrate>
  filesys_init (format_filesys);
#endif
#ifdef VM
    vm_swap_init ();
#endif
  printf ("Boot complete.\n");
c002033e:	83 ec 0c             	sub    $0xc,%esp
c0020341:	68 db ef 02 c0       	push   $0xc002efdb
c0020346:	e8 98 be 00 00       	call   c002c1e3 <puts>
c002034b:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c002034e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020351:	8b 00                	mov    (%eax),%eax
c0020353:	85 c0                	test   %eax,%eax
c0020355:	74 0e                	je     c0020365 <pintos_init+0xaf>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020357:	83 ec 0c             	sub    $0xc,%esp
c002035a:	ff 75 f4             	pushl  -0xc(%ebp)
c002035d:	e8 3d 04 00 00       	call   c002079f <run_actions>
c0020362:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020365:	e8 49 72 00 00       	call   c00275b3 <shutdown>
  thread_exit ();
c002036a:	e8 9c 09 00 00       	call   c0020d0b <thread_exit>

c002036f <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c002036f:	55                   	push   %ebp
c0020370:	89 e5                	mov    %esp,%ebp
c0020372:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020375:	ba 31 a1 03 c0       	mov    $0xc003a131,%edx
c002037a:	b8 04 84 03 c0       	mov    $0xc0038404,%eax
c002037f:	29 c2                	sub    %eax,%edx
c0020381:	89 d0                	mov    %edx,%eax
c0020383:	83 ec 04             	sub    $0x4,%esp
c0020386:	50                   	push   %eax
c0020387:	6a 00                	push   $0x0
c0020389:	68 04 84 03 c0       	push   $0xc0038404
c002038e:	e8 97 8f 00 00       	call   c002932a <memset>
c0020393:	83 c4 10             	add    $0x10,%esp
}
c0020396:	90                   	nop
c0020397:	c9                   	leave  
c0020398:	c3                   	ret    

c0020399 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c0020399:	55                   	push   %ebp
c002039a:	89 e5                	mov    %esp,%ebp
c002039c:	53                   	push   %ebx
c002039d:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203a0:	83 ec 0c             	sub    $0xc,%esp
c00203a3:	6a 03                	push   $0x3
c00203a5:	e8 cb 35 00 00       	call   c0023975 <palloc_get_page>
c00203aa:	83 c4 10             	add    $0x10,%esp
c00203ad:	a3 28 a1 03 c0       	mov    %eax,0xc003a128
c00203b2:	a1 28 a1 03 c0       	mov    0xc003a128,%eax
c00203b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203c8:	e9 df 00 00 00       	jmp    c00204ac <paging_init+0x113>
    {
      uintptr_t paddr = page * PGSIZE;
c00203cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00203d0:	c1 e0 0c             	shl    $0xc,%eax
c00203d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00203d6:	83 ec 0c             	sub    $0xc,%esp
c00203d9:	ff 75 e8             	pushl  -0x18(%ebp)
c00203dc:	e8 9d fd ff ff       	call   c002017e <ptov>
c00203e1:	83 c4 10             	add    $0x10,%esp
c00203e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c00203e7:	83 ec 0c             	sub    $0xc,%esp
c00203ea:	ff 75 e4             	pushl  -0x1c(%ebp)
c00203ed:	e8 11 fe ff ff       	call   c0020203 <pd_no>
c00203f2:	83 c4 10             	add    $0x10,%esp
c00203f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c00203f8:	83 ec 0c             	sub    $0xc,%esp
c00203fb:	ff 75 e4             	pushl  -0x1c(%ebp)
c00203fe:	e8 f0 fd ff ff       	call   c00201f3 <pt_no>
c0020403:	83 c4 10             	add    $0x10,%esp
c0020406:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020409:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020410:	72 10                	jb     c0020422 <paging_init+0x89>
c0020412:	81 7d e4 00 40 03 c0 	cmpl   $0xc0034000,-0x1c(%ebp)
c0020419:	73 07                	jae    c0020422 <paging_init+0x89>
c002041b:	b8 01 00 00 00       	mov    $0x1,%eax
c0020420:	eb 05                	jmp    c0020427 <paging_init+0x8e>
c0020422:	b8 00 00 00 00       	mov    $0x0,%eax
c0020427:	88 45 db             	mov    %al,-0x25(%ebp)
c002042a:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c002042e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020431:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020438:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002043b:	01 d0                	add    %edx,%eax
c002043d:	8b 00                	mov    (%eax),%eax
c002043f:	85 c0                	test   %eax,%eax
c0020441:	75 30                	jne    c0020473 <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020443:	83 ec 0c             	sub    $0xc,%esp
c0020446:	6a 03                	push   $0x3
c0020448:	e8 28 35 00 00       	call   c0023975 <palloc_get_page>
c002044d:	83 c4 10             	add    $0x10,%esp
c0020450:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020453:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020456:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002045d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020460:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020463:	83 ec 0c             	sub    $0xc,%esp
c0020466:	ff 75 f4             	pushl  -0xc(%ebp)
c0020469:	e8 a0 fd ff ff       	call   c002020e <pde_create>
c002046e:	83 c4 10             	add    $0x10,%esp
c0020471:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020473:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020476:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002047d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020480:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020483:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c0020487:	85 c0                	test   %eax,%eax
c0020489:	0f 95 c0             	setne  %al
c002048c:	83 f0 01             	xor    $0x1,%eax
c002048f:	0f b6 c0             	movzbl %al,%eax
c0020492:	83 e0 01             	and    $0x1,%eax
c0020495:	0f b6 c0             	movzbl %al,%eax
c0020498:	83 ec 08             	sub    $0x8,%esp
c002049b:	50                   	push   %eax
c002049c:	ff 75 e4             	pushl  -0x1c(%ebp)
c002049f:	e8 b0 fd ff ff       	call   c0020254 <pte_create_kernel>
c00204a4:	83 c4 10             	add    $0x10,%esp
c00204a7:	89 03                	mov    %eax,(%ebx)
  for (page = 0; page < init_ram_pages; page++)
c00204a9:	ff 45 f0             	incl   -0x10(%ebp)
c00204ac:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00204b1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204b4:	0f 82 13 ff ff ff    	jb     c00203cd <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204ba:	a1 28 a1 03 c0       	mov    0xc003a128,%eax
c00204bf:	83 ec 0c             	sub    $0xc,%esp
c00204c2:	50                   	push   %eax
c00204c3:	e8 ee fc ff ff       	call   c00201b6 <vtop>
c00204c8:	83 c4 10             	add    $0x10,%esp
c00204cb:	0f 22 d8             	mov    %eax,%cr3
}
c00204ce:	90                   	nop
c00204cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204d2:	c9                   	leave  
c00204d3:	c3                   	ret    

c00204d4 <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00204d4:	55                   	push   %ebp
c00204d5:	89 e5                	mov    %esp,%ebp
c00204d7:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00204da:	83 ec 0c             	sub    $0xc,%esp
c00204dd:	68 3a 7d 00 00       	push   $0x7d3a
c00204e2:	e8 97 fc ff ff       	call   c002017e <ptov>
c00204e7:	83 c4 10             	add    $0x10,%esp
c00204ea:	8b 00                	mov    (%eax),%eax
c00204ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c00204ef:	83 ec 0c             	sub    $0xc,%esp
c00204f2:	68 3e 7d 00 00       	push   $0x7d3e
c00204f7:	e8 82 fc ff ff       	call   c002017e <ptov>
c00204fc:	83 c4 10             	add    $0x10,%esp
c00204ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020502:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020505:	83 e8 80             	sub    $0xffffff80,%eax
c0020508:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c002050b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020512:	eb 4e                	jmp    c0020562 <read_command_line+0x8e>
    {
      if (p >= end)
c0020514:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020517:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002051a:	72 19                	jb     c0020535 <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c002051c:	68 ec ef 02 c0       	push   $0xc002efec
c0020521:	68 f8 f2 02 c0       	push   $0xc002f2f8
c0020526:	68 e3 00 00 00       	push   $0xe3
c002052b:	68 0c f0 02 c0       	push   $0xc002f00c
c0020530:	e8 ed 9a 00 00       	call   c002a022 <debug_panic>

      argv[i] = p;
c0020535:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020538:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002053b:	89 14 85 20 84 03 c0 	mov    %edx,-0x3ffc7be0(,%eax,4)
      p += strnlen (p, end - p) + 1;
c0020542:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0020545:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020548:	29 c2                	sub    %eax,%edx
c002054a:	89 d0                	mov    %edx,%eax
c002054c:	83 ec 08             	sub    $0x8,%esp
c002054f:	50                   	push   %eax
c0020550:	ff 75 f4             	pushl  -0xc(%ebp)
c0020553:	e8 78 8e 00 00       	call   c00293d0 <strnlen>
c0020558:	83 c4 10             	add    $0x10,%esp
c002055b:	40                   	inc    %eax
c002055c:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < argc; i++) 
c002055f:	ff 45 f0             	incl   -0x10(%ebp)
c0020562:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020565:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020568:	7c aa                	jl     c0020514 <read_command_line+0x40>
    }
  argv[argc] = NULL;
c002056a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002056d:	c7 04 85 20 84 03 c0 	movl   $0x0,-0x3ffc7be0(,%eax,4)
c0020574:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c0020578:	83 ec 0c             	sub    $0xc,%esp
c002057b:	68 21 f0 02 c0       	push   $0xc002f021
c0020580:	e8 cc 75 00 00       	call   c0027b51 <printf>
c0020585:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c0020588:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002058f:	eb 57                	jmp    c00205e8 <read_command_line+0x114>
    if (strchr (argv[i], ' ') == NULL)
c0020591:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020594:	8b 04 85 20 84 03 c0 	mov    -0x3ffc7be0(,%eax,4),%eax
c002059b:	83 ec 08             	sub    $0x8,%esp
c002059e:	6a 20                	push   $0x20
c00205a0:	50                   	push   %eax
c00205a1:	e8 a9 8a 00 00       	call   c002904f <strchr>
c00205a6:	83 c4 10             	add    $0x10,%esp
c00205a9:	85 c0                	test   %eax,%eax
c00205ab:	75 1d                	jne    c00205ca <read_command_line+0xf6>
      printf (" %s", argv[i]);
c00205ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205b0:	8b 04 85 20 84 03 c0 	mov    -0x3ffc7be0(,%eax,4),%eax
c00205b7:	83 ec 08             	sub    $0x8,%esp
c00205ba:	50                   	push   %eax
c00205bb:	68 36 f0 02 c0       	push   $0xc002f036
c00205c0:	e8 8c 75 00 00       	call   c0027b51 <printf>
c00205c5:	83 c4 10             	add    $0x10,%esp
c00205c8:	eb 1b                	jmp    c00205e5 <read_command_line+0x111>
    else
      printf (" '%s'", argv[i]);
c00205ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205cd:	8b 04 85 20 84 03 c0 	mov    -0x3ffc7be0(,%eax,4),%eax
c00205d4:	83 ec 08             	sub    $0x8,%esp
c00205d7:	50                   	push   %eax
c00205d8:	68 3a f0 02 c0       	push   $0xc002f03a
c00205dd:	e8 6f 75 00 00       	call   c0027b51 <printf>
c00205e2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205e5:	ff 45 f0             	incl   -0x10(%ebp)
c00205e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205eb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00205ee:	7c a1                	jl     c0020591 <read_command_line+0xbd>
  printf ("\n");
c00205f0:	83 ec 0c             	sub    $0xc,%esp
c00205f3:	6a 0a                	push   $0xa
c00205f5:	e8 6e bc 00 00       	call   c002c268 <putchar>
c00205fa:	83 c4 10             	add    $0x10,%esp

  return argv;
c00205fd:	b8 20 84 03 c0       	mov    $0xc0038420,%eax
}
c0020602:	c9                   	leave  
c0020603:	c3                   	ret    

c0020604 <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c0020604:	55                   	push   %ebp
c0020605:	89 e5                	mov    %esp,%ebp
c0020607:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c002060a:	e9 1c 01 00 00       	jmp    c002072b <parse_options+0x127>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c002060f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020612:	8b 00                	mov    (%eax),%eax
c0020614:	83 ec 04             	sub    $0x4,%esp
c0020617:	8d 55 ec             	lea    -0x14(%ebp),%edx
c002061a:	52                   	push   %edx
c002061b:	68 40 f0 02 c0       	push   $0xc002f040
c0020620:	50                   	push   %eax
c0020621:	e8 f6 8b 00 00       	call   c002921c <strtok_r>
c0020626:	83 c4 10             	add    $0x10,%esp
c0020629:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c002062c:	83 ec 04             	sub    $0x4,%esp
c002062f:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0020632:	50                   	push   %eax
c0020633:	68 42 f0 02 c0       	push   $0xc002f042
c0020638:	6a 00                	push   $0x0
c002063a:	e8 dd 8b 00 00       	call   c002921c <strtok_r>
c002063f:	83 c4 10             	add    $0x10,%esp
c0020642:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c0020645:	83 ec 08             	sub    $0x8,%esp
c0020648:	68 43 f0 02 c0       	push   $0xc002f043
c002064d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020650:	e8 f8 88 00 00       	call   c0028f4d <strcmp>
c0020655:	83 c4 10             	add    $0x10,%esp
c0020658:	85 c0                	test   %eax,%eax
c002065a:	75 0a                	jne    c0020666 <parse_options+0x62>
        usage ();
c002065c:	e8 22 02 00 00       	call   c0020883 <usage>
c0020661:	e9 c1 00 00 00       	jmp    c0020727 <parse_options+0x123>
      else if (!strcmp (name, "-q"))
c0020666:	83 ec 08             	sub    $0x8,%esp
c0020669:	68 46 f0 02 c0       	push   $0xc002f046
c002066e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020671:	e8 d7 88 00 00       	call   c0028f4d <strcmp>
c0020676:	83 c4 10             	add    $0x10,%esp
c0020679:	85 c0                	test   %eax,%eax
c002067b:	75 12                	jne    c002068f <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c002067d:	83 ec 0c             	sub    $0xc,%esp
c0020680:	6a 01                	push   $0x1
c0020682:	e8 50 6f 00 00       	call   c00275d7 <shutdown_configure>
c0020687:	83 c4 10             	add    $0x10,%esp
c002068a:	e9 98 00 00 00       	jmp    c0020727 <parse_options+0x123>
      else if (!strcmp (name, "-r"))
c002068f:	83 ec 08             	sub    $0x8,%esp
c0020692:	68 49 f0 02 c0       	push   $0xc002f049
c0020697:	ff 75 f4             	pushl  -0xc(%ebp)
c002069a:	e8 ae 88 00 00       	call   c0028f4d <strcmp>
c002069f:	83 c4 10             	add    $0x10,%esp
c00206a2:	85 c0                	test   %eax,%eax
c00206a4:	75 0f                	jne    c00206b5 <parse_options+0xb1>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206a6:	83 ec 0c             	sub    $0xc,%esp
c00206a9:	6a 02                	push   $0x2
c00206ab:	e8 27 6f 00 00       	call   c00275d7 <shutdown_configure>
c00206b0:	83 c4 10             	add    $0x10,%esp
c00206b3:	eb 72                	jmp    c0020727 <parse_options+0x123>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c00206b5:	83 ec 08             	sub    $0x8,%esp
c00206b8:	68 4c f0 02 c0       	push   $0xc002f04c
c00206bd:	ff 75 f4             	pushl  -0xc(%ebp)
c00206c0:	e8 88 88 00 00       	call   c0028f4d <strcmp>
c00206c5:	83 c4 10             	add    $0x10,%esp
c00206c8:	85 c0                	test   %eax,%eax
c00206ca:	75 1c                	jne    c00206e8 <parse_options+0xe4>
        random_init (atoi (value));
c00206cc:	83 ec 0c             	sub    $0xc,%esp
c00206cf:	ff 75 f0             	pushl  -0x10(%ebp)
c00206d2:	e8 79 82 00 00       	call   c0028950 <atoi>
c00206d7:	83 c4 10             	add    $0x10,%esp
c00206da:	83 ec 0c             	sub    $0xc,%esp
c00206dd:	50                   	push   %eax
c00206de:	e8 10 72 00 00       	call   c00278f3 <random_init>
c00206e3:	83 c4 10             	add    $0x10,%esp
c00206e6:	eb 3f                	jmp    c0020727 <parse_options+0x123>
      else if (!strcmp (name, "-mlfqs"))
c00206e8:	83 ec 08             	sub    $0x8,%esp
c00206eb:	68 50 f0 02 c0       	push   $0xc002f050
c00206f0:	ff 75 f4             	pushl  -0xc(%ebp)
c00206f3:	e8 55 88 00 00       	call   c0028f4d <strcmp>
c00206f8:	83 c4 10             	add    $0x10,%esp
c00206fb:	85 c0                	test   %eax,%eax
c00206fd:	75 09                	jne    c0020708 <parse_options+0x104>
        thread_mlfqs = true;
c00206ff:	c6 05 30 a1 03 c0 01 	movb   $0x1,0xc003a130
c0020706:	eb 1f                	jmp    c0020727 <parse_options+0x123>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020708:	83 ec 0c             	sub    $0xc,%esp
c002070b:	ff 75 f4             	pushl  -0xc(%ebp)
c002070e:	68 58 f0 02 c0       	push   $0xc002f058
c0020713:	68 0c f3 02 c0       	push   $0xc002f30c
c0020718:	68 1c 01 00 00       	push   $0x11c
c002071d:	68 0c f0 02 c0       	push   $0xc002f00c
c0020722:	e8 fb 98 00 00       	call   c002a022 <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020727:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c002072b:	8b 45 08             	mov    0x8(%ebp),%eax
c002072e:	8b 00                	mov    (%eax),%eax
c0020730:	85 c0                	test   %eax,%eax
c0020732:	74 0f                	je     c0020743 <parse_options+0x13f>
c0020734:	8b 45 08             	mov    0x8(%ebp),%eax
c0020737:	8b 00                	mov    (%eax),%eax
c0020739:	8a 00                	mov    (%eax),%al
c002073b:	3c 2d                	cmp    $0x2d,%al
c002073d:	0f 84 cc fe ff ff    	je     c002060f <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c0020743:	e8 dc 6b 00 00       	call   c0027324 <rtc_get_time>
c0020748:	83 ec 0c             	sub    $0xc,%esp
c002074b:	50                   	push   %eax
c002074c:	e8 a2 71 00 00       	call   c00278f3 <random_init>
c0020751:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c0020754:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020757:	c9                   	leave  
c0020758:	c3                   	ret    

c0020759 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020759:	55                   	push   %ebp
c002075a:	89 e5                	mov    %esp,%ebp
c002075c:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c002075f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020762:	8b 40 04             	mov    0x4(%eax),%eax
c0020765:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020768:	83 ec 08             	sub    $0x8,%esp
c002076b:	ff 75 f4             	pushl  -0xc(%ebp)
c002076e:	68 7e f0 02 c0       	push   $0xc002f07e
c0020773:	e8 d9 73 00 00       	call   c0027b51 <printf>
c0020778:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c002077b:	83 ec 0c             	sub    $0xc,%esp
c002077e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020781:	e8 b2 bb 00 00       	call   c002c338 <run_test>
c0020786:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c0020789:	83 ec 08             	sub    $0x8,%esp
c002078c:	ff 75 f4             	pushl  -0xc(%ebp)
c002078f:	68 8f f0 02 c0       	push   $0xc002f08f
c0020794:	e8 b8 73 00 00       	call   c0027b51 <printf>
c0020799:	83 c4 10             	add    $0x10,%esp
}
c002079c:	90                   	nop
c002079d:	c9                   	leave  
c002079e:	c3                   	ret    

c002079f <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c002079f:	55                   	push   %ebp
c00207a0:	89 e5                	mov    %esp,%ebp
c00207a2:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c00207a5:	e9 c9 00 00 00       	jmp    c0020873 <run_actions+0xd4>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c00207aa:	c7 45 f4 20 f3 02 c0 	movl   $0xc002f320,-0xc(%ebp)
        if (a->name == NULL)
c00207b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207b4:	8b 00                	mov    (%eax),%eax
c00207b6:	85 c0                	test   %eax,%eax
c00207b8:	75 22                	jne    c00207dc <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00207bd:	8b 00                	mov    (%eax),%eax
c00207bf:	83 ec 0c             	sub    $0xc,%esp
c00207c2:	50                   	push   %eax
c00207c3:	68 ac f0 02 c0       	push   $0xc002f0ac
c00207c8:	68 38 f3 02 c0       	push   $0xc002f338
c00207cd:	68 5e 01 00 00       	push   $0x15e
c00207d2:	68 0c f0 02 c0       	push   $0xc002f00c
c00207d7:	e8 46 98 00 00       	call   c002a022 <debug_panic>
        else if (!strcmp (*argv, a->name))
c00207dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207df:	8b 10                	mov    (%eax),%edx
c00207e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00207e4:	8b 00                	mov    (%eax),%eax
c00207e6:	83 ec 08             	sub    $0x8,%esp
c00207e9:	52                   	push   %edx
c00207ea:	50                   	push   %eax
c00207eb:	e8 5d 87 00 00       	call   c0028f4d <strcmp>
c00207f0:	83 c4 10             	add    $0x10,%esp
c00207f3:	85 c0                	test   %eax,%eax
c00207f5:	74 06                	je     c00207fd <run_actions+0x5e>
      for (a = actions; ; a++)
c00207f7:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
        if (a->name == NULL)
c00207fb:	eb b4                	jmp    c00207b1 <run_actions+0x12>
          break;
c00207fd:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c00207fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0020805:	eb 44                	jmp    c002084b <run_actions+0xac>
        if (argv[i] == NULL)
c0020807:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002080a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020811:	8b 45 08             	mov    0x8(%ebp),%eax
c0020814:	01 d0                	add    %edx,%eax
c0020816:	8b 00                	mov    (%eax),%eax
c0020818:	85 c0                	test   %eax,%eax
c002081a:	75 2c                	jne    c0020848 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c002081c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002081f:	8b 40 04             	mov    0x4(%eax),%eax
c0020822:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020825:	8b 45 08             	mov    0x8(%ebp),%eax
c0020828:	8b 00                	mov    (%eax),%eax
c002082a:	83 ec 08             	sub    $0x8,%esp
c002082d:	52                   	push   %edx
c002082e:	50                   	push   %eax
c002082f:	68 d4 f0 02 c0       	push   $0xc002f0d4
c0020834:	68 38 f3 02 c0       	push   $0xc002f338
c0020839:	68 65 01 00 00       	push   $0x165
c002083e:	68 0c f0 02 c0       	push   $0xc002f00c
c0020843:	e8 da 97 00 00       	call   c002a022 <debug_panic>
      for (i = 1; i < a->argc; i++)
c0020848:	ff 45 f0             	incl   -0x10(%ebp)
c002084b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002084e:	8b 40 04             	mov    0x4(%eax),%eax
c0020851:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0020854:	7f b1                	jg     c0020807 <run_actions+0x68>

      /* Invoke action and advance. */
      a->function (argv);
c0020856:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020859:	8b 40 08             	mov    0x8(%eax),%eax
c002085c:	83 ec 0c             	sub    $0xc,%esp
c002085f:	ff 75 08             	pushl  0x8(%ebp)
c0020862:	ff d0                	call   *%eax
c0020864:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020867:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002086a:	8b 40 04             	mov    0x4(%eax),%eax
c002086d:	c1 e0 02             	shl    $0x2,%eax
c0020870:	01 45 08             	add    %eax,0x8(%ebp)
  while (*argv != NULL)
c0020873:	8b 45 08             	mov    0x8(%ebp),%eax
c0020876:	8b 00                	mov    (%eax),%eax
c0020878:	85 c0                	test   %eax,%eax
c002087a:	0f 85 2a ff ff ff    	jne    c00207aa <run_actions+0xb>
    }
  
}
c0020880:	90                   	nop
c0020881:	c9                   	leave  
c0020882:	c3                   	ret    

c0020883 <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c0020883:	55                   	push   %ebp
c0020884:	89 e5                	mov    %esp,%ebp
c0020886:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020889:	83 ec 0c             	sub    $0xc,%esp
c002088c:	68 f8 f0 02 c0       	push   $0xc002f0f8
c0020891:	e8 4d b9 00 00       	call   c002c1e3 <puts>
c0020896:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020899:	e8 cd 6d 00 00       	call   c002766b <shutdown_power_off>

c002089e <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c002089e:	55                   	push   %ebp
c002089f:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00208a4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00208a9:	5d                   	pop    %ebp
c00208aa:	c3                   	ret    

c00208ab <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c00208ab:	55                   	push   %ebp
c00208ac:	89 e5                	mov    %esp,%ebp
c00208ae:	53                   	push   %ebx
c00208af:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00208b2:	e8 51 10 00 00       	call   c0021908 <intr_get_level>
c00208b7:	85 c0                	test   %eax,%eax
c00208b9:	74 1e                	je     c00208d9 <thread_init+0x2e>
c00208bb:	83 ec 0c             	sub    $0xc,%esp
c00208be:	68 44 f3 02 c0       	push   $0xc002f344
c00208c3:	68 62 f3 02 c0       	push   $0xc002f362
c00208c8:	68 04 f5 02 c0       	push   $0xc002f504
c00208cd:	6a 5e                	push   $0x5e
c00208cf:	68 79 f3 02 c0       	push   $0xc002f379
c00208d4:	e8 49 97 00 00       	call   c002a022 <debug_panic>

  lock_init (&tid_lock);
c00208d9:	83 ec 0c             	sub    $0xc,%esp
c00208dc:	68 80 85 03 c0       	push   $0xc0038580
c00208e1:	e8 7c 27 00 00       	call   c0023062 <lock_init>
c00208e6:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c00208e9:	83 ec 0c             	sub    $0xc,%esp
c00208ec:	68 40 85 03 c0       	push   $0xc0038540
c00208f1:	e8 9d 99 00 00       	call   c002a293 <list_init>
c00208f6:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c00208f9:	83 ec 0c             	sub    $0xc,%esp
c00208fc:	68 50 85 03 c0       	push   $0xc0038550
c0020901:	e8 8d 99 00 00       	call   c002a293 <list_init>
c0020906:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020909:	e8 25 07 00 00       	call   c0021033 <running_thread>
c002090e:	a3 64 85 03 c0       	mov    %eax,0xc0038564
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020913:	a1 64 85 03 c0       	mov    0xc0038564,%eax
c0020918:	83 ec 04             	sub    $0x4,%esp
c002091b:	6a 1f                	push   $0x1f
c002091d:	68 90 f3 02 c0       	push   $0xc002f390
c0020922:	50                   	push   %eax
c0020923:	e8 4a 07 00 00       	call   c0021072 <init_thread>
c0020928:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c002092b:	a1 64 85 03 c0       	mov    0xc0038564,%eax
c0020930:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020937:	8b 1d 64 85 03 c0    	mov    0xc0038564,%ebx
c002093d:	e8 b4 0a 00 00       	call   c00213f6 <allocate_tid>
c0020942:	89 03                	mov    %eax,(%ebx)

  load_avg = convert_to_fixed_point(0);
c0020944:	83 ec 0c             	sub    $0xc,%esp
c0020947:	6a 00                	push   $0x0
c0020949:	e8 c2 95 00 00       	call   c0029f10 <convert_to_fixed_point>
c002094e:	83 c4 10             	add    $0x10,%esp
c0020951:	a3 2c a1 03 c0       	mov    %eax,0xc003a12c
  // if (thread_mlfqs)
  //   printf("123\n");
  // else
  //   printf("1243421\n");
}
c0020956:	90                   	nop
c0020957:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002095a:	c9                   	leave  
c002095b:	c3                   	ret    

c002095c <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c002095c:	55                   	push   %ebp
c002095d:	89 e5                	mov    %esp,%ebp
c002095f:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c0020962:	83 ec 08             	sub    $0x8,%esp
c0020965:	6a 00                	push   $0x0
c0020967:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002096a:	50                   	push   %eax
c002096b:	e8 0c 24 00 00       	call   c0022d7c <sema_init>
c0020970:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c0020973:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020976:	50                   	push   %eax
c0020977:	68 bc 0f 02 c0       	push   $0xc0020fbc
c002097c:	6a 00                	push   $0x0
c002097e:	68 95 f3 02 c0       	push   $0xc002f395
c0020983:	e8 d4 00 00 00       	call   c0020a5c <thread_create>
c0020988:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c002098b:	e8 af 0f 00 00       	call   c002193f <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c0020990:	83 ec 0c             	sub    $0xc,%esp
c0020993:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020996:	50                   	push   %eax
c0020997:	e8 27 24 00 00       	call   c0022dc3 <sema_down>
c002099c:	83 c4 10             	add    $0x10,%esp
}
c002099f:	90                   	nop
c00209a0:	c9                   	leave  
c00209a1:	c3                   	ret    

c00209a2 <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c00209a2:	55                   	push   %ebp
c00209a3:	89 e5                	mov    %esp,%ebp
c00209a5:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c00209a8:	e8 de 02 00 00       	call   c0020c8b <thread_current>
c00209ad:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c00209b0:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c00209b5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00209b8:	75 1e                	jne    c00209d8 <thread_tick+0x36>
    idle_ticks++;
c00209ba:	a1 a8 85 03 c0       	mov    0xc00385a8,%eax
c00209bf:	8b 15 ac 85 03 c0    	mov    0xc00385ac,%edx
c00209c5:	83 c0 01             	add    $0x1,%eax
c00209c8:	83 d2 00             	adc    $0x0,%edx
c00209cb:	a3 a8 85 03 c0       	mov    %eax,0xc00385a8
c00209d0:	89 15 ac 85 03 c0    	mov    %edx,0xc00385ac
c00209d6:	eb 1c                	jmp    c00209f4 <thread_tick+0x52>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c00209d8:	a1 b0 85 03 c0       	mov    0xc00385b0,%eax
c00209dd:	8b 15 b4 85 03 c0    	mov    0xc00385b4,%edx
c00209e3:	83 c0 01             	add    $0x1,%eax
c00209e6:	83 d2 00             	adc    $0x0,%edx
c00209e9:	a3 b0 85 03 c0       	mov    %eax,0xc00385b0
c00209ee:	89 15 b4 85 03 c0    	mov    %edx,0xc00385b4

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c00209f4:	a1 c0 85 03 c0       	mov    0xc00385c0,%eax
c00209f9:	40                   	inc    %eax
c00209fa:	a3 c0 85 03 c0       	mov    %eax,0xc00385c0
c00209ff:	a1 c0 85 03 c0       	mov    0xc00385c0,%eax
c0020a04:	83 f8 03             	cmp    $0x3,%eax
c0020a07:	76 05                	jbe    c0020a0e <thread_tick+0x6c>
    intr_yield_on_return ();
c0020a09:	e8 46 12 00 00       	call   c0021c54 <intr_yield_on_return>
}
c0020a0e:	90                   	nop
c0020a0f:	c9                   	leave  
c0020a10:	c3                   	ret    

c0020a11 <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020a11:	55                   	push   %ebp
c0020a12:	89 e5                	mov    %esp,%ebp
c0020a14:	57                   	push   %edi
c0020a15:	56                   	push   %esi
c0020a16:	53                   	push   %ebx
c0020a17:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020a1a:	8b 35 b8 85 03 c0    	mov    0xc00385b8,%esi
c0020a20:	8b 3d bc 85 03 c0    	mov    0xc00385bc,%edi
c0020a26:	8b 0d b0 85 03 c0    	mov    0xc00385b0,%ecx
c0020a2c:	8b 1d b4 85 03 c0    	mov    0xc00385b4,%ebx
c0020a32:	a1 a8 85 03 c0       	mov    0xc00385a8,%eax
c0020a37:	8b 15 ac 85 03 c0    	mov    0xc00385ac,%edx
c0020a3d:	83 ec 04             	sub    $0x4,%esp
c0020a40:	57                   	push   %edi
c0020a41:	56                   	push   %esi
c0020a42:	53                   	push   %ebx
c0020a43:	51                   	push   %ecx
c0020a44:	52                   	push   %edx
c0020a45:	50                   	push   %eax
c0020a46:	68 9c f3 02 c0       	push   $0xc002f39c
c0020a4b:	e8 01 71 00 00       	call   c0027b51 <printf>
c0020a50:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020a53:	90                   	nop
c0020a54:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020a57:	5b                   	pop    %ebx
c0020a58:	5e                   	pop    %esi
c0020a59:	5f                   	pop    %edi
c0020a5a:	5d                   	pop    %ebp
c0020a5b:	c3                   	ret    

c0020a5c <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020a5c:	55                   	push   %ebp
c0020a5d:	89 e5                	mov    %esp,%ebp
c0020a5f:	83 ec 28             	sub    $0x28,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020a62:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020a66:	75 21                	jne    c0020a89 <thread_create+0x2d>
c0020a68:	83 ec 0c             	sub    $0xc,%esp
c0020a6b:	68 d9 f3 02 c0       	push   $0xc002f3d9
c0020a70:	68 62 f3 02 c0       	push   $0xc002f362
c0020a75:	68 10 f5 02 c0       	push   $0xc002f510
c0020a7a:	68 b9 00 00 00       	push   $0xb9
c0020a7f:	68 79 f3 02 c0       	push   $0xc002f379
c0020a84:	e8 99 95 00 00       	call   c002a022 <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020a89:	83 ec 0c             	sub    $0xc,%esp
c0020a8c:	6a 02                	push   $0x2
c0020a8e:	e8 e2 2e 00 00       	call   c0023975 <palloc_get_page>
c0020a93:	83 c4 10             	add    $0x10,%esp
c0020a96:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020a99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020a9d:	75 0a                	jne    c0020aa9 <thread_create+0x4d>
    return TID_ERROR;
c0020a9f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020aa4:	e9 bc 00 00 00       	jmp    c0020b65 <thread_create+0x109>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020aa9:	83 ec 04             	sub    $0x4,%esp
c0020aac:	ff 75 0c             	pushl  0xc(%ebp)
c0020aaf:	ff 75 08             	pushl  0x8(%ebp)
c0020ab2:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ab5:	e8 b8 05 00 00       	call   c0021072 <init_thread>
c0020aba:	83 c4 10             	add    $0x10,%esp

  tid = t->tid = allocate_tid ();
c0020abd:	e8 34 09 00 00       	call   c00213f6 <allocate_tid>
c0020ac2:	89 c2                	mov    %eax,%edx
c0020ac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ac7:	89 10                	mov    %edx,(%eax)
c0020ac9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020acc:	8b 00                	mov    (%eax),%eax
c0020ace:	89 45 f0             	mov    %eax,-0x10(%ebp)

  // printf("%d, create %d\n", thread_current()->tid, tid);

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020ad1:	83 ec 08             	sub    $0x8,%esp
c0020ad4:	6a 0c                	push   $0xc
c0020ad6:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ad9:	e8 f0 06 00 00       	call   c00211ce <alloc_frame>
c0020ade:	83 c4 10             	add    $0x10,%esp
c0020ae1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020ae4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020ae7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020aed:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020af0:	8b 55 10             	mov    0x10(%ebp),%edx
c0020af3:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020af6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020af9:	8b 55 14             	mov    0x14(%ebp),%edx
c0020afc:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020aff:	83 ec 08             	sub    $0x8,%esp
c0020b02:	6a 04                	push   $0x4
c0020b04:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b07:	e8 c2 06 00 00       	call   c00211ce <alloc_frame>
c0020b0c:	83 c4 10             	add    $0x10,%esp
c0020b0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020b12:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020b15:	c7 00 ee 0f 02 c0    	movl   $0xc0020fee,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020b1b:	83 ec 08             	sub    $0x8,%esp
c0020b1e:	6a 1c                	push   $0x1c
c0020b20:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b23:	e8 a6 06 00 00       	call   c00211ce <alloc_frame>
c0020b28:	83 c4 10             	add    $0x10,%esp
c0020b2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020b2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b31:	c7 40 10 de 18 02 c0 	movl   $0xc00218de,0x10(%eax)
  sf->ebp = 0;
c0020b38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020b42:	83 ec 0c             	sub    $0xc,%esp
c0020b45:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b48:	e8 8b 00 00 00       	call   c0020bd8 <thread_unblock>
c0020b4d:	83 c4 10             	add    $0x10,%esp

  if (thread_current() -> priority < priority)
c0020b50:	e8 36 01 00 00       	call   c0020c8b <thread_current>
c0020b55:	8b 40 1c             	mov    0x1c(%eax),%eax
c0020b58:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0020b5b:	7d 05                	jge    c0020b62 <thread_create+0x106>
    thread_yield();
c0020b5d:	e8 1f 02 00 00       	call   c0020d81 <thread_yield>

  return tid;
c0020b62:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020b65:	c9                   	leave  
c0020b66:	c3                   	ret    

c0020b67 <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020b67:	55                   	push   %ebp
c0020b68:	89 e5                	mov    %esp,%ebp
c0020b6a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020b6d:	e8 d8 10 00 00       	call   c0021c4a <intr_context>
c0020b72:	83 f0 01             	xor    $0x1,%eax
c0020b75:	84 c0                	test   %al,%al
c0020b77:	75 21                	jne    c0020b9a <thread_block+0x33>
c0020b79:	83 ec 0c             	sub    $0xc,%esp
c0020b7c:	68 ea f3 02 c0       	push   $0xc002f3ea
c0020b81:	68 62 f3 02 c0       	push   $0xc002f362
c0020b86:	68 20 f5 02 c0       	push   $0xc002f520
c0020b8b:	68 e8 00 00 00       	push   $0xe8
c0020b90:	68 79 f3 02 c0       	push   $0xc002f379
c0020b95:	e8 88 94 00 00       	call   c002a022 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020b9a:	e8 69 0d 00 00       	call   c0021908 <intr_get_level>
c0020b9f:	85 c0                	test   %eax,%eax
c0020ba1:	74 21                	je     c0020bc4 <thread_block+0x5d>
c0020ba3:	83 ec 0c             	sub    $0xc,%esp
c0020ba6:	68 44 f3 02 c0       	push   $0xc002f344
c0020bab:	68 62 f3 02 c0       	push   $0xc002f362
c0020bb0:	68 20 f5 02 c0       	push   $0xc002f520
c0020bb5:	68 e9 00 00 00       	push   $0xe9
c0020bba:	68 79 f3 02 c0       	push   $0xc002f379
c0020bbf:	e8 5e 94 00 00       	call   c002a022 <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020bc4:	e8 c2 00 00 00       	call   c0020c8b <thread_current>
c0020bc9:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020bd0:	e8 4f 07 00 00       	call   c0021324 <schedule>
}
c0020bd5:	90                   	nop
c0020bd6:	c9                   	leave  
c0020bd7:	c3                   	ret    

c0020bd8 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020bd8:	55                   	push   %ebp
c0020bd9:	89 e5                	mov    %esp,%ebp
c0020bdb:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020bde:	83 ec 0c             	sub    $0xc,%esp
c0020be1:	ff 75 08             	pushl  0x8(%ebp)
c0020be4:	e8 62 04 00 00       	call   c002104b <is_thread>
c0020be9:	83 c4 10             	add    $0x10,%esp
c0020bec:	84 c0                	test   %al,%al
c0020bee:	75 21                	jne    c0020c11 <thread_unblock+0x39>
c0020bf0:	83 ec 0c             	sub    $0xc,%esp
c0020bf3:	68 fb f3 02 c0       	push   $0xc002f3fb
c0020bf8:	68 62 f3 02 c0       	push   $0xc002f362
c0020bfd:	68 30 f5 02 c0       	push   $0xc002f530
c0020c02:	68 fc 00 00 00       	push   $0xfc
c0020c07:	68 79 f3 02 c0       	push   $0xc002f379
c0020c0c:	e8 11 94 00 00       	call   c002a022 <debug_panic>

  old_level = intr_disable ();
c0020c11:	e8 67 0d 00 00       	call   c002197d <intr_disable>
c0020c16:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c1c:	8b 40 04             	mov    0x4(%eax),%eax
c0020c1f:	83 f8 02             	cmp    $0x2,%eax
c0020c22:	74 21                	je     c0020c45 <thread_unblock+0x6d>
c0020c24:	83 ec 0c             	sub    $0xc,%esp
c0020c27:	68 09 f4 02 c0       	push   $0xc002f409
c0020c2c:	68 62 f3 02 c0       	push   $0xc002f362
c0020c31:	68 30 f5 02 c0       	push   $0xc002f530
c0020c36:	68 ff 00 00 00       	push   $0xff
c0020c3b:	68 79 f3 02 c0       	push   $0xc002f379
c0020c40:	e8 dd 93 00 00       	call   c002a022 <debug_panic>

  // list_push_back (&ready_list, &t->elem);
  list_insert_ordered(&ready_list, &t->elem, thread_priority_cmp, NULL);
c0020c45:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c48:	83 c0 28             	add    $0x28,%eax
c0020c4b:	6a 00                	push   $0x0
c0020c4d:	68 83 14 02 c0       	push   $0xc0021483
c0020c52:	50                   	push   %eax
c0020c53:	68 40 85 03 c0       	push   $0xc0038540
c0020c58:	e8 d6 a0 00 00       	call   c002ad33 <list_insert_ordered>
c0020c5d:	83 c4 10             	add    $0x10,%esp

  t->status = THREAD_READY;
c0020c60:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c63:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020c6a:	83 ec 0c             	sub    $0xc,%esp
c0020c6d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c70:	e8 b0 0c 00 00       	call   c0021925 <intr_set_level>
c0020c75:	83 c4 10             	add    $0x10,%esp
}
c0020c78:	90                   	nop
c0020c79:	c9                   	leave  
c0020c7a:	c3                   	ret    

c0020c7b <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020c7b:	55                   	push   %ebp
c0020c7c:	89 e5                	mov    %esp,%ebp
c0020c7e:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020c81:	e8 05 00 00 00       	call   c0020c8b <thread_current>
c0020c86:	83 c0 08             	add    $0x8,%eax
}
c0020c89:	c9                   	leave  
c0020c8a:	c3                   	ret    

c0020c8b <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020c8b:	55                   	push   %ebp
c0020c8c:	89 e5                	mov    %esp,%ebp
c0020c8e:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020c91:	e8 9d 03 00 00       	call   c0021033 <running_thread>
c0020c96:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020c99:	83 ec 0c             	sub    $0xc,%esp
c0020c9c:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c9f:	e8 a7 03 00 00       	call   c002104b <is_thread>
c0020ca4:	83 c4 10             	add    $0x10,%esp
c0020ca7:	84 c0                	test   %al,%al
c0020ca9:	75 21                	jne    c0020ccc <thread_current+0x41>
c0020cab:	83 ec 0c             	sub    $0xc,%esp
c0020cae:	68 fb f3 02 c0       	push   $0xc002f3fb
c0020cb3:	68 62 f3 02 c0       	push   $0xc002f362
c0020cb8:	68 40 f5 02 c0       	push   $0xc002f540
c0020cbd:	68 1c 01 00 00       	push   $0x11c
c0020cc2:	68 79 f3 02 c0       	push   $0xc002f379
c0020cc7:	e8 56 93 00 00       	call   c002a022 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020ccc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ccf:	8b 40 04             	mov    0x4(%eax),%eax
c0020cd2:	85 c0                	test   %eax,%eax
c0020cd4:	74 21                	je     c0020cf7 <thread_current+0x6c>
c0020cd6:	83 ec 0c             	sub    $0xc,%esp
c0020cd9:	68 25 f4 02 c0       	push   $0xc002f425
c0020cde:	68 62 f3 02 c0       	push   $0xc002f362
c0020ce3:	68 40 f5 02 c0       	push   $0xc002f540
c0020ce8:	68 1d 01 00 00       	push   $0x11d
c0020ced:	68 79 f3 02 c0       	push   $0xc002f379
c0020cf2:	e8 2b 93 00 00       	call   c002a022 <debug_panic>

  return t;
c0020cf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020cfa:	c9                   	leave  
c0020cfb:	c3                   	ret    

c0020cfc <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020cfc:	55                   	push   %ebp
c0020cfd:	89 e5                	mov    %esp,%ebp
c0020cff:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020d02:	e8 84 ff ff ff       	call   c0020c8b <thread_current>
c0020d07:	8b 00                	mov    (%eax),%eax
}
c0020d09:	c9                   	leave  
c0020d0a:	c3                   	ret    

c0020d0b <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020d0b:	55                   	push   %ebp
c0020d0c:	89 e5                	mov    %esp,%ebp
c0020d0e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020d11:	e8 34 0f 00 00       	call   c0021c4a <intr_context>
c0020d16:	83 f0 01             	xor    $0x1,%eax
c0020d19:	84 c0                	test   %al,%al
c0020d1b:	75 21                	jne    c0020d3e <thread_exit+0x33>
c0020d1d:	83 ec 0c             	sub    $0xc,%esp
c0020d20:	68 ea f3 02 c0       	push   $0xc002f3ea
c0020d25:	68 62 f3 02 c0       	push   $0xc002f362
c0020d2a:	68 50 f5 02 c0       	push   $0xc002f550
c0020d2f:	68 2e 01 00 00       	push   $0x12e
c0020d34:	68 79 f3 02 c0       	push   $0xc002f379
c0020d39:	e8 e4 92 00 00       	call   c002a022 <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020d3e:	e8 3a 0c 00 00       	call   c002197d <intr_disable>
  list_remove (&thread_current()->allelem);
c0020d43:	e8 43 ff ff ff       	call   c0020c8b <thread_current>
c0020d48:	83 c0 20             	add    $0x20,%eax
c0020d4b:	83 ec 0c             	sub    $0xc,%esp
c0020d4e:	50                   	push   %eax
c0020d4f:	e8 45 99 00 00       	call   c002a699 <list_remove>
c0020d54:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020d57:	e8 2f ff ff ff       	call   c0020c8b <thread_current>
c0020d5c:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020d63:	e8 bc 05 00 00       	call   c0021324 <schedule>
  NOT_REACHED ();
c0020d68:	68 44 f4 02 c0       	push   $0xc002f444
c0020d6d:	68 50 f5 02 c0       	push   $0xc002f550
c0020d72:	68 3b 01 00 00       	push   $0x13b
c0020d77:	68 79 f3 02 c0       	push   $0xc002f379
c0020d7c:	e8 a1 92 00 00       	call   c002a022 <debug_panic>

c0020d81 <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020d81:	55                   	push   %ebp
c0020d82:	89 e5                	mov    %esp,%ebp
c0020d84:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020d87:	e8 ff fe ff ff       	call   c0020c8b <thread_current>
c0020d8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020d8f:	e8 b6 0e 00 00       	call   c0021c4a <intr_context>
c0020d94:	83 f0 01             	xor    $0x1,%eax
c0020d97:	84 c0                	test   %al,%al
c0020d99:	75 21                	jne    c0020dbc <thread_yield+0x3b>
c0020d9b:	83 ec 0c             	sub    $0xc,%esp
c0020d9e:	68 ea f3 02 c0       	push   $0xc002f3ea
c0020da3:	68 62 f3 02 c0       	push   $0xc002f362
c0020da8:	68 5c f5 02 c0       	push   $0xc002f55c
c0020dad:	68 46 01 00 00       	push   $0x146
c0020db2:	68 79 f3 02 c0       	push   $0xc002f379
c0020db7:	e8 66 92 00 00       	call   c002a022 <debug_panic>

  old_level = intr_disable ();
c0020dbc:	e8 bc 0b 00 00       	call   c002197d <intr_disable>
c0020dc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020dc4:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c0020dc9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020dcc:	74 1b                	je     c0020de9 <thread_yield+0x68>
    list_insert_ordered(&ready_list, &cur->elem, thread_priority_cmp, NULL);
c0020dce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dd1:	83 c0 28             	add    $0x28,%eax
c0020dd4:	6a 00                	push   $0x0
c0020dd6:	68 83 14 02 c0       	push   $0xc0021483
c0020ddb:	50                   	push   %eax
c0020ddc:	68 40 85 03 c0       	push   $0xc0038540
c0020de1:	e8 4d 9f 00 00       	call   c002ad33 <list_insert_ordered>
c0020de6:	83 c4 10             	add    $0x10,%esp

  cur->status = THREAD_READY;
c0020de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dec:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020df3:	e8 2c 05 00 00       	call   c0021324 <schedule>
  intr_set_level (old_level);
c0020df8:	83 ec 0c             	sub    $0xc,%esp
c0020dfb:	ff 75 f0             	pushl  -0x10(%ebp)
c0020dfe:	e8 22 0b 00 00       	call   c0021925 <intr_set_level>
c0020e03:	83 c4 10             	add    $0x10,%esp
}
c0020e06:	90                   	nop
c0020e07:	c9                   	leave  
c0020e08:	c3                   	ret    

c0020e09 <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020e09:	55                   	push   %ebp
c0020e0a:	89 e5                	mov    %esp,%ebp
c0020e0c:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020e0f:	e8 f4 0a 00 00       	call   c0021908 <intr_get_level>
c0020e14:	85 c0                	test   %eax,%eax
c0020e16:	74 21                	je     c0020e39 <thread_foreach+0x30>
c0020e18:	83 ec 0c             	sub    $0xc,%esp
c0020e1b:	68 44 f3 02 c0       	push   $0xc002f344
c0020e20:	68 62 f3 02 c0       	push   $0xc002f362
c0020e25:	68 6c f5 02 c0       	push   $0xc002f56c
c0020e2a:	68 58 01 00 00       	push   $0x158
c0020e2f:	68 79 f3 02 c0       	push   $0xc002f379
c0020e34:	e8 e9 91 00 00       	call   c002a022 <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e39:	83 ec 0c             	sub    $0xc,%esp
c0020e3c:	68 50 85 03 c0       	push   $0xc0038550
c0020e41:	e8 a2 94 00 00       	call   c002a2e8 <list_begin>
c0020e46:	83 c4 10             	add    $0x10,%esp
c0020e49:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020e4c:	eb 2e                	jmp    c0020e7c <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020e51:	83 c0 04             	add    $0x4,%eax
c0020e54:	83 e8 24             	sub    $0x24,%eax
c0020e57:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0020e5a:	83 ec 08             	sub    $0x8,%esp
c0020e5d:	ff 75 0c             	pushl  0xc(%ebp)
c0020e60:	ff 75 f0             	pushl  -0x10(%ebp)
c0020e63:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e66:	ff d0                	call   *%eax
c0020e68:	83 c4 10             	add    $0x10,%esp
       e = list_next (e))
c0020e6b:	83 ec 0c             	sub    $0xc,%esp
c0020e6e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020e71:	e8 a4 94 00 00       	call   c002a31a <list_next>
c0020e76:	83 c4 10             	add    $0x10,%esp
c0020e79:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e7c:	83 ec 0c             	sub    $0xc,%esp
c0020e7f:	68 50 85 03 c0       	push   $0xc0038550
c0020e84:	e8 db 94 00 00       	call   c002a364 <list_end>
c0020e89:	83 c4 10             	add    $0x10,%esp
c0020e8c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0020e8f:	75 bd                	jne    c0020e4e <thread_foreach+0x45>
    }
}
c0020e91:	90                   	nop
c0020e92:	c9                   	leave  
c0020e93:	c3                   	ret    

c0020e94 <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c0020e94:	55                   	push   %ebp
c0020e95:	89 e5                	mov    %esp,%ebp
c0020e97:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0020e9a:	e8 de 0a 00 00       	call   c002197d <intr_disable>
c0020e9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (! thread_mlfqs)
c0020ea2:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c0020ea7:	83 f0 01             	xor    $0x1,%eax
c0020eaa:	84 c0                	test   %al,%al
c0020eac:	74 4e                	je     c0020efc <thread_set_priority+0x68>
  {
    struct thread* cur_thread = thread_current ();
c0020eae:	e8 d8 fd ff ff       	call   c0020c8b <thread_current>
c0020eb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    cur_thread->old_priority = new_priority;
c0020eb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020eb9:	8b 55 08             	mov    0x8(%ebp),%edx
c0020ebc:	89 50 50             	mov    %edx,0x50(%eax)
    
    thread_update_priority(cur_thread);
c0020ebf:	83 ec 0c             	sub    $0xc,%esp
c0020ec2:	ff 75 f0             	pushl  -0x10(%ebp)
c0020ec5:	e8 b4 06 00 00       	call   c002157e <thread_update_priority>
c0020eca:	83 c4 10             	add    $0x10,%esp
    if (list_empty (&cur_thread->holding_locks) || new_priority > cur_thread->priority)
c0020ecd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020ed0:	83 c0 40             	add    $0x40,%eax
c0020ed3:	83 ec 0c             	sub    $0xc,%esp
c0020ed6:	50                   	push   %eax
c0020ed7:	e8 3e 99 00 00       	call   c002a81a <list_empty>
c0020edc:	83 c4 10             	add    $0x10,%esp
c0020edf:	84 c0                	test   %al,%al
c0020ee1:	75 0b                	jne    c0020eee <thread_set_priority+0x5a>
c0020ee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020ee6:	8b 40 1c             	mov    0x1c(%eax),%eax
c0020ee9:	3b 45 08             	cmp    0x8(%ebp),%eax
c0020eec:	7d 0e                	jge    c0020efc <thread_set_priority+0x68>
    {
      cur_thread->priority = new_priority;
c0020eee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020ef1:	8b 55 08             	mov    0x8(%ebp),%edx
c0020ef4:	89 50 1c             	mov    %edx,0x1c(%eax)
      thread_yield();
c0020ef7:	e8 85 fe ff ff       	call   c0020d81 <thread_yield>
    }
  }

  intr_set_level (old_level);
c0020efc:	83 ec 0c             	sub    $0xc,%esp
c0020eff:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f02:	e8 1e 0a 00 00       	call   c0021925 <intr_set_level>
c0020f07:	83 c4 10             	add    $0x10,%esp
}
c0020f0a:	90                   	nop
c0020f0b:	c9                   	leave  
c0020f0c:	c3                   	ret    

c0020f0d <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020f0d:	55                   	push   %ebp
c0020f0e:	89 e5                	mov    %esp,%ebp
c0020f10:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->priority;
c0020f13:	e8 73 fd ff ff       	call   c0020c8b <thread_current>
c0020f18:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020f1b:	c9                   	leave  
c0020f1c:	c3                   	ret    

c0020f1d <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice) 
{
c0020f1d:	55                   	push   %ebp
c0020f1e:	89 e5                	mov    %esp,%ebp
c0020f20:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable();
c0020f23:	e8 55 0a 00 00       	call   c002197d <intr_disable>
c0020f28:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct thread* cur_thread = thread_current();
c0020f2b:	e8 5b fd ff ff       	call   c0020c8b <thread_current>
c0020f30:	89 45 f0             	mov    %eax,-0x10(%ebp)
  cur_thread->nice_val = nice;
c0020f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020f36:	8b 55 08             	mov    0x8(%ebp),%edx
c0020f39:	89 50 58             	mov    %edx,0x58(%eax)
  thread_update_priority_mlfqs(cur_thread);
c0020f3c:	83 ec 0c             	sub    $0xc,%esp
c0020f3f:	ff 75 f0             	pushl  -0x10(%ebp)
c0020f42:	e8 d1 08 00 00       	call   c0021818 <thread_update_priority_mlfqs>
c0020f47:	83 c4 10             	add    $0x10,%esp
  intr_set_level(old_level);
c0020f4a:	83 ec 0c             	sub    $0xc,%esp
c0020f4d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f50:	e8 d0 09 00 00       	call   c0021925 <intr_set_level>
c0020f55:	83 c4 10             	add    $0x10,%esp
}
c0020f58:	90                   	nop
c0020f59:	c9                   	leave  
c0020f5a:	c3                   	ret    

c0020f5b <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020f5b:	55                   	push   %ebp
c0020f5c:	89 e5                	mov    %esp,%ebp
c0020f5e:	83 ec 08             	sub    $0x8,%esp
  return thread_current()->nice_val;
c0020f61:	e8 25 fd ff ff       	call   c0020c8b <thread_current>
c0020f66:	8b 40 58             	mov    0x58(%eax),%eax
}
c0020f69:	c9                   	leave  
c0020f6a:	c3                   	ret    

c0020f6b <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020f6b:	55                   	push   %ebp
c0020f6c:	89 e5                	mov    %esp,%ebp
c0020f6e:	83 ec 08             	sub    $0x8,%esp
  // int t = ff_mul_with_int(load_avg, 100);
  return convert_to_int_round(ff_mul_with_int(load_avg, 100));
c0020f71:	a1 2c a1 03 c0       	mov    0xc003a12c,%eax
c0020f76:	83 ec 08             	sub    $0x8,%esp
c0020f79:	6a 64                	push   $0x64
c0020f7b:	50                   	push   %eax
c0020f7c:	e8 5e 90 00 00       	call   c0029fdf <ff_mul_with_int>
c0020f81:	83 c4 10             	add    $0x10,%esp
c0020f84:	83 ec 0c             	sub    $0xc,%esp
c0020f87:	50                   	push   %eax
c0020f88:	e8 a2 8f 00 00       	call   c0029f2f <convert_to_int_round>
c0020f8d:	83 c4 10             	add    $0x10,%esp
  // return convert_to_int_round(t);
}
c0020f90:	c9                   	leave  
c0020f91:	c3                   	ret    

c0020f92 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020f92:	55                   	push   %ebp
c0020f93:	89 e5                	mov    %esp,%ebp
c0020f95:	83 ec 08             	sub    $0x8,%esp
  return convert_to_int_round(ff_mul_with_int(thread_current()->recent_cpu, 100));
c0020f98:	e8 ee fc ff ff       	call   c0020c8b <thread_current>
c0020f9d:	8b 40 5c             	mov    0x5c(%eax),%eax
c0020fa0:	83 ec 08             	sub    $0x8,%esp
c0020fa3:	6a 64                	push   $0x64
c0020fa5:	50                   	push   %eax
c0020fa6:	e8 34 90 00 00       	call   c0029fdf <ff_mul_with_int>
c0020fab:	83 c4 10             	add    $0x10,%esp
c0020fae:	83 ec 0c             	sub    $0xc,%esp
c0020fb1:	50                   	push   %eax
c0020fb2:	e8 78 8f 00 00       	call   c0029f2f <convert_to_int_round>
c0020fb7:	83 c4 10             	add    $0x10,%esp
}
c0020fba:	c9                   	leave  
c0020fbb:	c3                   	ret    

c0020fbc <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0020fbc:	55                   	push   %ebp
c0020fbd:	89 e5                	mov    %esp,%ebp
c0020fbf:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0020fc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0020fc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c0020fc8:	e8 be fc ff ff       	call   c0020c8b <thread_current>
c0020fcd:	a3 60 85 03 c0       	mov    %eax,0xc0038560
  sema_up (idle_started);
c0020fd2:	83 ec 0c             	sub    $0xc,%esp
c0020fd5:	ff 75 f4             	pushl  -0xc(%ebp)
c0020fd8:	e8 f4 1e 00 00       	call   c0022ed1 <sema_up>
c0020fdd:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c0020fe0:	e8 98 09 00 00       	call   c002197d <intr_disable>
      thread_block ();
c0020fe5:	e8 7d fb ff ff       	call   c0020b67 <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c0020fea:	fb                   	sti    
c0020feb:	f4                   	hlt    
      intr_disable ();
c0020fec:	eb f2                	jmp    c0020fe0 <idle+0x24>

c0020fee <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0020fee:	55                   	push   %ebp
c0020fef:	89 e5                	mov    %esp,%ebp
c0020ff1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c0020ff4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020ff8:	75 21                	jne    c002101b <kernel_thread+0x2d>
c0020ffa:	83 ec 0c             	sub    $0xc,%esp
c0020ffd:	68 d9 f3 02 c0       	push   $0xc002f3d9
c0021002:	68 62 f3 02 c0       	push   $0xc002f362
c0021007:	68 7c f5 02 c0       	push   $0xc002f57c
c002100c:	68 ca 01 00 00       	push   $0x1ca
c0021011:	68 79 f3 02 c0       	push   $0xc002f379
c0021016:	e8 07 90 00 00       	call   c002a022 <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c002101b:	e8 1f 09 00 00       	call   c002193f <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021020:	83 ec 0c             	sub    $0xc,%esp
c0021023:	ff 75 0c             	pushl  0xc(%ebp)
c0021026:	8b 45 08             	mov    0x8(%ebp),%eax
c0021029:	ff d0                	call   *%eax
c002102b:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c002102e:	e8 d8 fc ff ff       	call   c0020d0b <thread_exit>

c0021033 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0021033:	55                   	push   %ebp
c0021034:	89 e5                	mov    %esp,%ebp
c0021036:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0021039:	89 e0                	mov    %esp,%eax
c002103b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c002103e:	ff 75 fc             	pushl  -0x4(%ebp)
c0021041:	e8 58 f8 ff ff       	call   c002089e <pg_round_down>
c0021046:	83 c4 04             	add    $0x4,%esp
}
c0021049:	c9                   	leave  
c002104a:	c3                   	ret    

c002104b <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c002104b:	55                   	push   %ebp
c002104c:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c002104e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021052:	74 14                	je     c0021068 <is_thread+0x1d>
c0021054:	8b 45 08             	mov    0x8(%ebp),%eax
c0021057:	8b 40 64             	mov    0x64(%eax),%eax
c002105a:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c002105f:	75 07                	jne    c0021068 <is_thread+0x1d>
c0021061:	b8 01 00 00 00       	mov    $0x1,%eax
c0021066:	eb 05                	jmp    c002106d <is_thread+0x22>
c0021068:	b8 00 00 00 00       	mov    $0x0,%eax
c002106d:	83 e0 01             	and    $0x1,%eax
}
c0021070:	5d                   	pop    %ebp
c0021071:	c3                   	ret    

c0021072 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0021072:	55                   	push   %ebp
c0021073:	89 e5                	mov    %esp,%ebp
c0021075:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c0021078:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002107c:	75 21                	jne    c002109f <init_thread+0x2d>
c002107e:	83 ec 0c             	sub    $0xc,%esp
c0021081:	68 66 f4 02 c0       	push   $0xc002f466
c0021086:	68 62 f3 02 c0       	push   $0xc002f362
c002108b:	68 8c f5 02 c0       	push   $0xc002f58c
c0021090:	68 ed 01 00 00       	push   $0x1ed
c0021095:	68 79 f3 02 c0       	push   $0xc002f379
c002109a:	e8 83 8f 00 00       	call   c002a022 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c002109f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00210a3:	78 06                	js     c00210ab <init_thread+0x39>
c00210a5:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c00210a9:	7e 21                	jle    c00210cc <init_thread+0x5a>
c00210ab:	83 ec 0c             	sub    $0xc,%esp
c00210ae:	68 70 f4 02 c0       	push   $0xc002f470
c00210b3:	68 62 f3 02 c0       	push   $0xc002f362
c00210b8:	68 8c f5 02 c0       	push   $0xc002f58c
c00210bd:	68 ee 01 00 00       	push   $0x1ee
c00210c2:	68 79 f3 02 c0       	push   $0xc002f379
c00210c7:	e8 56 8f 00 00       	call   c002a022 <debug_panic>
  ASSERT (name != NULL);
c00210cc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00210d0:	75 21                	jne    c00210f3 <init_thread+0x81>
c00210d2:	83 ec 0c             	sub    $0xc,%esp
c00210d5:	68 9b f4 02 c0       	push   $0xc002f49b
c00210da:	68 62 f3 02 c0       	push   $0xc002f362
c00210df:	68 8c f5 02 c0       	push   $0xc002f58c
c00210e4:	68 ef 01 00 00       	push   $0x1ef
c00210e9:	68 79 f3 02 c0       	push   $0xc002f379
c00210ee:	e8 2f 8f 00 00       	call   c002a022 <debug_panic>

  memset (t, 0, sizeof *t);
c00210f3:	83 ec 04             	sub    $0x4,%esp
c00210f6:	6a 68                	push   $0x68
c00210f8:	6a 00                	push   $0x0
c00210fa:	ff 75 08             	pushl  0x8(%ebp)
c00210fd:	e8 28 82 00 00       	call   c002932a <memset>
c0021102:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c0021105:	8b 45 08             	mov    0x8(%ebp),%eax
c0021108:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c002110f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021112:	83 c0 08             	add    $0x8,%eax
c0021115:	83 ec 04             	sub    $0x4,%esp
c0021118:	6a 10                	push   $0x10
c002111a:	ff 75 0c             	pushl  0xc(%ebp)
c002111d:	50                   	push   %eax
c002111e:	e8 da 82 00 00       	call   c00293fd <strlcpy>
c0021123:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c0021126:	8b 45 08             	mov    0x8(%ebp),%eax
c0021129:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c002112f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021132:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c0021135:	8b 45 08             	mov    0x8(%ebp),%eax
c0021138:	8b 55 10             	mov    0x10(%ebp),%edx
c002113b:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c002113e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021141:	c7 40 64 4b bf 6a cd 	movl   $0xcd6abf4b,0x64(%eax)

  #ifdef VM
    list_init(&t->mmap_list);
  #endif

  if (!thread_mlfqs) 
c0021148:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002114d:	83 f0 01             	xor    $0x1,%eax
c0021150:	84 c0                	test   %al,%al
c0021152:	74 27                	je     c002117b <init_thread+0x109>
  {
    t->old_priority = priority;
c0021154:	8b 45 08             	mov    0x8(%ebp),%eax
c0021157:	8b 55 10             	mov    0x10(%ebp),%edx
c002115a:	89 50 50             	mov    %edx,0x50(%eax)
    list_init(&t->holding_locks);
c002115d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021160:	83 c0 40             	add    $0x40,%eax
c0021163:	83 ec 0c             	sub    $0xc,%esp
c0021166:	50                   	push   %eax
c0021167:	e8 27 91 00 00       	call   c002a293 <list_init>
c002116c:	83 c4 10             	add    $0x10,%esp
    t->lock_waiting = NULL;
c002116f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021172:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
c0021179:	eb 1f                	jmp    c002119a <init_thread+0x128>
  } else
  {
    t->nice_val = 0;
c002117b:	8b 45 08             	mov    0x8(%ebp),%eax
c002117e:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
    t->recent_cpu = convert_to_fixed_point(0);
c0021185:	83 ec 0c             	sub    $0xc,%esp
c0021188:	6a 00                	push   $0x0
c002118a:	e8 81 8d 00 00       	call   c0029f10 <convert_to_fixed_point>
c002118f:	83 c4 10             	add    $0x10,%esp
c0021192:	89 c2                	mov    %eax,%edx
c0021194:	8b 45 08             	mov    0x8(%ebp),%eax
c0021197:	89 50 5c             	mov    %edx,0x5c(%eax)
  }

  old_level = intr_disable ();
c002119a:	e8 de 07 00 00       	call   c002197d <intr_disable>
c002119f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_insert_ordered (&all_list, &t->allelem, thread_priority_cmp, NULL);
c00211a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00211a5:	83 c0 20             	add    $0x20,%eax
c00211a8:	6a 00                	push   $0x0
c00211aa:	68 83 14 02 c0       	push   $0xc0021483
c00211af:	50                   	push   %eax
c00211b0:	68 50 85 03 c0       	push   $0xc0038550
c00211b5:	e8 79 9b 00 00       	call   c002ad33 <list_insert_ordered>
c00211ba:	83 c4 10             	add    $0x10,%esp

  intr_set_level (old_level);
c00211bd:	83 ec 0c             	sub    $0xc,%esp
c00211c0:	ff 75 f4             	pushl  -0xc(%ebp)
c00211c3:	e8 5d 07 00 00       	call   c0021925 <intr_set_level>
c00211c8:	83 c4 10             	add    $0x10,%esp
}
c00211cb:	90                   	nop
c00211cc:	c9                   	leave  
c00211cd:	c3                   	ret    

c00211ce <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c00211ce:	55                   	push   %ebp
c00211cf:	89 e5                	mov    %esp,%ebp
c00211d1:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c00211d4:	ff 75 08             	pushl  0x8(%ebp)
c00211d7:	e8 6f fe ff ff       	call   c002104b <is_thread>
c00211dc:	83 c4 04             	add    $0x4,%esp
c00211df:	84 c0                	test   %al,%al
c00211e1:	75 21                	jne    c0021204 <alloc_frame+0x36>
c00211e3:	83 ec 0c             	sub    $0xc,%esp
c00211e6:	68 fb f3 02 c0       	push   $0xc002f3fb
c00211eb:	68 62 f3 02 c0       	push   $0xc002f362
c00211f0:	68 98 f5 02 c0       	push   $0xc002f598
c00211f5:	68 1a 02 00 00       	push   $0x21a
c00211fa:	68 79 f3 02 c0       	push   $0xc002f379
c00211ff:	e8 1e 8e 00 00       	call   c002a022 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c0021204:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021207:	83 e0 03             	and    $0x3,%eax
c002120a:	85 c0                	test   %eax,%eax
c002120c:	74 21                	je     c002122f <alloc_frame+0x61>
c002120e:	83 ec 0c             	sub    $0xc,%esp
c0021211:	68 a8 f4 02 c0       	push   $0xc002f4a8
c0021216:	68 62 f3 02 c0       	push   $0xc002f362
c002121b:	68 98 f5 02 c0       	push   $0xc002f598
c0021220:	68 1b 02 00 00       	push   $0x21b
c0021225:	68 79 f3 02 c0       	push   $0xc002f379
c002122a:	e8 f3 8d 00 00       	call   c002a022 <debug_panic>

  t->stack -= size;
c002122f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021232:	8b 40 18             	mov    0x18(%eax),%eax
c0021235:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021238:	f7 da                	neg    %edx
c002123a:	01 c2                	add    %eax,%edx
c002123c:	8b 45 08             	mov    0x8(%ebp),%eax
c002123f:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c0021242:	8b 45 08             	mov    0x8(%ebp),%eax
c0021245:	8b 40 18             	mov    0x18(%eax),%eax
}
c0021248:	c9                   	leave  
c0021249:	c3                   	ret    

c002124a <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c002124a:	55                   	push   %ebp
c002124b:	89 e5                	mov    %esp,%ebp
c002124d:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c0021250:	83 ec 0c             	sub    $0xc,%esp
c0021253:	68 40 85 03 c0       	push   $0xc0038540
c0021258:	e8 bd 95 00 00       	call   c002a81a <list_empty>
c002125d:	83 c4 10             	add    $0x10,%esp
c0021260:	84 c0                	test   %al,%al
c0021262:	74 07                	je     c002126b <next_thread_to_run+0x21>
    return idle_thread;
c0021264:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c0021269:	eb 16                	jmp    c0021281 <next_thread_to_run+0x37>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c002126b:	83 ec 0c             	sub    $0xc,%esp
c002126e:	68 40 85 03 c0       	push   $0xc0038540
c0021273:	e8 7a 94 00 00       	call   c002a6f2 <list_pop_front>
c0021278:	83 c4 10             	add    $0x10,%esp
c002127b:	83 c0 04             	add    $0x4,%eax
c002127e:	83 e8 2c             	sub    $0x2c,%eax
}
c0021281:	c9                   	leave  
c0021282:	c3                   	ret    

c0021283 <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0021283:	55                   	push   %ebp
c0021284:	89 e5                	mov    %esp,%ebp
c0021286:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021289:	e8 a5 fd ff ff       	call   c0021033 <running_thread>
c002128e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c0021291:	e8 72 06 00 00       	call   c0021908 <intr_get_level>
c0021296:	85 c0                	test   %eax,%eax
c0021298:	74 21                	je     c00212bb <thread_schedule_tail+0x38>
c002129a:	83 ec 0c             	sub    $0xc,%esp
c002129d:	68 44 f3 02 c0       	push   $0xc002f344
c00212a2:	68 62 f3 02 c0       	push   $0xc002f362
c00212a7:	68 a4 f5 02 c0       	push   $0xc002f5a4
c00212ac:	68 44 02 00 00       	push   $0x244
c00212b1:	68 79 f3 02 c0       	push   $0xc002f379
c00212b6:	e8 67 8d 00 00       	call   c002a022 <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c00212bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00212be:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c00212c5:	c7 05 c0 85 03 c0 00 	movl   $0x0,0xc00385c0
c00212cc:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c00212cf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00212d3:	74 4c                	je     c0021321 <thread_schedule_tail+0x9e>
c00212d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00212d8:	8b 40 04             	mov    0x4(%eax),%eax
c00212db:	83 f8 03             	cmp    $0x3,%eax
c00212de:	75 41                	jne    c0021321 <thread_schedule_tail+0x9e>
c00212e0:	a1 64 85 03 c0       	mov    0xc0038564,%eax
c00212e5:	39 45 08             	cmp    %eax,0x8(%ebp)
c00212e8:	74 37                	je     c0021321 <thread_schedule_tail+0x9e>
    {
      ASSERT (prev != cur);
c00212ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00212ed:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00212f0:	75 21                	jne    c0021313 <thread_schedule_tail+0x90>
c00212f2:	83 ec 0c             	sub    $0xc,%esp
c00212f5:	68 c6 f4 02 c0       	push   $0xc002f4c6
c00212fa:	68 62 f3 02 c0       	push   $0xc002f362
c00212ff:	68 a4 f5 02 c0       	push   $0xc002f5a4
c0021304:	68 59 02 00 00       	push   $0x259
c0021309:	68 79 f3 02 c0       	push   $0xc002f379
c002130e:	e8 0f 8d 00 00       	call   c002a022 <debug_panic>
      palloc_free_page (prev);
c0021313:	83 ec 0c             	sub    $0xc,%esp
c0021316:	ff 75 08             	pushl  0x8(%ebp)
c0021319:	e8 af 27 00 00       	call   c0023acd <palloc_free_page>
c002131e:	83 c4 10             	add    $0x10,%esp
    }
}
c0021321:	90                   	nop
c0021322:	c9                   	leave  
c0021323:	c3                   	ret    

c0021324 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c0021324:	55                   	push   %ebp
c0021325:	89 e5                	mov    %esp,%ebp
c0021327:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c002132a:	e8 04 fd ff ff       	call   c0021033 <running_thread>
c002132f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c0021332:	e8 13 ff ff ff       	call   c002124a <next_thread_to_run>
c0021337:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c002133a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0021341:	e8 c2 05 00 00       	call   c0021908 <intr_get_level>
c0021346:	85 c0                	test   %eax,%eax
c0021348:	74 21                	je     c002136b <schedule+0x47>
c002134a:	83 ec 0c             	sub    $0xc,%esp
c002134d:	68 44 f3 02 c0       	push   $0xc002f344
c0021352:	68 62 f3 02 c0       	push   $0xc002f362
c0021357:	68 bc f5 02 c0       	push   $0xc002f5bc
c002135c:	68 6c 02 00 00       	push   $0x26c
c0021361:	68 79 f3 02 c0       	push   $0xc002f379
c0021366:	e8 b7 8c 00 00       	call   c002a022 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c002136b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002136e:	8b 40 04             	mov    0x4(%eax),%eax
c0021371:	85 c0                	test   %eax,%eax
c0021373:	75 21                	jne    c0021396 <schedule+0x72>
c0021375:	83 ec 0c             	sub    $0xc,%esp
c0021378:	68 d2 f4 02 c0       	push   $0xc002f4d2
c002137d:	68 62 f3 02 c0       	push   $0xc002f362
c0021382:	68 bc f5 02 c0       	push   $0xc002f5bc
c0021387:	68 6d 02 00 00       	push   $0x26d
c002138c:	68 79 f3 02 c0       	push   $0xc002f379
c0021391:	e8 8c 8c 00 00       	call   c002a022 <debug_panic>
  ASSERT (is_thread (next));
c0021396:	83 ec 0c             	sub    $0xc,%esp
c0021399:	ff 75 ec             	pushl  -0x14(%ebp)
c002139c:	e8 aa fc ff ff       	call   c002104b <is_thread>
c00213a1:	83 c4 10             	add    $0x10,%esp
c00213a4:	84 c0                	test   %al,%al
c00213a6:	75 21                	jne    c00213c9 <schedule+0xa5>
c00213a8:	83 ec 0c             	sub    $0xc,%esp
c00213ab:	68 f0 f4 02 c0       	push   $0xc002f4f0
c00213b0:	68 62 f3 02 c0       	push   $0xc002f362
c00213b5:	68 bc f5 02 c0       	push   $0xc002f5bc
c00213ba:	68 6e 02 00 00       	push   $0x26e
c00213bf:	68 79 f3 02 c0       	push   $0xc002f379
c00213c4:	e8 59 8c 00 00       	call   c002a022 <debug_panic>

  if (cur != next)
c00213c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00213cc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00213cf:	74 14                	je     c00213e5 <schedule+0xc1>
    prev = switch_threads (cur, next);
c00213d1:	83 ec 08             	sub    $0x8,%esp
c00213d4:	ff 75 ec             	pushl  -0x14(%ebp)
c00213d7:	ff 75 f0             	pushl  -0x10(%ebp)
c00213da:	e8 e2 04 00 00       	call   c00218c1 <switch_threads>
c00213df:	83 c4 10             	add    $0x10,%esp
c00213e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c00213e5:	83 ec 0c             	sub    $0xc,%esp
c00213e8:	ff 75 f4             	pushl  -0xc(%ebp)
c00213eb:	e8 93 fe ff ff       	call   c0021283 <thread_schedule_tail>
c00213f0:	83 c4 10             	add    $0x10,%esp
}
c00213f3:	90                   	nop
c00213f4:	c9                   	leave  
c00213f5:	c3                   	ret    

c00213f6 <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c00213f6:	55                   	push   %ebp
c00213f7:	89 e5                	mov    %esp,%ebp
c00213f9:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c00213fc:	83 ec 0c             	sub    $0xc,%esp
c00213ff:	68 80 85 03 c0       	push   $0xc0038580
c0021404:	e8 a6 1c 00 00       	call   c00230af <lock_acquire>
c0021409:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c002140c:	a1 88 7b 03 c0       	mov    0xc0037b88,%eax
c0021411:	8d 50 01             	lea    0x1(%eax),%edx
c0021414:	89 15 88 7b 03 c0    	mov    %edx,0xc0037b88
c002141a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c002141d:	83 ec 0c             	sub    $0xc,%esp
c0021420:	68 80 85 03 c0       	push   $0xc0038580
c0021425:	e8 b6 1e 00 00       	call   c00232e0 <lock_release>
c002142a:	83 c4 10             	add    $0x10,%esp

  return tid;
c002142d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021430:	c9                   	leave  
c0021431:	c3                   	ret    

c0021432 <sleep_thread_cmp>:


/* Used to compare the wake up time for threads */
bool
sleep_thread_cmp (const struct list_elem* t1, const struct list_elem* t2, void* aux)
{
c0021432:	55                   	push   %ebp
c0021433:	89 e5                	mov    %esp,%ebp
c0021435:	56                   	push   %esi
c0021436:	53                   	push   %ebx
c0021437:	83 ec 10             	sub    $0x10,%esp
  struct thread* thread1 = list_entry(t1, struct thread, sleepelem);
c002143a:	8b 45 08             	mov    0x8(%ebp),%eax
c002143d:	83 c0 04             	add    $0x4,%eax
c0021440:	83 e8 3c             	sub    $0x3c,%eax
c0021443:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct thread* thread2 = list_entry(t2, struct thread, sleepelem);
c0021446:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021449:	83 c0 04             	add    $0x4,%eax
c002144c:	83 e8 3c             	sub    $0x3c,%eax
c002144f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  return thread1->wake_tick <= thread2->wake_tick;
c0021452:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021455:	8b 48 30             	mov    0x30(%eax),%ecx
c0021458:	8b 58 34             	mov    0x34(%eax),%ebx
c002145b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002145e:	8b 50 34             	mov    0x34(%eax),%edx
c0021461:	8b 40 30             	mov    0x30(%eax),%eax
c0021464:	be 01 00 00 00       	mov    $0x1,%esi
c0021469:	39 d3                	cmp    %edx,%ebx
c002146b:	7c 0d                	jl     c002147a <sleep_thread_cmp+0x48>
c002146d:	39 d3                	cmp    %edx,%ebx
c002146f:	7f 04                	jg     c0021475 <sleep_thread_cmp+0x43>
c0021471:	39 c1                	cmp    %eax,%ecx
c0021473:	76 05                	jbe    c002147a <sleep_thread_cmp+0x48>
c0021475:	be 00 00 00 00       	mov    $0x0,%esi
c002147a:	89 f0                	mov    %esi,%eax
}
c002147c:	83 c4 10             	add    $0x10,%esp
c002147f:	5b                   	pop    %ebx
c0021480:	5e                   	pop    %esi
c0021481:	5d                   	pop    %ebp
c0021482:	c3                   	ret    

c0021483 <thread_priority_cmp>:

/* Used to compare the priority between threads */
bool
thread_priority_cmp (const struct list_elem* t1, const struct list_elem* t2, void* aux)
{
c0021483:	55                   	push   %ebp
c0021484:	89 e5                	mov    %esp,%ebp
c0021486:	83 ec 10             	sub    $0x10,%esp
  struct thread* thread1 = list_entry(t1, struct thread, elem);
c0021489:	8b 45 08             	mov    0x8(%ebp),%eax
c002148c:	83 c0 04             	add    $0x4,%eax
c002148f:	83 e8 2c             	sub    $0x2c,%eax
c0021492:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct thread* thread2 = list_entry(t2, struct thread, elem);
c0021495:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021498:	83 c0 04             	add    $0x4,%eax
c002149b:	83 e8 2c             	sub    $0x2c,%eax
c002149e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return thread1->priority > thread2->priority;
c00214a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00214a4:	8b 50 1c             	mov    0x1c(%eax),%edx
c00214a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00214aa:	8b 40 1c             	mov    0x1c(%eax),%eax
c00214ad:	39 c2                	cmp    %eax,%edx
c00214af:	0f 9f c0             	setg   %al
}
c00214b2:	c9                   	leave  
c00214b3:	c3                   	ret    

c00214b4 <thread_donate_priority>:

/* Used to donate priority */
void 
thread_donate_priority (const struct thread* donate_to) 
{
c00214b4:	55                   	push   %ebp
c00214b5:	89 e5                	mov    %esp,%ebp
c00214b7:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c00214ba:	e8 be 04 00 00       	call   c002197d <intr_disable>
c00214bf:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_update_priority (donate_to); /* donate_to thread already has a bigger clock */
c00214c2:	83 ec 0c             	sub    $0xc,%esp
c00214c5:	ff 75 08             	pushl  0x8(%ebp)
c00214c8:	e8 b1 00 00 00       	call   c002157e <thread_update_priority>
c00214cd:	83 c4 10             	add    $0x10,%esp

  if (donate_to->status == THREAD_READY) /* let it run immediately */
c00214d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00214d3:	8b 40 04             	mov    0x4(%eax),%eax
c00214d6:	83 f8 01             	cmp    $0x1,%eax
c00214d9:	75 2d                	jne    c0021508 <thread_donate_priority+0x54>
  {
    list_remove (&donate_to->elem);
c00214db:	8b 45 08             	mov    0x8(%ebp),%eax
c00214de:	83 c0 28             	add    $0x28,%eax
c00214e1:	83 ec 0c             	sub    $0xc,%esp
c00214e4:	50                   	push   %eax
c00214e5:	e8 af 91 00 00       	call   c002a699 <list_remove>
c00214ea:	83 c4 10             	add    $0x10,%esp
    list_insert_ordered (&ready_list, &donate_to->elem, thread_priority_cmp, NULL);
c00214ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00214f0:	83 c0 28             	add    $0x28,%eax
c00214f3:	6a 00                	push   $0x0
c00214f5:	68 83 14 02 c0       	push   $0xc0021483
c00214fa:	50                   	push   %eax
c00214fb:	68 40 85 03 c0       	push   $0xc0038540
c0021500:	e8 2e 98 00 00       	call   c002ad33 <list_insert_ordered>
c0021505:	83 c4 10             	add    $0x10,%esp
  }

  intr_set_level (old_level);
c0021508:	83 ec 0c             	sub    $0xc,%esp
c002150b:	ff 75 f4             	pushl  -0xc(%ebp)
c002150e:	e8 12 04 00 00       	call   c0021925 <intr_set_level>
c0021513:	83 c4 10             	add    $0x10,%esp
}
c0021516:	90                   	nop
c0021517:	c9                   	leave  
c0021518:	c3                   	ret    

c0021519 <thread_hold_lock>:

/* let cur_thread hold a lock */
void 
thread_hold_lock (struct lock* lock)
{
c0021519:	55                   	push   %ebp
c002151a:	89 e5                	mov    %esp,%ebp
c002151c:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c002151f:	e8 59 04 00 00       	call   c002197d <intr_disable>
c0021524:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct thread* cur_thread = thread_current();
c0021527:	e8 5f f7 ff ff       	call   c0020c8b <thread_current>
c002152c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  list_insert_ordered (&cur_thread->holding_locks, &lock->lock_elem, lock_priority_cmp, NULL);
c002152f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021532:	8d 50 18             	lea    0x18(%eax),%edx
c0021535:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021538:	83 c0 40             	add    $0x40,%eax
c002153b:	6a 00                	push   $0x0
c002153d:	68 b1 36 02 c0       	push   $0xc00236b1
c0021542:	52                   	push   %edx
c0021543:	50                   	push   %eax
c0021544:	e8 ea 97 00 00       	call   c002ad33 <list_insert_ordered>
c0021549:	83 c4 10             	add    $0x10,%esp
  
  if (cur_thread->priority < lock->max_priority)
c002154c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002154f:	8b 50 1c             	mov    0x1c(%eax),%edx
c0021552:	8b 45 08             	mov    0x8(%ebp),%eax
c0021555:	8b 40 20             	mov    0x20(%eax),%eax
c0021558:	39 c2                	cmp    %eax,%edx
c002155a:	7d 11                	jge    c002156d <thread_hold_lock+0x54>
  {
    cur_thread->priority = lock->max_priority;
c002155c:	8b 45 08             	mov    0x8(%ebp),%eax
c002155f:	8b 50 20             	mov    0x20(%eax),%edx
c0021562:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021565:	89 50 1c             	mov    %edx,0x1c(%eax)
    thread_yield ();
c0021568:	e8 14 f8 ff ff       	call   c0020d81 <thread_yield>
  }

  intr_set_level (old_level);
c002156d:	83 ec 0c             	sub    $0xc,%esp
c0021570:	ff 75 f4             	pushl  -0xc(%ebp)
c0021573:	e8 ad 03 00 00       	call   c0021925 <intr_set_level>
c0021578:	83 c4 10             	add    $0x10,%esp
}
c002157b:	90                   	nop
c002157c:	c9                   	leave  
c002157d:	c3                   	ret    

c002157e <thread_update_priority>:


/* update thread's priority from the holding_locks && its old_priority */
void 
thread_update_priority(struct thread* to_update)
{
c002157e:	55                   	push   %ebp
c002157f:	89 e5                	mov    %esp,%ebp
c0021581:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0021584:	e8 f4 03 00 00       	call   c002197d <intr_disable>
c0021589:	89 45 f0             	mov    %eax,-0x10(%ebp)

  int to_update_priority = to_update->old_priority;
c002158c:	8b 45 08             	mov    0x8(%ebp),%eax
c002158f:	8b 40 50             	mov    0x50(%eax),%eax
c0021592:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (! list_empty(&to_update->holding_locks)) 
c0021595:	8b 45 08             	mov    0x8(%ebp),%eax
c0021598:	83 c0 40             	add    $0x40,%eax
c002159b:	83 ec 0c             	sub    $0xc,%esp
c002159e:	50                   	push   %eax
c002159f:	e8 76 92 00 00       	call   c002a81a <list_empty>
c00215a4:	83 c4 10             	add    $0x10,%esp
c00215a7:	83 f0 01             	xor    $0x1,%eax
c00215aa:	84 c0                	test   %al,%al
c00215ac:	74 45                	je     c00215f3 <thread_update_priority+0x75>
  {
    list_sort(&to_update->holding_locks, lock_priority_cmp, NULL);
c00215ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00215b1:	83 c0 40             	add    $0x40,%eax
c00215b4:	83 ec 04             	sub    $0x4,%esp
c00215b7:	6a 00                	push   $0x0
c00215b9:	68 b1 36 02 c0       	push   $0xc00236b1
c00215be:	50                   	push   %eax
c00215bf:	e8 07 96 00 00       	call   c002abcb <list_sort>
c00215c4:	83 c4 10             	add    $0x10,%esp
    int lock_max_priority;
    lock_max_priority = list_entry (list_front (&to_update->holding_locks), 
c00215c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00215ca:	83 c0 40             	add    $0x40,%eax
c00215cd:	83 ec 0c             	sub    $0xc,%esp
c00215d0:	50                   	push   %eax
c00215d1:	e8 70 91 00 00       	call   c002a746 <list_front>
c00215d6:	83 c4 10             	add    $0x10,%esp
c00215d9:	83 c0 04             	add    $0x4,%eax
c00215dc:	83 e8 1c             	sub    $0x1c,%eax
c00215df:	8b 40 20             	mov    0x20(%eax),%eax
c00215e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                      struct lock, lock_elem)->max_priority;
    if (lock_max_priority > to_update_priority)
c00215e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00215e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00215eb:	7e 06                	jle    c00215f3 <thread_update_priority+0x75>
      to_update_priority = lock_max_priority;
c00215ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00215f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  
  if (to_update->old_priority > to_update_priority)
c00215f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00215f6:	8b 40 50             	mov    0x50(%eax),%eax
c00215f9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00215fc:	7e 09                	jle    c0021607 <thread_update_priority+0x89>
    to_update_priority = to_update->old_priority;
c00215fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0021601:	8b 40 50             	mov    0x50(%eax),%eax
c0021604:	89 45 f4             	mov    %eax,-0xc(%ebp)

  to_update->priority = to_update_priority;
c0021607:	8b 45 08             	mov    0x8(%ebp),%eax
c002160a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002160d:	89 50 1c             	mov    %edx,0x1c(%eax)

  intr_set_level (old_level);
c0021610:	83 ec 0c             	sub    $0xc,%esp
c0021613:	ff 75 f0             	pushl  -0x10(%ebp)
c0021616:	e8 0a 03 00 00       	call   c0021925 <intr_set_level>
c002161b:	83 c4 10             	add    $0x10,%esp
}
c002161e:	90                   	nop
c002161f:	c9                   	leave  
c0021620:	c3                   	ret    

c0021621 <thread_remove_lock>:


/* remove the lock from holding_locks in cur_thread*/
void 
thread_remove_lock(struct lock* to_rm) 
{
c0021621:	55                   	push   %ebp
c0021622:	89 e5                	mov    %esp,%ebp
c0021624:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0021627:	e8 51 03 00 00       	call   c002197d <intr_disable>
c002162c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  struct thread* cur_thread = thread_current();
c002162f:	e8 57 f6 ff ff       	call   c0020c8b <thread_current>
c0021634:	89 45 f0             	mov    %eax,-0x10(%ebp)
  list_remove(&to_rm->lock_elem);
c0021637:	8b 45 08             	mov    0x8(%ebp),%eax
c002163a:	83 c0 18             	add    $0x18,%eax
c002163d:	83 ec 0c             	sub    $0xc,%esp
c0021640:	50                   	push   %eax
c0021641:	e8 53 90 00 00       	call   c002a699 <list_remove>
c0021646:	83 c4 10             	add    $0x10,%esp
  thread_update_priority(cur_thread);
c0021649:	83 ec 0c             	sub    $0xc,%esp
c002164c:	ff 75 f0             	pushl  -0x10(%ebp)
c002164f:	e8 2a ff ff ff       	call   c002157e <thread_update_priority>
c0021654:	83 c4 10             	add    $0x10,%esp

  intr_set_level (old_level);
c0021657:	83 ec 0c             	sub    $0xc,%esp
c002165a:	ff 75 f4             	pushl  -0xc(%ebp)
c002165d:	e8 c3 02 00 00       	call   c0021925 <intr_set_level>
c0021662:	83 c4 10             	add    $0x10,%esp
}
c0021665:	90                   	nop
c0021666:	c9                   	leave  
c0021667:	c3                   	ret    

c0021668 <thread_update_recent_cpu_and_load_avg>:

/* update all recent_cpu and load_avg for mlfqs */
void 
thread_update_recent_cpu_and_load_avg()
{
c0021668:	55                   	push   %ebp
c0021669:	89 e5                	mov    %esp,%ebp
c002166b:	53                   	push   %ebx
c002166c:	83 ec 24             	sub    $0x24,%esp
  struct thread *cur_thread = thread_current ();
c002166f:	e8 17 f6 ff ff       	call   c0020c8b <thread_current>
c0021674:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* update load_avg */
  size_t ready_threads = list_size (&ready_list);
c0021677:	83 ec 0c             	sub    $0xc,%esp
c002167a:	68 40 85 03 c0       	push   $0xc0038540
c002167f:	e8 4a 91 00 00       	call   c002a7ce <list_size>
c0021684:	83 c4 10             	add    $0x10,%esp
c0021687:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (cur_thread != idle_thread)
c002168a:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c002168f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0021692:	74 03                	je     c0021697 <thread_update_recent_cpu_and_load_avg+0x2f>
    ready_threads = ready_threads + 1;
c0021694:	ff 45 f4             	incl   -0xc(%ebp)
  int ff_ready_threads = convert_to_fixed_point (ready_threads);
c0021697:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002169a:	83 ec 0c             	sub    $0xc,%esp
c002169d:	50                   	push   %eax
c002169e:	e8 6d 88 00 00       	call   c0029f10 <convert_to_fixed_point>
c00216a3:	83 c4 10             	add    $0x10,%esp
c00216a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int ff_59_60 = ff_div_with_int (convert_to_fixed_point (59), 60);
c00216a9:	83 ec 0c             	sub    $0xc,%esp
c00216ac:	6a 3b                	push   $0x3b
c00216ae:	e8 5d 88 00 00       	call   c0029f10 <convert_to_fixed_point>
c00216b3:	83 c4 10             	add    $0x10,%esp
c00216b6:	83 ec 08             	sub    $0x8,%esp
c00216b9:	6a 3c                	push   $0x3c
c00216bb:	50                   	push   %eax
c00216bc:	e8 55 89 00 00       	call   c002a016 <ff_div_with_int>
c00216c1:	83 c4 10             	add    $0x10,%esp
c00216c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
  int ff_1_60 = ff_div_with_int (convert_to_fixed_point (1), 60);
c00216c7:	83 ec 0c             	sub    $0xc,%esp
c00216ca:	6a 01                	push   $0x1
c00216cc:	e8 3f 88 00 00       	call   c0029f10 <convert_to_fixed_point>
c00216d1:	83 c4 10             	add    $0x10,%esp
c00216d4:	83 ec 08             	sub    $0x8,%esp
c00216d7:	6a 3c                	push   $0x3c
c00216d9:	50                   	push   %eax
c00216da:	e8 37 89 00 00       	call   c002a016 <ff_div_with_int>
c00216df:	83 c4 10             	add    $0x10,%esp
c00216e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  load_avg = ff_add (ff_mul (ff_59_60, load_avg), ff_mul (ff_1_60, ff_ready_threads));
c00216e5:	83 ec 08             	sub    $0x8,%esp
c00216e8:	ff 75 ec             	pushl  -0x14(%ebp)
c00216eb:	ff 75 e4             	pushl  -0x1c(%ebp)
c00216ee:	e8 ad 88 00 00       	call   c0029fa0 <ff_mul>
c00216f3:	83 c4 10             	add    $0x10,%esp
c00216f6:	89 c3                	mov    %eax,%ebx
c00216f8:	a1 2c a1 03 c0       	mov    0xc003a12c,%eax
c00216fd:	83 ec 08             	sub    $0x8,%esp
c0021700:	50                   	push   %eax
c0021701:	ff 75 e8             	pushl  -0x18(%ebp)
c0021704:	e8 97 88 00 00       	call   c0029fa0 <ff_mul>
c0021709:	83 c4 10             	add    $0x10,%esp
c002170c:	83 ec 08             	sub    $0x8,%esp
c002170f:	53                   	push   %ebx
c0021710:	50                   	push   %eax
c0021711:	e8 4e 88 00 00       	call   c0029f64 <ff_add>
c0021716:	83 c4 10             	add    $0x10,%esp
c0021719:	a3 2c a1 03 c0       	mov    %eax,0xc003a12c
  /* update recent_cpu */
  thread_foreach(thread_update_recent_cpu, NULL);
c002171e:	83 ec 08             	sub    $0x8,%esp
c0021721:	6a 00                	push   $0x0
c0021723:	68 36 17 02 c0       	push   $0xc0021736
c0021728:	e8 dc f6 ff ff       	call   c0020e09 <thread_foreach>
c002172d:	83 c4 10             	add    $0x10,%esp
}
c0021730:	90                   	nop
c0021731:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021734:	c9                   	leave  
c0021735:	c3                   	ret    

c0021736 <thread_update_recent_cpu>:

/* update recent_cpu for a single thread for mlfqs */
void
thread_update_recent_cpu(struct thread *t, void *aux)
{
c0021736:	55                   	push   %ebp
c0021737:	89 e5                	mov    %esp,%ebp
c0021739:	53                   	push   %ebx
c002173a:	83 ec 14             	sub    $0x14,%esp
  if (t == idle_thread)
c002173d:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c0021742:	39 45 08             	cmp    %eax,0x8(%ebp)
c0021745:	0f 84 8e 00 00 00    	je     c00217d9 <thread_update_recent_cpu+0xa3>
    return;
  enum intr_level old_level = intr_disable ();
c002174b:	e8 2d 02 00 00       	call   c002197d <intr_disable>
c0021750:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int timesload_avg = ff_mul_with_int(load_avg, 2);
c0021753:	a1 2c a1 03 c0       	mov    0xc003a12c,%eax
c0021758:	83 ec 08             	sub    $0x8,%esp
c002175b:	6a 02                	push   $0x2
c002175d:	50                   	push   %eax
c002175e:	e8 7c 88 00 00       	call   c0029fdf <ff_mul_with_int>
c0021763:	83 c4 10             	add    $0x10,%esp
c0021766:	89 45 f0             	mov    %eax,-0x10(%ebp)
  // int load_avg_res = ff_div(ff_mul_with_int(load_avg, 2), ff_add_with_int(ff_mul_with_int(load_avg, 2), 1));
  int load_avg_res = ff_div(timesload_avg, ff_add_with_int(timesload_avg, 1));
c0021769:	83 ec 08             	sub    $0x8,%esp
c002176c:	6a 01                	push   $0x1
c002176e:	ff 75 f0             	pushl  -0x10(%ebp)
c0021771:	e8 06 88 00 00       	call   c0029f7c <ff_add_with_int>
c0021776:	83 c4 10             	add    $0x10,%esp
c0021779:	83 ec 08             	sub    $0x8,%esp
c002177c:	50                   	push   %eax
c002177d:	ff 75 f0             	pushl  -0x10(%ebp)
c0021780:	e8 66 88 00 00       	call   c0029feb <ff_div>
c0021785:	83 c4 10             	add    $0x10,%esp
c0021788:	89 45 ec             	mov    %eax,-0x14(%ebp)
  t->recent_cpu = ff_add_with_int(ff_mul(load_avg_res, t->recent_cpu), t->nice_val);
c002178b:	8b 45 08             	mov    0x8(%ebp),%eax
c002178e:	8b 58 58             	mov    0x58(%eax),%ebx
c0021791:	8b 45 08             	mov    0x8(%ebp),%eax
c0021794:	8b 40 5c             	mov    0x5c(%eax),%eax
c0021797:	83 ec 08             	sub    $0x8,%esp
c002179a:	50                   	push   %eax
c002179b:	ff 75 ec             	pushl  -0x14(%ebp)
c002179e:	e8 fd 87 00 00       	call   c0029fa0 <ff_mul>
c00217a3:	83 c4 10             	add    $0x10,%esp
c00217a6:	83 ec 08             	sub    $0x8,%esp
c00217a9:	53                   	push   %ebx
c00217aa:	50                   	push   %eax
c00217ab:	e8 cc 87 00 00       	call   c0029f7c <ff_add_with_int>
c00217b0:	83 c4 10             	add    $0x10,%esp
c00217b3:	89 c2                	mov    %eax,%edx
c00217b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00217b8:	89 50 5c             	mov    %edx,0x5c(%eax)
  thread_update_priority_mlfqs(t);
c00217bb:	83 ec 0c             	sub    $0xc,%esp
c00217be:	ff 75 08             	pushl  0x8(%ebp)
c00217c1:	e8 52 00 00 00       	call   c0021818 <thread_update_priority_mlfqs>
c00217c6:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c00217c9:	83 ec 0c             	sub    $0xc,%esp
c00217cc:	ff 75 f4             	pushl  -0xc(%ebp)
c00217cf:	e8 51 01 00 00       	call   c0021925 <intr_set_level>
c00217d4:	83 c4 10             	add    $0x10,%esp
c00217d7:	eb 01                	jmp    c00217da <thread_update_recent_cpu+0xa4>
    return;
c00217d9:	90                   	nop
}
c00217da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00217dd:	c9                   	leave  
c00217de:	c3                   	ret    

c00217df <thread_update_recent_cpu_one>:

/* update recent_cpu for mlfqs */
void 
thread_update_recent_cpu_one()
{
c00217df:	55                   	push   %ebp
c00217e0:	89 e5                	mov    %esp,%ebp
c00217e2:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur_thread = thread_current ();
c00217e5:	e8 a1 f4 ff ff       	call   c0020c8b <thread_current>
c00217ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (cur_thread == idle_thread)
c00217ed:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c00217f2:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00217f5:	74 1e                	je     c0021815 <thread_update_recent_cpu_one+0x36>
    return;
  cur_thread->recent_cpu = ff_add_with_int (cur_thread->recent_cpu, 1);
c00217f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00217fa:	8b 40 5c             	mov    0x5c(%eax),%eax
c00217fd:	83 ec 08             	sub    $0x8,%esp
c0021800:	6a 01                	push   $0x1
c0021802:	50                   	push   %eax
c0021803:	e8 74 87 00 00       	call   c0029f7c <ff_add_with_int>
c0021808:	83 c4 10             	add    $0x10,%esp
c002180b:	89 c2                	mov    %eax,%edx
c002180d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021810:	89 50 5c             	mov    %edx,0x5c(%eax)
c0021813:	eb 01                	jmp    c0021816 <thread_update_recent_cpu_one+0x37>
    return;
c0021815:	90                   	nop
}
c0021816:	c9                   	leave  
c0021817:	c3                   	ret    

c0021818 <thread_update_priority_mlfqs>:

/* update priority in mlfqs */
void 
thread_update_priority_mlfqs(struct thread* to_update)
{
c0021818:	55                   	push   %ebp
c0021819:	89 e5                	mov    %esp,%ebp
c002181b:	83 ec 18             	sub    $0x18,%esp
  if (to_update == idle_thread)
c002181e:	a1 60 85 03 c0       	mov    0xc0038560,%eax
c0021823:	39 45 08             	cmp    %eax,0x8(%ebp)
c0021826:	0f 84 92 00 00 00    	je     c00218be <thread_update_priority_mlfqs+0xa6>
    return;
  int tmp_priority;
  tmp_priority = ff_div_with_int(to_update->recent_cpu, 4);
c002182c:	8b 45 08             	mov    0x8(%ebp),%eax
c002182f:	8b 40 5c             	mov    0x5c(%eax),%eax
c0021832:	83 ec 08             	sub    $0x8,%esp
c0021835:	6a 04                	push   $0x4
c0021837:	50                   	push   %eax
c0021838:	e8 d9 87 00 00       	call   c002a016 <ff_div_with_int>
c002183d:	83 c4 10             	add    $0x10,%esp
c0021840:	89 45 f4             	mov    %eax,-0xc(%ebp)
  tmp_priority = ff_sub(convert_to_fixed_point(PRI_MAX), tmp_priority);
c0021843:	83 ec 0c             	sub    $0xc,%esp
c0021846:	6a 3f                	push   $0x3f
c0021848:	e8 c3 86 00 00       	call   c0029f10 <convert_to_fixed_point>
c002184d:	83 c4 10             	add    $0x10,%esp
c0021850:	83 ec 08             	sub    $0x8,%esp
c0021853:	ff 75 f4             	pushl  -0xc(%ebp)
c0021856:	50                   	push   %eax
c0021857:	e8 15 87 00 00       	call   c0029f71 <ff_sub>
c002185c:	83 c4 10             	add    $0x10,%esp
c002185f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  // tmp_priority = ff_sub(tmp_priority, ff_mul_with_int(to_update->nice_val, 2));
  tmp_priority = ff_sub(tmp_priority, convert_to_fixed_point(to_update->nice_val * 2));
c0021862:	8b 45 08             	mov    0x8(%ebp),%eax
c0021865:	8b 40 58             	mov    0x58(%eax),%eax
c0021868:	01 c0                	add    %eax,%eax
c002186a:	83 ec 0c             	sub    $0xc,%esp
c002186d:	50                   	push   %eax
c002186e:	e8 9d 86 00 00       	call   c0029f10 <convert_to_fixed_point>
c0021873:	83 c4 10             	add    $0x10,%esp
c0021876:	83 ec 08             	sub    $0x8,%esp
c0021879:	50                   	push   %eax
c002187a:	ff 75 f4             	pushl  -0xc(%ebp)
c002187d:	e8 ef 86 00 00       	call   c0029f71 <ff_sub>
c0021882:	83 c4 10             	add    $0x10,%esp
c0021885:	89 45 f4             	mov    %eax,-0xc(%ebp)
  tmp_priority = convert_to_int_round(tmp_priority);
c0021888:	83 ec 0c             	sub    $0xc,%esp
c002188b:	ff 75 f4             	pushl  -0xc(%ebp)
c002188e:	e8 9c 86 00 00       	call   c0029f2f <convert_to_int_round>
c0021893:	83 c4 10             	add    $0x10,%esp
c0021896:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (tmp_priority < PRI_MIN)
c0021899:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002189d:	79 07                	jns    c00218a6 <thread_update_priority_mlfqs+0x8e>
    tmp_priority = PRI_MIN;
c002189f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  if (tmp_priority > PRI_MAX)
c00218a6:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
c00218aa:	7e 07                	jle    c00218b3 <thread_update_priority_mlfqs+0x9b>
    tmp_priority = PRI_MAX;
c00218ac:	c7 45 f4 3f 00 00 00 	movl   $0x3f,-0xc(%ebp)
  to_update->priority = tmp_priority;
c00218b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00218b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00218b9:	89 50 1c             	mov    %edx,0x1c(%eax)
c00218bc:	eb 01                	jmp    c00218bf <thread_update_priority_mlfqs+0xa7>
    return;
c00218be:	90                   	nop
}
c00218bf:	c9                   	leave  
c00218c0:	c3                   	ret    

c00218c1 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c00218c1:	53                   	push   %ebx
	pushl %ebp
c00218c2:	55                   	push   %ebp
	pushl %esi
c00218c3:	56                   	push   %esi
	pushl %edi
c00218c4:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c00218c5:	8b 15 84 7b 03 c0    	mov    0xc0037b84,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c00218cb:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c00218cf:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c00218d2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c00218d6:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c00218d9:	5f                   	pop    %edi
	popl %esi
c00218da:	5e                   	pop    %esi
	popl %ebp
c00218db:	5d                   	pop    %ebp
	popl %ebx
c00218dc:	5b                   	pop    %ebx
        ret
c00218dd:	c3                   	ret    

c00218de <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c00218de:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c00218e1:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c00218e2:	e8 9c f9 ff ff       	call   c0021283 <thread_schedule_tail>
	addl $4, %esp
c00218e7:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c00218ea:	c3                   	ret    

c00218eb <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00218eb:	55                   	push   %ebp
c00218ec:	89 e5                	mov    %esp,%ebp
c00218ee:	83 ec 08             	sub    $0x8,%esp
c00218f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00218f4:	8b 55 0c             	mov    0xc(%ebp),%edx
c00218f7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00218fb:	88 55 f8             	mov    %dl,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00218fe:	8a 45 f8             	mov    -0x8(%ebp),%al
c0021901:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0021904:	ee                   	out    %al,(%dx)
}
c0021905:	90                   	nop
c0021906:	c9                   	leave  
c0021907:	c3                   	ret    

c0021908 <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021908:	55                   	push   %ebp
c0021909:	89 e5                	mov    %esp,%ebp
c002190b:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c002190e:	9c                   	pushf  
c002190f:	58                   	pop    %eax
c0021910:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021913:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021916:	25 00 02 00 00       	and    $0x200,%eax
c002191b:	85 c0                	test   %eax,%eax
c002191d:	0f 95 c0             	setne  %al
c0021920:	0f b6 c0             	movzbl %al,%eax
}
c0021923:	c9                   	leave  
c0021924:	c3                   	ret    

c0021925 <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021925:	55                   	push   %ebp
c0021926:	89 e5                	mov    %esp,%ebp
c0021928:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c002192b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002192f:	75 07                	jne    c0021938 <intr_set_level+0x13>
c0021931:	e8 09 00 00 00       	call   c002193f <intr_enable>
c0021936:	eb 05                	jmp    c002193d <intr_set_level+0x18>
c0021938:	e8 40 00 00 00       	call   c002197d <intr_disable>
}
c002193d:	c9                   	leave  
c002193e:	c3                   	ret    

c002193f <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c002193f:	55                   	push   %ebp
c0021940:	89 e5                	mov    %esp,%ebp
c0021942:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c0021945:	e8 be ff ff ff       	call   c0021908 <intr_get_level>
c002194a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c002194d:	e8 f8 02 00 00       	call   c0021c4a <intr_context>
c0021952:	83 f0 01             	xor    $0x1,%eax
c0021955:	84 c0                	test   %al,%al
c0021957:	75 1e                	jne    c0021977 <intr_enable+0x38>
c0021959:	83 ec 0c             	sub    $0xc,%esp
c002195c:	68 c8 f5 02 c0       	push   $0xc002f5c8
c0021961:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021966:	68 d8 f9 02 c0       	push   $0xc002f9d8
c002196b:	6a 5b                	push   $0x5b
c002196d:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021972:	e8 ab 86 00 00       	call   c002a022 <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c0021977:	fb                   	sti    

  return old_level;
c0021978:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002197b:	c9                   	leave  
c002197c:	c3                   	ret    

c002197d <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c002197d:	55                   	push   %ebp
c002197e:	89 e5                	mov    %esp,%ebp
c0021980:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c0021983:	e8 80 ff ff ff       	call   c0021908 <intr_get_level>
c0021988:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c002198b:	fa                   	cli    

  return old_level;
c002198c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002198f:	c9                   	leave  
c0021990:	c3                   	ret    

c0021991 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c0021991:	55                   	push   %ebp
c0021992:	89 e5                	mov    %esp,%ebp
c0021994:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c0021997:	e8 f2 02 00 00       	call   c0021c8e <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c002199c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00219a3:	eb 2c                	jmp    c00219d1 <intr_init+0x40>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00219a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00219a8:	8b 04 85 8c 7b 03 c0 	mov    -0x3ffc8474(,%eax,4),%eax
c00219af:	83 ec 08             	sub    $0x8,%esp
c00219b2:	6a 00                	push   $0x0
c00219b4:	50                   	push   %eax
c00219b5:	e8 ce 04 00 00       	call   c0021e88 <make_intr_gate>
c00219ba:	83 c4 10             	add    $0x10,%esp
c00219bd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00219c0:	89 04 cd e0 85 03 c0 	mov    %eax,-0x3ffc7a20(,%ecx,8)
c00219c7:	89 14 cd e4 85 03 c0 	mov    %edx,-0x3ffc7a1c(,%ecx,8)
  for (i = 0; i < INTR_CNT; i++)
c00219ce:	ff 45 f4             	incl   -0xc(%ebp)
c00219d1:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c00219d8:	7e cb                	jle    c00219a5 <intr_init+0x14>

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c00219da:	83 ec 08             	sub    $0x8,%esp
c00219dd:	68 e0 85 03 c0       	push   $0xc00385e0
c00219e2:	68 ff 07 00 00       	push   $0x7ff
c00219e7:	e8 d2 04 00 00       	call   c0021ebe <make_idtr_operand>
c00219ec:	83 c4 10             	add    $0x10,%esp
c00219ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00219f2:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c00219f5:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c00219f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021a00:	eb 11                	jmp    c0021a13 <intr_init+0x82>
    intr_names[i] = "unknown";
c0021a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021a05:	c7 04 85 e0 91 03 c0 	movl   $0xc002f60a,-0x3ffc6e20(,%eax,4)
c0021a0c:	0a f6 02 c0 
  for (i = 0; i < INTR_CNT; i++)
c0021a10:	ff 45 f4             	incl   -0xc(%ebp)
c0021a13:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021a1a:	7e e6                	jle    c0021a02 <intr_init+0x71>
  intr_names[0] = "#DE Divide Error";
c0021a1c:	c7 05 e0 91 03 c0 12 	movl   $0xc002f612,0xc00391e0
c0021a23:	f6 02 c0 
  intr_names[1] = "#DB Debug Exception";
c0021a26:	c7 05 e4 91 03 c0 23 	movl   $0xc002f623,0xc00391e4
c0021a2d:	f6 02 c0 
  intr_names[2] = "NMI Interrupt";
c0021a30:	c7 05 e8 91 03 c0 37 	movl   $0xc002f637,0xc00391e8
c0021a37:	f6 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c0021a3a:	c7 05 ec 91 03 c0 45 	movl   $0xc002f645,0xc00391ec
c0021a41:	f6 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021a44:	c7 05 f0 91 03 c0 5e 	movl   $0xc002f65e,0xc00391f0
c0021a4b:	f6 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021a4e:	c7 05 f4 91 03 c0 78 	movl   $0xc002f678,0xc00391f4
c0021a55:	f6 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021a58:	c7 05 f8 91 03 c0 9b 	movl   $0xc002f69b,0xc00391f8
c0021a5f:	f6 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021a62:	c7 05 fc 91 03 c0 b8 	movl   $0xc002f6b8,0xc00391fc
c0021a69:	f6 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c0021a6c:	c7 05 00 92 03 c0 db 	movl   $0xc002f6db,0xc0039200
c0021a73:	f6 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021a76:	c7 05 04 92 03 c0 f6 	movl   $0xc002f6f6,0xc0039204
c0021a7d:	f6 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c0021a80:	c7 05 08 92 03 c0 12 	movl   $0xc002f712,0xc0039208
c0021a87:	f7 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021a8a:	c7 05 0c 92 03 c0 2c 	movl   $0xc002f72c,0xc003920c
c0021a91:	f7 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c0021a94:	c7 05 10 92 03 c0 44 	movl   $0xc002f744,0xc0039210
c0021a9b:	f7 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c0021a9e:	c7 05 14 92 03 c0 60 	movl   $0xc002f760,0xc0039214
c0021aa5:	f7 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c0021aa8:	c7 05 18 92 03 c0 81 	movl   $0xc002f781,0xc0039218
c0021aaf:	f7 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021ab2:	c7 05 20 92 03 c0 9c 	movl   $0xc002f79c,0xc0039220
c0021ab9:	f7 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021abc:	c7 05 24 92 03 c0 bd 	movl   $0xc002f7bd,0xc0039224
c0021ac3:	f7 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021ac6:	c7 05 28 92 03 c0 db 	movl   $0xc002f7db,0xc0039228
c0021acd:	f7 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021ad0:	c7 05 2c 92 03 c0 f8 	movl   $0xc002f7f8,0xc003922c
c0021ad7:	f7 02 c0 
}
c0021ada:	90                   	nop
c0021adb:	c9                   	leave  
c0021adc:	c3                   	ret    

c0021add <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c0021add:	55                   	push   %ebp
c0021ade:	89 e5                	mov    %esp,%ebp
c0021ae0:	53                   	push   %ebx
c0021ae1:	83 ec 14             	sub    $0x14,%esp
c0021ae4:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ae7:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c0021aea:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021aee:	8b 04 85 e0 8d 03 c0 	mov    -0x3ffc7220(,%eax,4),%eax
c0021af5:	85 c0                	test   %eax,%eax
c0021af7:	74 21                	je     c0021b1a <register_handler+0x3d>
c0021af9:	83 ec 0c             	sub    $0xc,%esp
c0021afc:	68 1a f8 02 c0       	push   $0xc002f81a
c0021b01:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021b06:	68 e4 f9 02 c0       	push   $0xc002f9e4
c0021b0b:	68 a8 00 00 00       	push   $0xa8
c0021b10:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021b15:	e8 08 85 00 00       	call   c002a022 <debug_panic>
  if (level == INTR_ON)
c0021b1a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0021b1e:	75 2e                	jne    c0021b4e <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021b20:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021b24:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b28:	8b 04 85 8c 7b 03 c0 	mov    -0x3ffc8474(,%eax,4),%eax
c0021b2f:	83 ec 08             	sub    $0x8,%esp
c0021b32:	ff 75 0c             	pushl  0xc(%ebp)
c0021b35:	50                   	push   %eax
c0021b36:	e8 68 03 00 00       	call   c0021ea3 <make_trap_gate>
c0021b3b:	83 c4 10             	add    $0x10,%esp
c0021b3e:	89 04 dd e0 85 03 c0 	mov    %eax,-0x3ffc7a20(,%ebx,8)
c0021b45:	89 14 dd e4 85 03 c0 	mov    %edx,-0x3ffc7a1c(,%ebx,8)
c0021b4c:	eb 2c                	jmp    c0021b7a <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021b4e:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021b52:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b56:	8b 04 85 8c 7b 03 c0 	mov    -0x3ffc8474(,%eax,4),%eax
c0021b5d:	83 ec 08             	sub    $0x8,%esp
c0021b60:	ff 75 0c             	pushl  0xc(%ebp)
c0021b63:	50                   	push   %eax
c0021b64:	e8 1f 03 00 00       	call   c0021e88 <make_intr_gate>
c0021b69:	83 c4 10             	add    $0x10,%esp
c0021b6c:	89 04 dd e0 85 03 c0 	mov    %eax,-0x3ffc7a20(,%ebx,8)
c0021b73:	89 14 dd e4 85 03 c0 	mov    %edx,-0x3ffc7a1c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c0021b7a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b7e:	8b 55 14             	mov    0x14(%ebp),%edx
c0021b81:	89 14 85 e0 8d 03 c0 	mov    %edx,-0x3ffc7220(,%eax,4)
  intr_names[vec_no] = name;
c0021b88:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b8c:	8b 55 18             	mov    0x18(%ebp),%edx
c0021b8f:	89 14 85 e0 91 03 c0 	mov    %edx,-0x3ffc6e20(,%eax,4)
}
c0021b96:	90                   	nop
c0021b97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021b9a:	c9                   	leave  
c0021b9b:	c3                   	ret    

c0021b9c <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c0021b9c:	55                   	push   %ebp
c0021b9d:	89 e5                	mov    %esp,%ebp
c0021b9f:	83 ec 18             	sub    $0x18,%esp
c0021ba2:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ba5:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021ba8:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021bac:	76 06                	jbe    c0021bb4 <intr_register_ext+0x18>
c0021bae:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021bb2:	76 21                	jbe    c0021bd5 <intr_register_ext+0x39>
c0021bb4:	83 ec 0c             	sub    $0xc,%esp
c0021bb7:	68 38 f8 02 c0       	push   $0xc002f838
c0021bbc:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021bc1:	68 f8 f9 02 c0       	push   $0xc002f9f8
c0021bc6:	68 b8 00 00 00       	push   $0xb8
c0021bcb:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021bd0:	e8 4d 84 00 00       	call   c002a022 <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021bd5:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021bd9:	83 ec 0c             	sub    $0xc,%esp
c0021bdc:	ff 75 10             	pushl  0x10(%ebp)
c0021bdf:	ff 75 0c             	pushl  0xc(%ebp)
c0021be2:	6a 00                	push   $0x0
c0021be4:	6a 00                	push   $0x0
c0021be6:	50                   	push   %eax
c0021be7:	e8 f1 fe ff ff       	call   c0021add <register_handler>
c0021bec:	83 c4 20             	add    $0x20,%esp
}
c0021bef:	90                   	nop
c0021bf0:	c9                   	leave  
c0021bf1:	c3                   	ret    

c0021bf2 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021bf2:	55                   	push   %ebp
c0021bf3:	89 e5                	mov    %esp,%ebp
c0021bf5:	83 ec 18             	sub    $0x18,%esp
c0021bf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bfb:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021bfe:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021c02:	76 27                	jbe    c0021c2b <intr_register_int+0x39>
c0021c04:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021c08:	77 21                	ja     c0021c2b <intr_register_int+0x39>
c0021c0a:	83 ec 0c             	sub    $0xc,%esp
c0021c0d:	68 5c f8 02 c0       	push   $0xc002f85c
c0021c12:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021c17:	68 0c fa 02 c0       	push   $0xc002fa0c
c0021c1c:	68 cd 00 00 00       	push   $0xcd
c0021c21:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021c26:	e8 f7 83 00 00       	call   c002a022 <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c0021c2b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021c2f:	83 ec 0c             	sub    $0xc,%esp
c0021c32:	ff 75 18             	pushl  0x18(%ebp)
c0021c35:	ff 75 14             	pushl  0x14(%ebp)
c0021c38:	ff 75 10             	pushl  0x10(%ebp)
c0021c3b:	ff 75 0c             	pushl  0xc(%ebp)
c0021c3e:	50                   	push   %eax
c0021c3f:	e8 99 fe ff ff       	call   c0021add <register_handler>
c0021c44:	83 c4 20             	add    $0x20,%esp
}
c0021c47:	90                   	nop
c0021c48:	c9                   	leave  
c0021c49:	c3                   	ret    

c0021c4a <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c0021c4a:	55                   	push   %ebp
c0021c4b:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c0021c4d:	a0 e0 99 03 c0       	mov    0xc00399e0,%al
}
c0021c52:	5d                   	pop    %ebp
c0021c53:	c3                   	ret    

c0021c54 <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c0021c54:	55                   	push   %ebp
c0021c55:	89 e5                	mov    %esp,%ebp
c0021c57:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c0021c5a:	e8 eb ff ff ff       	call   c0021c4a <intr_context>
c0021c5f:	84 c0                	test   %al,%al
c0021c61:	75 21                	jne    c0021c84 <intr_yield_on_return+0x30>
c0021c63:	83 ec 0c             	sub    $0xc,%esp
c0021c66:	68 7b f8 02 c0       	push   $0xc002f87b
c0021c6b:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021c70:	68 20 fa 02 c0       	push   $0xc002fa20
c0021c75:	68 e0 00 00 00       	push   $0xe0
c0021c7a:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021c7f:	e8 9e 83 00 00       	call   c002a022 <debug_panic>
  yield_on_return = true;
c0021c84:	c6 05 e1 99 03 c0 01 	movb   $0x1,0xc00399e1
}
c0021c8b:	90                   	nop
c0021c8c:	c9                   	leave  
c0021c8d:	c3                   	ret    

c0021c8e <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c0021c8e:	55                   	push   %ebp
c0021c8f:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c0021c91:	68 ff 00 00 00       	push   $0xff
c0021c96:	6a 21                	push   $0x21
c0021c98:	e8 4e fc ff ff       	call   c00218eb <outb>
c0021c9d:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c0021ca0:	68 ff 00 00 00       	push   $0xff
c0021ca5:	68 a1 00 00 00       	push   $0xa1
c0021caa:	e8 3c fc ff ff       	call   c00218eb <outb>
c0021caf:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021cb2:	6a 11                	push   $0x11
c0021cb4:	6a 20                	push   $0x20
c0021cb6:	e8 30 fc ff ff       	call   c00218eb <outb>
c0021cbb:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c0021cbe:	6a 20                	push   $0x20
c0021cc0:	6a 21                	push   $0x21
c0021cc2:	e8 24 fc ff ff       	call   c00218eb <outb>
c0021cc7:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c0021cca:	6a 04                	push   $0x4
c0021ccc:	6a 21                	push   $0x21
c0021cce:	e8 18 fc ff ff       	call   c00218eb <outb>
c0021cd3:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021cd6:	6a 01                	push   $0x1
c0021cd8:	6a 21                	push   $0x21
c0021cda:	e8 0c fc ff ff       	call   c00218eb <outb>
c0021cdf:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021ce2:	6a 11                	push   $0x11
c0021ce4:	68 a0 00 00 00       	push   $0xa0
c0021ce9:	e8 fd fb ff ff       	call   c00218eb <outb>
c0021cee:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021cf1:	6a 28                	push   $0x28
c0021cf3:	68 a1 00 00 00       	push   $0xa1
c0021cf8:	e8 ee fb ff ff       	call   c00218eb <outb>
c0021cfd:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0021d00:	6a 02                	push   $0x2
c0021d02:	68 a1 00 00 00       	push   $0xa1
c0021d07:	e8 df fb ff ff       	call   c00218eb <outb>
c0021d0c:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021d0f:	6a 01                	push   $0x1
c0021d11:	68 a1 00 00 00       	push   $0xa1
c0021d16:	e8 d0 fb ff ff       	call   c00218eb <outb>
c0021d1b:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c0021d1e:	6a 00                	push   $0x0
c0021d20:	6a 21                	push   $0x21
c0021d22:	e8 c4 fb ff ff       	call   c00218eb <outb>
c0021d27:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c0021d2a:	6a 00                	push   $0x0
c0021d2c:	68 a1 00 00 00       	push   $0xa1
c0021d31:	e8 b5 fb ff ff       	call   c00218eb <outb>
c0021d36:	83 c4 08             	add    $0x8,%esp
}
c0021d39:	90                   	nop
c0021d3a:	c9                   	leave  
c0021d3b:	c3                   	ret    

c0021d3c <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c0021d3c:	55                   	push   %ebp
c0021d3d:	89 e5                	mov    %esp,%ebp
c0021d3f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021d42:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0021d46:	7e 06                	jle    c0021d4e <pic_end_of_interrupt+0x12>
c0021d48:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0021d4c:	7e 21                	jle    c0021d6f <pic_end_of_interrupt+0x33>
c0021d4e:	83 ec 0c             	sub    $0xc,%esp
c0021d51:	68 8b f8 02 c0       	push   $0xc002f88b
c0021d56:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021d5b:	68 38 fa 02 c0       	push   $0xc002fa38
c0021d60:	68 0b 01 00 00       	push   $0x10b
c0021d65:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021d6a:	e8 b3 82 00 00       	call   c002a022 <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c0021d6f:	83 ec 08             	sub    $0x8,%esp
c0021d72:	6a 20                	push   $0x20
c0021d74:	6a 20                	push   $0x20
c0021d76:	e8 70 fb ff ff       	call   c00218eb <outb>
c0021d7b:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c0021d7e:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c0021d82:	7e 12                	jle    c0021d96 <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c0021d84:	83 ec 08             	sub    $0x8,%esp
c0021d87:	6a 20                	push   $0x20
c0021d89:	68 a0 00 00 00       	push   $0xa0
c0021d8e:	e8 58 fb ff ff       	call   c00218eb <outb>
c0021d93:	83 c4 10             	add    $0x10,%esp
}
c0021d96:	90                   	nop
c0021d97:	c9                   	leave  
c0021d98:	c3                   	ret    

c0021d99 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c0021d99:	55                   	push   %ebp
c0021d9a:	89 e5                	mov    %esp,%ebp
c0021d9c:	57                   	push   %edi
c0021d9d:	56                   	push   %esi
c0021d9e:	53                   	push   %ebx
c0021d9f:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c0021da2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021da6:	75 21                	jne    c0021dc9 <make_gate+0x30>
c0021da8:	83 ec 0c             	sub    $0xc,%esp
c0021dab:	68 a5 f8 02 c0       	push   $0xc002f8a5
c0021db0:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021db5:	68 50 fa 02 c0       	push   $0xc002fa50
c0021dba:	68 2a 01 00 00       	push   $0x12a
c0021dbf:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021dc4:	e8 59 82 00 00       	call   c002a022 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021dc9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021dcd:	78 06                	js     c0021dd5 <make_gate+0x3c>
c0021dcf:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0021dd3:	7e 21                	jle    c0021df6 <make_gate+0x5d>
c0021dd5:	83 ec 0c             	sub    $0xc,%esp
c0021dd8:	68 b6 f8 02 c0       	push   $0xc002f8b6
c0021ddd:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021de2:	68 50 fa 02 c0       	push   $0xc002fa50
c0021de7:	68 2b 01 00 00       	push   $0x12b
c0021dec:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021df1:	e8 2c 82 00 00       	call   c002a022 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021df6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021dfa:	78 06                	js     c0021e02 <make_gate+0x69>
c0021dfc:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c0021e00:	7e 21                	jle    c0021e23 <make_gate+0x8a>
c0021e02:	83 ec 0c             	sub    $0xc,%esp
c0021e05:	68 cb f8 02 c0       	push   $0xc002f8cb
c0021e0a:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021e0f:	68 50 fa 02 c0       	push   $0xc002fa50
c0021e14:	68 2c 01 00 00       	push   $0x12c
c0021e19:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021e1e:	e8 ff 81 00 00       	call   c002a022 <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021e23:	8b 45 08             	mov    0x8(%ebp),%eax
c0021e26:	0f b7 c0             	movzwl %ax,%eax
c0021e29:	0d 00 00 08 00       	or     $0x80000,%eax
c0021e2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021e31:	8b 45 08             	mov    0x8(%ebp),%eax
c0021e34:	25 00 00 ff ff       	and    $0xffff0000,%eax
c0021e39:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c0021e3b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021e3e:	c1 e0 0d             	shl    $0xd,%eax
c0021e41:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021e43:	8b 45 10             	mov    0x10(%ebp),%eax
c0021e46:	c1 e0 08             	shl    $0x8,%eax
c0021e49:	09 d0                	or     %edx,%eax
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021e4b:	80 cc 80             	or     $0x80,%ah
c0021e4e:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c0021e51:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0021e54:	bf 00 00 00 00       	mov    $0x0,%edi
c0021e59:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0021e5c:	ba 00 00 00 00       	mov    $0x0,%edx
c0021e61:	89 c2                	mov    %eax,%edx
c0021e63:	b8 00 00 00 00       	mov    $0x0,%eax
c0021e68:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0021e6b:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0021e6e:	89 f0                	mov    %esi,%eax
c0021e70:	0b 45 d0             	or     -0x30(%ebp),%eax
c0021e73:	89 c1                	mov    %eax,%ecx
c0021e75:	89 f8                	mov    %edi,%eax
c0021e77:	0b 45 d4             	or     -0x2c(%ebp),%eax
c0021e7a:	89 c3                	mov    %eax,%ebx
c0021e7c:	89 c8                	mov    %ecx,%eax
c0021e7e:	89 da                	mov    %ebx,%edx
}
c0021e80:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0021e83:	5b                   	pop    %ebx
c0021e84:	5e                   	pop    %esi
c0021e85:	5f                   	pop    %edi
c0021e86:	5d                   	pop    %ebp
c0021e87:	c3                   	ret    

c0021e88 <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c0021e88:	55                   	push   %ebp
c0021e89:	89 e5                	mov    %esp,%ebp
c0021e8b:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c0021e8e:	83 ec 04             	sub    $0x4,%esp
c0021e91:	6a 0e                	push   $0xe
c0021e93:	ff 75 0c             	pushl  0xc(%ebp)
c0021e96:	ff 75 08             	pushl  0x8(%ebp)
c0021e99:	e8 fb fe ff ff       	call   c0021d99 <make_gate>
c0021e9e:	83 c4 10             	add    $0x10,%esp
}
c0021ea1:	c9                   	leave  
c0021ea2:	c3                   	ret    

c0021ea3 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c0021ea3:	55                   	push   %ebp
c0021ea4:	89 e5                	mov    %esp,%ebp
c0021ea6:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c0021ea9:	83 ec 04             	sub    $0x4,%esp
c0021eac:	6a 0f                	push   $0xf
c0021eae:	ff 75 0c             	pushl  0xc(%ebp)
c0021eb1:	ff 75 08             	pushl  0x8(%ebp)
c0021eb4:	e8 e0 fe ff ff       	call   c0021d99 <make_gate>
c0021eb9:	83 c4 10             	add    $0x10,%esp
}
c0021ebc:	c9                   	leave  
c0021ebd:	c3                   	ret    

c0021ebe <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c0021ebe:	55                   	push   %ebp
c0021ebf:	89 e5                	mov    %esp,%ebp
c0021ec1:	57                   	push   %edi
c0021ec2:	56                   	push   %esi
c0021ec3:	53                   	push   %ebx
c0021ec4:	83 ec 14             	sub    $0x14,%esp
c0021ec7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021eca:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021ece:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0021ed2:	89 c6                	mov    %eax,%esi
c0021ed4:	bf 00 00 00 00       	mov    $0x0,%edi
c0021ed9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021edc:	ba 00 00 00 00       	mov    $0x0,%edx
c0021ee1:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021ee5:	c1 e0 10             	shl    $0x10,%eax
c0021ee8:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0021eeb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0021eee:	89 f0                	mov    %esi,%eax
c0021ef0:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021ef3:	89 c1                	mov    %eax,%ecx
c0021ef5:	89 f8                	mov    %edi,%eax
c0021ef7:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0021efa:	89 c3                	mov    %eax,%ebx
c0021efc:	89 c8                	mov    %ecx,%eax
c0021efe:	89 da                	mov    %ebx,%edx
}
c0021f00:	83 c4 14             	add    $0x14,%esp
c0021f03:	5b                   	pop    %ebx
c0021f04:	5e                   	pop    %esi
c0021f05:	5f                   	pop    %edi
c0021f06:	5d                   	pop    %ebp
c0021f07:	c3                   	ret    

c0021f08 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021f08:	55                   	push   %ebp
c0021f09:	89 e5                	mov    %esp,%ebp
c0021f0b:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021f0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021f11:	8b 40 30             	mov    0x30(%eax),%eax
c0021f14:	83 f8 1f             	cmp    $0x1f,%eax
c0021f17:	76 12                	jbe    c0021f2b <intr_handler+0x23>
c0021f19:	8b 45 08             	mov    0x8(%ebp),%eax
c0021f1c:	8b 40 30             	mov    0x30(%eax),%eax
c0021f1f:	83 f8 2f             	cmp    $0x2f,%eax
c0021f22:	77 07                	ja     c0021f2b <intr_handler+0x23>
c0021f24:	b8 01 00 00 00       	mov    $0x1,%eax
c0021f29:	eb 05                	jmp    c0021f30 <intr_handler+0x28>
c0021f2b:	b8 00 00 00 00       	mov    $0x0,%eax
c0021f30:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021f33:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021f37:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021f3b:	74 65                	je     c0021fa2 <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021f3d:	e8 c6 f9 ff ff       	call   c0021908 <intr_get_level>
c0021f42:	85 c0                	test   %eax,%eax
c0021f44:	74 21                	je     c0021f67 <intr_handler+0x5f>
c0021f46:	83 ec 0c             	sub    $0xc,%esp
c0021f49:	68 e3 f8 02 c0       	push   $0xc002f8e3
c0021f4e:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021f53:	68 5c fa 02 c0       	push   $0xc002fa5c
c0021f58:	68 65 01 00 00       	push   $0x165
c0021f5d:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021f62:	e8 bb 80 00 00       	call   c002a022 <debug_panic>
      ASSERT (!intr_context ());
c0021f67:	e8 de fc ff ff       	call   c0021c4a <intr_context>
c0021f6c:	83 f0 01             	xor    $0x1,%eax
c0021f6f:	84 c0                	test   %al,%al
c0021f71:	75 21                	jne    c0021f94 <intr_handler+0x8c>
c0021f73:	83 ec 0c             	sub    $0xc,%esp
c0021f76:	68 c8 f5 02 c0       	push   $0xc002f5c8
c0021f7b:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0021f80:	68 5c fa 02 c0       	push   $0xc002fa5c
c0021f85:	68 66 01 00 00       	push   $0x166
c0021f8a:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0021f8f:	e8 8e 80 00 00       	call   c002a022 <debug_panic>

      in_external_intr = true;
c0021f94:	c6 05 e0 99 03 c0 01 	movb   $0x1,0xc00399e0
      yield_on_return = false;
c0021f9b:	c6 05 e1 99 03 c0 00 	movb   $0x0,0xc00399e1
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021fa2:	8b 45 08             	mov    0x8(%ebp),%eax
c0021fa5:	8b 40 30             	mov    0x30(%eax),%eax
c0021fa8:	8b 04 85 e0 8d 03 c0 	mov    -0x3ffc7220(,%eax,4),%eax
c0021faf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c0021fb2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0021fb6:	74 10                	je     c0021fc8 <intr_handler+0xc0>
    handler (frame);
c0021fb8:	83 ec 0c             	sub    $0xc,%esp
c0021fbb:	ff 75 08             	pushl  0x8(%ebp)
c0021fbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021fc1:	ff d0                	call   *%eax
c0021fc3:	83 c4 10             	add    $0x10,%esp
c0021fc6:	eb 24                	jmp    c0021fec <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021fc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0021fcb:	8b 40 30             	mov    0x30(%eax),%eax
c0021fce:	83 f8 27             	cmp    $0x27,%eax
c0021fd1:	74 19                	je     c0021fec <intr_handler+0xe4>
c0021fd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0021fd6:	8b 40 30             	mov    0x30(%eax),%eax
c0021fd9:	83 f8 2f             	cmp    $0x2f,%eax
c0021fdc:	74 0e                	je     c0021fec <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c0021fde:	83 ec 0c             	sub    $0xc,%esp
c0021fe1:	ff 75 08             	pushl  0x8(%ebp)
c0021fe4:	e8 87 00 00 00       	call   c0022070 <unexpected_interrupt>
c0021fe9:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021fec:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021ff0:	74 7b                	je     c002206d <intr_handler+0x165>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021ff2:	e8 11 f9 ff ff       	call   c0021908 <intr_get_level>
c0021ff7:	85 c0                	test   %eax,%eax
c0021ff9:	74 21                	je     c002201c <intr_handler+0x114>
c0021ffb:	83 ec 0c             	sub    $0xc,%esp
c0021ffe:	68 e3 f8 02 c0       	push   $0xc002f8e3
c0022003:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0022008:	68 5c fa 02 c0       	push   $0xc002fa5c
c002200d:	68 7c 01 00 00       	push   $0x17c
c0022012:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0022017:	e8 06 80 00 00       	call   c002a022 <debug_panic>
      ASSERT (intr_context ());
c002201c:	e8 29 fc ff ff       	call   c0021c4a <intr_context>
c0022021:	84 c0                	test   %al,%al
c0022023:	75 21                	jne    c0022046 <intr_handler+0x13e>
c0022025:	83 ec 0c             	sub    $0xc,%esp
c0022028:	68 7b f8 02 c0       	push   $0xc002f87b
c002202d:	68 d9 f5 02 c0       	push   $0xc002f5d9
c0022032:	68 5c fa 02 c0       	push   $0xc002fa5c
c0022037:	68 7d 01 00 00       	push   $0x17d
c002203c:	68 f0 f5 02 c0       	push   $0xc002f5f0
c0022041:	e8 dc 7f 00 00       	call   c002a022 <debug_panic>

      in_external_intr = false;
c0022046:	c6 05 e0 99 03 c0 00 	movb   $0x0,0xc00399e0
      pic_end_of_interrupt (frame->vec_no); 
c002204d:	8b 45 08             	mov    0x8(%ebp),%eax
c0022050:	8b 40 30             	mov    0x30(%eax),%eax
c0022053:	83 ec 0c             	sub    $0xc,%esp
c0022056:	50                   	push   %eax
c0022057:	e8 e0 fc ff ff       	call   c0021d3c <pic_end_of_interrupt>
c002205c:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c002205f:	a0 e1 99 03 c0       	mov    0xc00399e1,%al
c0022064:	84 c0                	test   %al,%al
c0022066:	74 05                	je     c002206d <intr_handler+0x165>
        thread_yield (); 
c0022068:	e8 14 ed ff ff       	call   c0020d81 <thread_yield>
    }
}
c002206d:	90                   	nop
c002206e:	c9                   	leave  
c002206f:	c3                   	ret    

c0022070 <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0022070:	55                   	push   %ebp
c0022071:	89 e5                	mov    %esp,%ebp
c0022073:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0022076:	8b 45 08             	mov    0x8(%ebp),%eax
c0022079:	8b 40 30             	mov    0x30(%eax),%eax
c002207c:	8b 14 85 e0 95 03 c0 	mov    -0x3ffc6a20(,%eax,4),%edx
c0022083:	42                   	inc    %edx
c0022084:	89 14 85 e0 95 03 c0 	mov    %edx,-0x3ffc6a20(,%eax,4)
c002208b:	8b 04 85 e0 95 03 c0 	mov    -0x3ffc6a20(,%eax,4),%eax
c0022092:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0022095:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0022098:	48                   	dec    %eax
c0022099:	23 45 f4             	and    -0xc(%ebp),%eax
c002209c:	85 c0                	test   %eax,%eax
c002209e:	75 25                	jne    c00220c5 <unexpected_interrupt+0x55>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c00220a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00220a3:	8b 40 30             	mov    0x30(%eax),%eax
    printf ("Unexpected interrupt %#04x (%s)\n",
c00220a6:	8b 14 85 e0 91 03 c0 	mov    -0x3ffc6e20(,%eax,4),%edx
c00220ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00220b0:	8b 40 30             	mov    0x30(%eax),%eax
c00220b3:	83 ec 04             	sub    $0x4,%esp
c00220b6:	52                   	push   %edx
c00220b7:	50                   	push   %eax
c00220b8:	68 04 f9 02 c0       	push   $0xc002f904
c00220bd:	e8 8f 5a 00 00       	call   c0027b51 <printf>
c00220c2:	83 c4 10             	add    $0x10,%esp
}
c00220c5:	90                   	nop
c00220c6:	c9                   	leave  
c00220c7:	c3                   	ret    

c00220c8 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c00220c8:	55                   	push   %ebp
c00220c9:	89 e5                	mov    %esp,%ebp
c00220cb:	53                   	push   %ebx
c00220cc:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c00220cf:	0f 20 d0             	mov    %cr2,%eax
c00220d2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c00220d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00220d8:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c00220db:	8b 45 08             	mov    0x8(%ebp),%eax
c00220de:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c00220e1:	8b 14 85 e0 91 03 c0 	mov    -0x3ffc6e20(,%eax,4),%edx
c00220e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00220eb:	8b 40 30             	mov    0x30(%eax),%eax
c00220ee:	51                   	push   %ecx
c00220ef:	52                   	push   %edx
c00220f0:	50                   	push   %eax
c00220f1:	68 28 f9 02 c0       	push   $0xc002f928
c00220f6:	e8 56 5a 00 00       	call   c0027b51 <printf>
c00220fb:	83 c4 10             	add    $0x10,%esp
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c00220fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0022101:	8b 40 34             	mov    0x34(%eax),%eax
c0022104:	83 ec 04             	sub    $0x4,%esp
c0022107:	50                   	push   %eax
c0022108:	ff 75 f4             	pushl  -0xc(%ebp)
c002210b:	68 48 f9 02 c0       	push   $0xc002f948
c0022110:	e8 3c 5a 00 00       	call   c0027b51 <printf>
c0022115:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0022118:	8b 45 08             	mov    0x8(%ebp),%eax
c002211b:	8b 58 14             	mov    0x14(%eax),%ebx
c002211e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022121:	8b 48 18             	mov    0x18(%eax),%ecx
c0022124:	8b 45 08             	mov    0x8(%ebp),%eax
c0022127:	8b 50 10             	mov    0x10(%eax),%edx
c002212a:	8b 45 08             	mov    0x8(%ebp),%eax
c002212d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0022130:	83 ec 0c             	sub    $0xc,%esp
c0022133:	53                   	push   %ebx
c0022134:	51                   	push   %ecx
c0022135:	52                   	push   %edx
c0022136:	50                   	push   %eax
c0022137:	68 60 f9 02 c0       	push   $0xc002f960
c002213c:	e8 10 5a 00 00       	call   c0027b51 <printf>
c0022141:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0022144:	8b 45 08             	mov    0x8(%ebp),%eax
c0022147:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c002214a:	8b 45 08             	mov    0x8(%ebp),%eax
c002214d:	8b 40 48             	mov    0x48(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0022150:	89 c3                	mov    %eax,%ebx
c0022152:	8b 45 08             	mov    0x8(%ebp),%eax
c0022155:	8b 10                	mov    (%eax),%edx
c0022157:	8b 45 08             	mov    0x8(%ebp),%eax
c002215a:	8b 40 04             	mov    0x4(%eax),%eax
c002215d:	83 ec 0c             	sub    $0xc,%esp
c0022160:	51                   	push   %ecx
c0022161:	53                   	push   %ebx
c0022162:	52                   	push   %edx
c0022163:	50                   	push   %eax
c0022164:	68 88 f9 02 c0       	push   $0xc002f988
c0022169:	e8 e3 59 00 00       	call   c0027b51 <printf>
c002216e:	83 c4 20             	add    $0x20,%esp
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0022171:	8b 45 08             	mov    0x8(%ebp),%eax
c0022174:	8b 40 4c             	mov    0x4c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022177:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c002217a:	8b 45 08             	mov    0x8(%ebp),%eax
c002217d:	8b 40 28             	mov    0x28(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022180:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0022183:	8b 45 08             	mov    0x8(%ebp),%eax
c0022186:	8b 40 2c             	mov    0x2c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022189:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c002218c:	8b 45 08             	mov    0x8(%ebp),%eax
c002218f:	8b 40 40             	mov    0x40(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022192:	0f b7 c0             	movzwl %ax,%eax
c0022195:	83 ec 0c             	sub    $0xc,%esp
c0022198:	53                   	push   %ebx
c0022199:	51                   	push   %ecx
c002219a:	52                   	push   %edx
c002219b:	50                   	push   %eax
c002219c:	68 b0 f9 02 c0       	push   $0xc002f9b0
c00221a1:	e8 ab 59 00 00       	call   c0027b51 <printf>
c00221a6:	83 c4 20             	add    $0x20,%esp
}
c00221a9:	90                   	nop
c00221aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00221ad:	c9                   	leave  
c00221ae:	c3                   	ret    

c00221af <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c00221af:	55                   	push   %ebp
c00221b0:	89 e5                	mov    %esp,%ebp
c00221b2:	83 ec 04             	sub    $0x4,%esp
c00221b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00221b8:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c00221bb:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00221bf:	8b 04 85 e0 91 03 c0 	mov    -0x3ffc6e20(,%eax,4),%eax
}
c00221c6:	c9                   	leave  
c00221c7:	c3                   	ret    

c00221c8 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c00221c8:	1e                   	push   %ds
	pushl %es
c00221c9:	06                   	push   %es
	pushl %fs
c00221ca:	0f a0                	push   %fs
	pushl %gs
c00221cc:	0f a8                	push   %gs
	pushal
c00221ce:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c00221cf:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c00221d0:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00221d5:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00221d7:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00221d9:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00221dd:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c00221de:	e8 25 fd ff ff       	call   c0021f08 <intr_handler>
	addl $4, %esp
c00221e3:	83 c4 04             	add    $0x4,%esp

c00221e6 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c00221e6:	61                   	popa   
	popl %gs
c00221e7:	0f a9                	pop    %gs
	popl %fs
c00221e9:	0f a1                	pop    %fs
	popl %es
c00221eb:	07                   	pop    %es
	popl %ds
c00221ec:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c00221ed:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c00221f0:	cf                   	iret   

c00221f1 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c00221f1:	55                   	push   %ebp
c00221f2:	6a 00                	push   $0x0
c00221f4:	6a 00                	push   $0x0
c00221f6:	eb d0                	jmp    c00221c8 <intr_entry>

c00221f8 <intr01_stub>:
c00221f8:	55                   	push   %ebp
c00221f9:	6a 00                	push   $0x0
c00221fb:	6a 01                	push   $0x1
c00221fd:	eb c9                	jmp    c00221c8 <intr_entry>

c00221ff <intr02_stub>:
c00221ff:	55                   	push   %ebp
c0022200:	6a 00                	push   $0x0
c0022202:	6a 02                	push   $0x2
c0022204:	eb c2                	jmp    c00221c8 <intr_entry>

c0022206 <intr03_stub>:
c0022206:	55                   	push   %ebp
c0022207:	6a 00                	push   $0x0
c0022209:	6a 03                	push   $0x3
c002220b:	eb bb                	jmp    c00221c8 <intr_entry>

c002220d <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c002220d:	55                   	push   %ebp
c002220e:	6a 00                	push   $0x0
c0022210:	6a 04                	push   $0x4
c0022212:	eb b4                	jmp    c00221c8 <intr_entry>

c0022214 <intr05_stub>:
c0022214:	55                   	push   %ebp
c0022215:	6a 00                	push   $0x0
c0022217:	6a 05                	push   $0x5
c0022219:	eb ad                	jmp    c00221c8 <intr_entry>

c002221b <intr06_stub>:
c002221b:	55                   	push   %ebp
c002221c:	6a 00                	push   $0x0
c002221e:	6a 06                	push   $0x6
c0022220:	eb a6                	jmp    c00221c8 <intr_entry>

c0022222 <intr07_stub>:
c0022222:	55                   	push   %ebp
c0022223:	6a 00                	push   $0x0
c0022225:	6a 07                	push   $0x7
c0022227:	eb 9f                	jmp    c00221c8 <intr_entry>

c0022229 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0022229:	ff 34 24             	pushl  (%esp)
c002222c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022230:	6a 08                	push   $0x8
c0022232:	eb 94                	jmp    c00221c8 <intr_entry>

c0022234 <intr09_stub>:
c0022234:	55                   	push   %ebp
c0022235:	6a 00                	push   $0x0
c0022237:	6a 09                	push   $0x9
c0022239:	eb 8d                	jmp    c00221c8 <intr_entry>

c002223b <intr0a_stub>:
c002223b:	ff 34 24             	pushl  (%esp)
c002223e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022242:	6a 0a                	push   $0xa
c0022244:	eb 82                	jmp    c00221c8 <intr_entry>

c0022246 <intr0b_stub>:
c0022246:	ff 34 24             	pushl  (%esp)
c0022249:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002224d:	6a 0b                	push   $0xb
c002224f:	e9 74 ff ff ff       	jmp    c00221c8 <intr_entry>

c0022254 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0022254:	55                   	push   %ebp
c0022255:	6a 00                	push   $0x0
c0022257:	6a 0c                	push   $0xc
c0022259:	e9 6a ff ff ff       	jmp    c00221c8 <intr_entry>

c002225e <intr0d_stub>:
c002225e:	ff 34 24             	pushl  (%esp)
c0022261:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022265:	6a 0d                	push   $0xd
c0022267:	e9 5c ff ff ff       	jmp    c00221c8 <intr_entry>

c002226c <intr0e_stub>:
c002226c:	ff 34 24             	pushl  (%esp)
c002226f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022273:	6a 0e                	push   $0xe
c0022275:	e9 4e ff ff ff       	jmp    c00221c8 <intr_entry>

c002227a <intr0f_stub>:
c002227a:	55                   	push   %ebp
c002227b:	6a 00                	push   $0x0
c002227d:	6a 0f                	push   $0xf
c002227f:	e9 44 ff ff ff       	jmp    c00221c8 <intr_entry>

c0022284 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0022284:	55                   	push   %ebp
c0022285:	6a 00                	push   $0x0
c0022287:	6a 10                	push   $0x10
c0022289:	e9 3a ff ff ff       	jmp    c00221c8 <intr_entry>

c002228e <intr11_stub>:
c002228e:	ff 34 24             	pushl  (%esp)
c0022291:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022295:	6a 11                	push   $0x11
c0022297:	e9 2c ff ff ff       	jmp    c00221c8 <intr_entry>

c002229c <intr12_stub>:
c002229c:	55                   	push   %ebp
c002229d:	6a 00                	push   $0x0
c002229f:	6a 12                	push   $0x12
c00222a1:	e9 22 ff ff ff       	jmp    c00221c8 <intr_entry>

c00222a6 <intr13_stub>:
c00222a6:	55                   	push   %ebp
c00222a7:	6a 00                	push   $0x0
c00222a9:	6a 13                	push   $0x13
c00222ab:	e9 18 ff ff ff       	jmp    c00221c8 <intr_entry>

c00222b0 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c00222b0:	55                   	push   %ebp
c00222b1:	6a 00                	push   $0x0
c00222b3:	6a 14                	push   $0x14
c00222b5:	e9 0e ff ff ff       	jmp    c00221c8 <intr_entry>

c00222ba <intr15_stub>:
c00222ba:	55                   	push   %ebp
c00222bb:	6a 00                	push   $0x0
c00222bd:	6a 15                	push   $0x15
c00222bf:	e9 04 ff ff ff       	jmp    c00221c8 <intr_entry>

c00222c4 <intr16_stub>:
c00222c4:	55                   	push   %ebp
c00222c5:	6a 00                	push   $0x0
c00222c7:	6a 16                	push   $0x16
c00222c9:	e9 fa fe ff ff       	jmp    c00221c8 <intr_entry>

c00222ce <intr17_stub>:
c00222ce:	55                   	push   %ebp
c00222cf:	6a 00                	push   $0x0
c00222d1:	6a 17                	push   $0x17
c00222d3:	e9 f0 fe ff ff       	jmp    c00221c8 <intr_entry>

c00222d8 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00222d8:	ff 34 24             	pushl  (%esp)
c00222db:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00222df:	6a 18                	push   $0x18
c00222e1:	e9 e2 fe ff ff       	jmp    c00221c8 <intr_entry>

c00222e6 <intr19_stub>:
c00222e6:	55                   	push   %ebp
c00222e7:	6a 00                	push   $0x0
c00222e9:	6a 19                	push   $0x19
c00222eb:	e9 d8 fe ff ff       	jmp    c00221c8 <intr_entry>

c00222f0 <intr1a_stub>:
c00222f0:	ff 34 24             	pushl  (%esp)
c00222f3:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00222f7:	6a 1a                	push   $0x1a
c00222f9:	e9 ca fe ff ff       	jmp    c00221c8 <intr_entry>

c00222fe <intr1b_stub>:
c00222fe:	ff 34 24             	pushl  (%esp)
c0022301:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022305:	6a 1b                	push   $0x1b
c0022307:	e9 bc fe ff ff       	jmp    c00221c8 <intr_entry>

c002230c <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c002230c:	55                   	push   %ebp
c002230d:	6a 00                	push   $0x0
c002230f:	6a 1c                	push   $0x1c
c0022311:	e9 b2 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022316 <intr1d_stub>:
c0022316:	ff 34 24             	pushl  (%esp)
c0022319:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002231d:	6a 1d                	push   $0x1d
c002231f:	e9 a4 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022324 <intr1e_stub>:
c0022324:	ff 34 24             	pushl  (%esp)
c0022327:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002232b:	6a 1e                	push   $0x1e
c002232d:	e9 96 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022332 <intr1f_stub>:
c0022332:	55                   	push   %ebp
c0022333:	6a 00                	push   $0x0
c0022335:	6a 1f                	push   $0x1f
c0022337:	e9 8c fe ff ff       	jmp    c00221c8 <intr_entry>

c002233c <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c002233c:	55                   	push   %ebp
c002233d:	6a 00                	push   $0x0
c002233f:	6a 20                	push   $0x20
c0022341:	e9 82 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022346 <intr21_stub>:
c0022346:	55                   	push   %ebp
c0022347:	6a 00                	push   $0x0
c0022349:	6a 21                	push   $0x21
c002234b:	e9 78 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022350 <intr22_stub>:
c0022350:	55                   	push   %ebp
c0022351:	6a 00                	push   $0x0
c0022353:	6a 22                	push   $0x22
c0022355:	e9 6e fe ff ff       	jmp    c00221c8 <intr_entry>

c002235a <intr23_stub>:
c002235a:	55                   	push   %ebp
c002235b:	6a 00                	push   $0x0
c002235d:	6a 23                	push   $0x23
c002235f:	e9 64 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022364 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022364:	55                   	push   %ebp
c0022365:	6a 00                	push   $0x0
c0022367:	6a 24                	push   $0x24
c0022369:	e9 5a fe ff ff       	jmp    c00221c8 <intr_entry>

c002236e <intr25_stub>:
c002236e:	55                   	push   %ebp
c002236f:	6a 00                	push   $0x0
c0022371:	6a 25                	push   $0x25
c0022373:	e9 50 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022378 <intr26_stub>:
c0022378:	55                   	push   %ebp
c0022379:	6a 00                	push   $0x0
c002237b:	6a 26                	push   $0x26
c002237d:	e9 46 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022382 <intr27_stub>:
c0022382:	55                   	push   %ebp
c0022383:	6a 00                	push   $0x0
c0022385:	6a 27                	push   $0x27
c0022387:	e9 3c fe ff ff       	jmp    c00221c8 <intr_entry>

c002238c <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c002238c:	55                   	push   %ebp
c002238d:	6a 00                	push   $0x0
c002238f:	6a 28                	push   $0x28
c0022391:	e9 32 fe ff ff       	jmp    c00221c8 <intr_entry>

c0022396 <intr29_stub>:
c0022396:	55                   	push   %ebp
c0022397:	6a 00                	push   $0x0
c0022399:	6a 29                	push   $0x29
c002239b:	e9 28 fe ff ff       	jmp    c00221c8 <intr_entry>

c00223a0 <intr2a_stub>:
c00223a0:	55                   	push   %ebp
c00223a1:	6a 00                	push   $0x0
c00223a3:	6a 2a                	push   $0x2a
c00223a5:	e9 1e fe ff ff       	jmp    c00221c8 <intr_entry>

c00223aa <intr2b_stub>:
c00223aa:	55                   	push   %ebp
c00223ab:	6a 00                	push   $0x0
c00223ad:	6a 2b                	push   $0x2b
c00223af:	e9 14 fe ff ff       	jmp    c00221c8 <intr_entry>

c00223b4 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c00223b4:	55                   	push   %ebp
c00223b5:	6a 00                	push   $0x0
c00223b7:	6a 2c                	push   $0x2c
c00223b9:	e9 0a fe ff ff       	jmp    c00221c8 <intr_entry>

c00223be <intr2d_stub>:
c00223be:	55                   	push   %ebp
c00223bf:	6a 00                	push   $0x0
c00223c1:	6a 2d                	push   $0x2d
c00223c3:	e9 00 fe ff ff       	jmp    c00221c8 <intr_entry>

c00223c8 <intr2e_stub>:
c00223c8:	55                   	push   %ebp
c00223c9:	6a 00                	push   $0x0
c00223cb:	6a 2e                	push   $0x2e
c00223cd:	e9 f6 fd ff ff       	jmp    c00221c8 <intr_entry>

c00223d2 <intr2f_stub>:
c00223d2:	55                   	push   %ebp
c00223d3:	6a 00                	push   $0x0
c00223d5:	6a 2f                	push   $0x2f
c00223d7:	e9 ec fd ff ff       	jmp    c00221c8 <intr_entry>

c00223dc <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00223dc:	55                   	push   %ebp
c00223dd:	6a 00                	push   $0x0
c00223df:	6a 30                	push   $0x30
c00223e1:	e9 e2 fd ff ff       	jmp    c00221c8 <intr_entry>

c00223e6 <intr31_stub>:
c00223e6:	55                   	push   %ebp
c00223e7:	6a 00                	push   $0x0
c00223e9:	6a 31                	push   $0x31
c00223eb:	e9 d8 fd ff ff       	jmp    c00221c8 <intr_entry>

c00223f0 <intr32_stub>:
c00223f0:	55                   	push   %ebp
c00223f1:	6a 00                	push   $0x0
c00223f3:	6a 32                	push   $0x32
c00223f5:	e9 ce fd ff ff       	jmp    c00221c8 <intr_entry>

c00223fa <intr33_stub>:
c00223fa:	55                   	push   %ebp
c00223fb:	6a 00                	push   $0x0
c00223fd:	6a 33                	push   $0x33
c00223ff:	e9 c4 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022404 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0022404:	55                   	push   %ebp
c0022405:	6a 00                	push   $0x0
c0022407:	6a 34                	push   $0x34
c0022409:	e9 ba fd ff ff       	jmp    c00221c8 <intr_entry>

c002240e <intr35_stub>:
c002240e:	55                   	push   %ebp
c002240f:	6a 00                	push   $0x0
c0022411:	6a 35                	push   $0x35
c0022413:	e9 b0 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022418 <intr36_stub>:
c0022418:	55                   	push   %ebp
c0022419:	6a 00                	push   $0x0
c002241b:	6a 36                	push   $0x36
c002241d:	e9 a6 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022422 <intr37_stub>:
c0022422:	55                   	push   %ebp
c0022423:	6a 00                	push   $0x0
c0022425:	6a 37                	push   $0x37
c0022427:	e9 9c fd ff ff       	jmp    c00221c8 <intr_entry>

c002242c <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c002242c:	55                   	push   %ebp
c002242d:	6a 00                	push   $0x0
c002242f:	6a 38                	push   $0x38
c0022431:	e9 92 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022436 <intr39_stub>:
c0022436:	55                   	push   %ebp
c0022437:	6a 00                	push   $0x0
c0022439:	6a 39                	push   $0x39
c002243b:	e9 88 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022440 <intr3a_stub>:
c0022440:	55                   	push   %ebp
c0022441:	6a 00                	push   $0x0
c0022443:	6a 3a                	push   $0x3a
c0022445:	e9 7e fd ff ff       	jmp    c00221c8 <intr_entry>

c002244a <intr3b_stub>:
c002244a:	55                   	push   %ebp
c002244b:	6a 00                	push   $0x0
c002244d:	6a 3b                	push   $0x3b
c002244f:	e9 74 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022454 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022454:	55                   	push   %ebp
c0022455:	6a 00                	push   $0x0
c0022457:	6a 3c                	push   $0x3c
c0022459:	e9 6a fd ff ff       	jmp    c00221c8 <intr_entry>

c002245e <intr3d_stub>:
c002245e:	55                   	push   %ebp
c002245f:	6a 00                	push   $0x0
c0022461:	6a 3d                	push   $0x3d
c0022463:	e9 60 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022468 <intr3e_stub>:
c0022468:	55                   	push   %ebp
c0022469:	6a 00                	push   $0x0
c002246b:	6a 3e                	push   $0x3e
c002246d:	e9 56 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022472 <intr3f_stub>:
c0022472:	55                   	push   %ebp
c0022473:	6a 00                	push   $0x0
c0022475:	6a 3f                	push   $0x3f
c0022477:	e9 4c fd ff ff       	jmp    c00221c8 <intr_entry>

c002247c <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c002247c:	55                   	push   %ebp
c002247d:	6a 00                	push   $0x0
c002247f:	6a 40                	push   $0x40
c0022481:	e9 42 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022486 <intr41_stub>:
c0022486:	55                   	push   %ebp
c0022487:	6a 00                	push   $0x0
c0022489:	6a 41                	push   $0x41
c002248b:	e9 38 fd ff ff       	jmp    c00221c8 <intr_entry>

c0022490 <intr42_stub>:
c0022490:	55                   	push   %ebp
c0022491:	6a 00                	push   $0x0
c0022493:	6a 42                	push   $0x42
c0022495:	e9 2e fd ff ff       	jmp    c00221c8 <intr_entry>

c002249a <intr43_stub>:
c002249a:	55                   	push   %ebp
c002249b:	6a 00                	push   $0x0
c002249d:	6a 43                	push   $0x43
c002249f:	e9 24 fd ff ff       	jmp    c00221c8 <intr_entry>

c00224a4 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c00224a4:	55                   	push   %ebp
c00224a5:	6a 00                	push   $0x0
c00224a7:	6a 44                	push   $0x44
c00224a9:	e9 1a fd ff ff       	jmp    c00221c8 <intr_entry>

c00224ae <intr45_stub>:
c00224ae:	55                   	push   %ebp
c00224af:	6a 00                	push   $0x0
c00224b1:	6a 45                	push   $0x45
c00224b3:	e9 10 fd ff ff       	jmp    c00221c8 <intr_entry>

c00224b8 <intr46_stub>:
c00224b8:	55                   	push   %ebp
c00224b9:	6a 00                	push   $0x0
c00224bb:	6a 46                	push   $0x46
c00224bd:	e9 06 fd ff ff       	jmp    c00221c8 <intr_entry>

c00224c2 <intr47_stub>:
c00224c2:	55                   	push   %ebp
c00224c3:	6a 00                	push   $0x0
c00224c5:	6a 47                	push   $0x47
c00224c7:	e9 fc fc ff ff       	jmp    c00221c8 <intr_entry>

c00224cc <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00224cc:	55                   	push   %ebp
c00224cd:	6a 00                	push   $0x0
c00224cf:	6a 48                	push   $0x48
c00224d1:	e9 f2 fc ff ff       	jmp    c00221c8 <intr_entry>

c00224d6 <intr49_stub>:
c00224d6:	55                   	push   %ebp
c00224d7:	6a 00                	push   $0x0
c00224d9:	6a 49                	push   $0x49
c00224db:	e9 e8 fc ff ff       	jmp    c00221c8 <intr_entry>

c00224e0 <intr4a_stub>:
c00224e0:	55                   	push   %ebp
c00224e1:	6a 00                	push   $0x0
c00224e3:	6a 4a                	push   $0x4a
c00224e5:	e9 de fc ff ff       	jmp    c00221c8 <intr_entry>

c00224ea <intr4b_stub>:
c00224ea:	55                   	push   %ebp
c00224eb:	6a 00                	push   $0x0
c00224ed:	6a 4b                	push   $0x4b
c00224ef:	e9 d4 fc ff ff       	jmp    c00221c8 <intr_entry>

c00224f4 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00224f4:	55                   	push   %ebp
c00224f5:	6a 00                	push   $0x0
c00224f7:	6a 4c                	push   $0x4c
c00224f9:	e9 ca fc ff ff       	jmp    c00221c8 <intr_entry>

c00224fe <intr4d_stub>:
c00224fe:	55                   	push   %ebp
c00224ff:	6a 00                	push   $0x0
c0022501:	6a 4d                	push   $0x4d
c0022503:	e9 c0 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022508 <intr4e_stub>:
c0022508:	55                   	push   %ebp
c0022509:	6a 00                	push   $0x0
c002250b:	6a 4e                	push   $0x4e
c002250d:	e9 b6 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022512 <intr4f_stub>:
c0022512:	55                   	push   %ebp
c0022513:	6a 00                	push   $0x0
c0022515:	6a 4f                	push   $0x4f
c0022517:	e9 ac fc ff ff       	jmp    c00221c8 <intr_entry>

c002251c <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c002251c:	55                   	push   %ebp
c002251d:	6a 00                	push   $0x0
c002251f:	6a 50                	push   $0x50
c0022521:	e9 a2 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022526 <intr51_stub>:
c0022526:	55                   	push   %ebp
c0022527:	6a 00                	push   $0x0
c0022529:	6a 51                	push   $0x51
c002252b:	e9 98 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022530 <intr52_stub>:
c0022530:	55                   	push   %ebp
c0022531:	6a 00                	push   $0x0
c0022533:	6a 52                	push   $0x52
c0022535:	e9 8e fc ff ff       	jmp    c00221c8 <intr_entry>

c002253a <intr53_stub>:
c002253a:	55                   	push   %ebp
c002253b:	6a 00                	push   $0x0
c002253d:	6a 53                	push   $0x53
c002253f:	e9 84 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022544 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0022544:	55                   	push   %ebp
c0022545:	6a 00                	push   $0x0
c0022547:	6a 54                	push   $0x54
c0022549:	e9 7a fc ff ff       	jmp    c00221c8 <intr_entry>

c002254e <intr55_stub>:
c002254e:	55                   	push   %ebp
c002254f:	6a 00                	push   $0x0
c0022551:	6a 55                	push   $0x55
c0022553:	e9 70 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022558 <intr56_stub>:
c0022558:	55                   	push   %ebp
c0022559:	6a 00                	push   $0x0
c002255b:	6a 56                	push   $0x56
c002255d:	e9 66 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022562 <intr57_stub>:
c0022562:	55                   	push   %ebp
c0022563:	6a 00                	push   $0x0
c0022565:	6a 57                	push   $0x57
c0022567:	e9 5c fc ff ff       	jmp    c00221c8 <intr_entry>

c002256c <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c002256c:	55                   	push   %ebp
c002256d:	6a 00                	push   $0x0
c002256f:	6a 58                	push   $0x58
c0022571:	e9 52 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022576 <intr59_stub>:
c0022576:	55                   	push   %ebp
c0022577:	6a 00                	push   $0x0
c0022579:	6a 59                	push   $0x59
c002257b:	e9 48 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022580 <intr5a_stub>:
c0022580:	55                   	push   %ebp
c0022581:	6a 00                	push   $0x0
c0022583:	6a 5a                	push   $0x5a
c0022585:	e9 3e fc ff ff       	jmp    c00221c8 <intr_entry>

c002258a <intr5b_stub>:
c002258a:	55                   	push   %ebp
c002258b:	6a 00                	push   $0x0
c002258d:	6a 5b                	push   $0x5b
c002258f:	e9 34 fc ff ff       	jmp    c00221c8 <intr_entry>

c0022594 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0022594:	55                   	push   %ebp
c0022595:	6a 00                	push   $0x0
c0022597:	6a 5c                	push   $0x5c
c0022599:	e9 2a fc ff ff       	jmp    c00221c8 <intr_entry>

c002259e <intr5d_stub>:
c002259e:	55                   	push   %ebp
c002259f:	6a 00                	push   $0x0
c00225a1:	6a 5d                	push   $0x5d
c00225a3:	e9 20 fc ff ff       	jmp    c00221c8 <intr_entry>

c00225a8 <intr5e_stub>:
c00225a8:	55                   	push   %ebp
c00225a9:	6a 00                	push   $0x0
c00225ab:	6a 5e                	push   $0x5e
c00225ad:	e9 16 fc ff ff       	jmp    c00221c8 <intr_entry>

c00225b2 <intr5f_stub>:
c00225b2:	55                   	push   %ebp
c00225b3:	6a 00                	push   $0x0
c00225b5:	6a 5f                	push   $0x5f
c00225b7:	e9 0c fc ff ff       	jmp    c00221c8 <intr_entry>

c00225bc <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c00225bc:	55                   	push   %ebp
c00225bd:	6a 00                	push   $0x0
c00225bf:	6a 60                	push   $0x60
c00225c1:	e9 02 fc ff ff       	jmp    c00221c8 <intr_entry>

c00225c6 <intr61_stub>:
c00225c6:	55                   	push   %ebp
c00225c7:	6a 00                	push   $0x0
c00225c9:	6a 61                	push   $0x61
c00225cb:	e9 f8 fb ff ff       	jmp    c00221c8 <intr_entry>

c00225d0 <intr62_stub>:
c00225d0:	55                   	push   %ebp
c00225d1:	6a 00                	push   $0x0
c00225d3:	6a 62                	push   $0x62
c00225d5:	e9 ee fb ff ff       	jmp    c00221c8 <intr_entry>

c00225da <intr63_stub>:
c00225da:	55                   	push   %ebp
c00225db:	6a 00                	push   $0x0
c00225dd:	6a 63                	push   $0x63
c00225df:	e9 e4 fb ff ff       	jmp    c00221c8 <intr_entry>

c00225e4 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00225e4:	55                   	push   %ebp
c00225e5:	6a 00                	push   $0x0
c00225e7:	6a 64                	push   $0x64
c00225e9:	e9 da fb ff ff       	jmp    c00221c8 <intr_entry>

c00225ee <intr65_stub>:
c00225ee:	55                   	push   %ebp
c00225ef:	6a 00                	push   $0x0
c00225f1:	6a 65                	push   $0x65
c00225f3:	e9 d0 fb ff ff       	jmp    c00221c8 <intr_entry>

c00225f8 <intr66_stub>:
c00225f8:	55                   	push   %ebp
c00225f9:	6a 00                	push   $0x0
c00225fb:	6a 66                	push   $0x66
c00225fd:	e9 c6 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022602 <intr67_stub>:
c0022602:	55                   	push   %ebp
c0022603:	6a 00                	push   $0x0
c0022605:	6a 67                	push   $0x67
c0022607:	e9 bc fb ff ff       	jmp    c00221c8 <intr_entry>

c002260c <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c002260c:	55                   	push   %ebp
c002260d:	6a 00                	push   $0x0
c002260f:	6a 68                	push   $0x68
c0022611:	e9 b2 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022616 <intr69_stub>:
c0022616:	55                   	push   %ebp
c0022617:	6a 00                	push   $0x0
c0022619:	6a 69                	push   $0x69
c002261b:	e9 a8 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022620 <intr6a_stub>:
c0022620:	55                   	push   %ebp
c0022621:	6a 00                	push   $0x0
c0022623:	6a 6a                	push   $0x6a
c0022625:	e9 9e fb ff ff       	jmp    c00221c8 <intr_entry>

c002262a <intr6b_stub>:
c002262a:	55                   	push   %ebp
c002262b:	6a 00                	push   $0x0
c002262d:	6a 6b                	push   $0x6b
c002262f:	e9 94 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022634 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	6a 6c                	push   $0x6c
c0022639:	e9 8a fb ff ff       	jmp    c00221c8 <intr_entry>

c002263e <intr6d_stub>:
c002263e:	55                   	push   %ebp
c002263f:	6a 00                	push   $0x0
c0022641:	6a 6d                	push   $0x6d
c0022643:	e9 80 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022648 <intr6e_stub>:
c0022648:	55                   	push   %ebp
c0022649:	6a 00                	push   $0x0
c002264b:	6a 6e                	push   $0x6e
c002264d:	e9 76 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022652 <intr6f_stub>:
c0022652:	55                   	push   %ebp
c0022653:	6a 00                	push   $0x0
c0022655:	6a 6f                	push   $0x6f
c0022657:	e9 6c fb ff ff       	jmp    c00221c8 <intr_entry>

c002265c <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002265c:	55                   	push   %ebp
c002265d:	6a 00                	push   $0x0
c002265f:	6a 70                	push   $0x70
c0022661:	e9 62 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022666 <intr71_stub>:
c0022666:	55                   	push   %ebp
c0022667:	6a 00                	push   $0x0
c0022669:	6a 71                	push   $0x71
c002266b:	e9 58 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022670 <intr72_stub>:
c0022670:	55                   	push   %ebp
c0022671:	6a 00                	push   $0x0
c0022673:	6a 72                	push   $0x72
c0022675:	e9 4e fb ff ff       	jmp    c00221c8 <intr_entry>

c002267a <intr73_stub>:
c002267a:	55                   	push   %ebp
c002267b:	6a 00                	push   $0x0
c002267d:	6a 73                	push   $0x73
c002267f:	e9 44 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022684 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022684:	55                   	push   %ebp
c0022685:	6a 00                	push   $0x0
c0022687:	6a 74                	push   $0x74
c0022689:	e9 3a fb ff ff       	jmp    c00221c8 <intr_entry>

c002268e <intr75_stub>:
c002268e:	55                   	push   %ebp
c002268f:	6a 00                	push   $0x0
c0022691:	6a 75                	push   $0x75
c0022693:	e9 30 fb ff ff       	jmp    c00221c8 <intr_entry>

c0022698 <intr76_stub>:
c0022698:	55                   	push   %ebp
c0022699:	6a 00                	push   $0x0
c002269b:	6a 76                	push   $0x76
c002269d:	e9 26 fb ff ff       	jmp    c00221c8 <intr_entry>

c00226a2 <intr77_stub>:
c00226a2:	55                   	push   %ebp
c00226a3:	6a 00                	push   $0x0
c00226a5:	6a 77                	push   $0x77
c00226a7:	e9 1c fb ff ff       	jmp    c00221c8 <intr_entry>

c00226ac <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00226ac:	55                   	push   %ebp
c00226ad:	6a 00                	push   $0x0
c00226af:	6a 78                	push   $0x78
c00226b1:	e9 12 fb ff ff       	jmp    c00221c8 <intr_entry>

c00226b6 <intr79_stub>:
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	6a 79                	push   $0x79
c00226bb:	e9 08 fb ff ff       	jmp    c00221c8 <intr_entry>

c00226c0 <intr7a_stub>:
c00226c0:	55                   	push   %ebp
c00226c1:	6a 00                	push   $0x0
c00226c3:	6a 7a                	push   $0x7a
c00226c5:	e9 fe fa ff ff       	jmp    c00221c8 <intr_entry>

c00226ca <intr7b_stub>:
c00226ca:	55                   	push   %ebp
c00226cb:	6a 00                	push   $0x0
c00226cd:	6a 7b                	push   $0x7b
c00226cf:	e9 f4 fa ff ff       	jmp    c00221c8 <intr_entry>

c00226d4 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00226d4:	55                   	push   %ebp
c00226d5:	6a 00                	push   $0x0
c00226d7:	6a 7c                	push   $0x7c
c00226d9:	e9 ea fa ff ff       	jmp    c00221c8 <intr_entry>

c00226de <intr7d_stub>:
c00226de:	55                   	push   %ebp
c00226df:	6a 00                	push   $0x0
c00226e1:	6a 7d                	push   $0x7d
c00226e3:	e9 e0 fa ff ff       	jmp    c00221c8 <intr_entry>

c00226e8 <intr7e_stub>:
c00226e8:	55                   	push   %ebp
c00226e9:	6a 00                	push   $0x0
c00226eb:	6a 7e                	push   $0x7e
c00226ed:	e9 d6 fa ff ff       	jmp    c00221c8 <intr_entry>

c00226f2 <intr7f_stub>:
c00226f2:	55                   	push   %ebp
c00226f3:	6a 00                	push   $0x0
c00226f5:	6a 7f                	push   $0x7f
c00226f7:	e9 cc fa ff ff       	jmp    c00221c8 <intr_entry>

c00226fc <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c00226fc:	55                   	push   %ebp
c00226fd:	6a 00                	push   $0x0
c00226ff:	68 80 00 00 00       	push   $0x80
c0022704:	e9 bf fa ff ff       	jmp    c00221c8 <intr_entry>

c0022709 <intr81_stub>:
c0022709:	55                   	push   %ebp
c002270a:	6a 00                	push   $0x0
c002270c:	68 81 00 00 00       	push   $0x81
c0022711:	e9 b2 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022716 <intr82_stub>:
c0022716:	55                   	push   %ebp
c0022717:	6a 00                	push   $0x0
c0022719:	68 82 00 00 00       	push   $0x82
c002271e:	e9 a5 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022723 <intr83_stub>:
c0022723:	55                   	push   %ebp
c0022724:	6a 00                	push   $0x0
c0022726:	68 83 00 00 00       	push   $0x83
c002272b:	e9 98 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022730 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022730:	55                   	push   %ebp
c0022731:	6a 00                	push   $0x0
c0022733:	68 84 00 00 00       	push   $0x84
c0022738:	e9 8b fa ff ff       	jmp    c00221c8 <intr_entry>

c002273d <intr85_stub>:
c002273d:	55                   	push   %ebp
c002273e:	6a 00                	push   $0x0
c0022740:	68 85 00 00 00       	push   $0x85
c0022745:	e9 7e fa ff ff       	jmp    c00221c8 <intr_entry>

c002274a <intr86_stub>:
c002274a:	55                   	push   %ebp
c002274b:	6a 00                	push   $0x0
c002274d:	68 86 00 00 00       	push   $0x86
c0022752:	e9 71 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022757 <intr87_stub>:
c0022757:	55                   	push   %ebp
c0022758:	6a 00                	push   $0x0
c002275a:	68 87 00 00 00       	push   $0x87
c002275f:	e9 64 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022764 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022764:	55                   	push   %ebp
c0022765:	6a 00                	push   $0x0
c0022767:	68 88 00 00 00       	push   $0x88
c002276c:	e9 57 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022771 <intr89_stub>:
c0022771:	55                   	push   %ebp
c0022772:	6a 00                	push   $0x0
c0022774:	68 89 00 00 00       	push   $0x89
c0022779:	e9 4a fa ff ff       	jmp    c00221c8 <intr_entry>

c002277e <intr8a_stub>:
c002277e:	55                   	push   %ebp
c002277f:	6a 00                	push   $0x0
c0022781:	68 8a 00 00 00       	push   $0x8a
c0022786:	e9 3d fa ff ff       	jmp    c00221c8 <intr_entry>

c002278b <intr8b_stub>:
c002278b:	55                   	push   %ebp
c002278c:	6a 00                	push   $0x0
c002278e:	68 8b 00 00 00       	push   $0x8b
c0022793:	e9 30 fa ff ff       	jmp    c00221c8 <intr_entry>

c0022798 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c0022798:	55                   	push   %ebp
c0022799:	6a 00                	push   $0x0
c002279b:	68 8c 00 00 00       	push   $0x8c
c00227a0:	e9 23 fa ff ff       	jmp    c00221c8 <intr_entry>

c00227a5 <intr8d_stub>:
c00227a5:	55                   	push   %ebp
c00227a6:	6a 00                	push   $0x0
c00227a8:	68 8d 00 00 00       	push   $0x8d
c00227ad:	e9 16 fa ff ff       	jmp    c00221c8 <intr_entry>

c00227b2 <intr8e_stub>:
c00227b2:	55                   	push   %ebp
c00227b3:	6a 00                	push   $0x0
c00227b5:	68 8e 00 00 00       	push   $0x8e
c00227ba:	e9 09 fa ff ff       	jmp    c00221c8 <intr_entry>

c00227bf <intr8f_stub>:
c00227bf:	55                   	push   %ebp
c00227c0:	6a 00                	push   $0x0
c00227c2:	68 8f 00 00 00       	push   $0x8f
c00227c7:	e9 fc f9 ff ff       	jmp    c00221c8 <intr_entry>

c00227cc <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00227cc:	55                   	push   %ebp
c00227cd:	6a 00                	push   $0x0
c00227cf:	68 90 00 00 00       	push   $0x90
c00227d4:	e9 ef f9 ff ff       	jmp    c00221c8 <intr_entry>

c00227d9 <intr91_stub>:
c00227d9:	55                   	push   %ebp
c00227da:	6a 00                	push   $0x0
c00227dc:	68 91 00 00 00       	push   $0x91
c00227e1:	e9 e2 f9 ff ff       	jmp    c00221c8 <intr_entry>

c00227e6 <intr92_stub>:
c00227e6:	55                   	push   %ebp
c00227e7:	6a 00                	push   $0x0
c00227e9:	68 92 00 00 00       	push   $0x92
c00227ee:	e9 d5 f9 ff ff       	jmp    c00221c8 <intr_entry>

c00227f3 <intr93_stub>:
c00227f3:	55                   	push   %ebp
c00227f4:	6a 00                	push   $0x0
c00227f6:	68 93 00 00 00       	push   $0x93
c00227fb:	e9 c8 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022800 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022800:	55                   	push   %ebp
c0022801:	6a 00                	push   $0x0
c0022803:	68 94 00 00 00       	push   $0x94
c0022808:	e9 bb f9 ff ff       	jmp    c00221c8 <intr_entry>

c002280d <intr95_stub>:
c002280d:	55                   	push   %ebp
c002280e:	6a 00                	push   $0x0
c0022810:	68 95 00 00 00       	push   $0x95
c0022815:	e9 ae f9 ff ff       	jmp    c00221c8 <intr_entry>

c002281a <intr96_stub>:
c002281a:	55                   	push   %ebp
c002281b:	6a 00                	push   $0x0
c002281d:	68 96 00 00 00       	push   $0x96
c0022822:	e9 a1 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022827 <intr97_stub>:
c0022827:	55                   	push   %ebp
c0022828:	6a 00                	push   $0x0
c002282a:	68 97 00 00 00       	push   $0x97
c002282f:	e9 94 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022834 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022834:	55                   	push   %ebp
c0022835:	6a 00                	push   $0x0
c0022837:	68 98 00 00 00       	push   $0x98
c002283c:	e9 87 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022841 <intr99_stub>:
c0022841:	55                   	push   %ebp
c0022842:	6a 00                	push   $0x0
c0022844:	68 99 00 00 00       	push   $0x99
c0022849:	e9 7a f9 ff ff       	jmp    c00221c8 <intr_entry>

c002284e <intr9a_stub>:
c002284e:	55                   	push   %ebp
c002284f:	6a 00                	push   $0x0
c0022851:	68 9a 00 00 00       	push   $0x9a
c0022856:	e9 6d f9 ff ff       	jmp    c00221c8 <intr_entry>

c002285b <intr9b_stub>:
c002285b:	55                   	push   %ebp
c002285c:	6a 00                	push   $0x0
c002285e:	68 9b 00 00 00       	push   $0x9b
c0022863:	e9 60 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022868 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022868:	55                   	push   %ebp
c0022869:	6a 00                	push   $0x0
c002286b:	68 9c 00 00 00       	push   $0x9c
c0022870:	e9 53 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022875 <intr9d_stub>:
c0022875:	55                   	push   %ebp
c0022876:	6a 00                	push   $0x0
c0022878:	68 9d 00 00 00       	push   $0x9d
c002287d:	e9 46 f9 ff ff       	jmp    c00221c8 <intr_entry>

c0022882 <intr9e_stub>:
c0022882:	55                   	push   %ebp
c0022883:	6a 00                	push   $0x0
c0022885:	68 9e 00 00 00       	push   $0x9e
c002288a:	e9 39 f9 ff ff       	jmp    c00221c8 <intr_entry>

c002288f <intr9f_stub>:
c002288f:	55                   	push   %ebp
c0022890:	6a 00                	push   $0x0
c0022892:	68 9f 00 00 00       	push   $0x9f
c0022897:	e9 2c f9 ff ff       	jmp    c00221c8 <intr_entry>

c002289c <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c002289c:	55                   	push   %ebp
c002289d:	6a 00                	push   $0x0
c002289f:	68 a0 00 00 00       	push   $0xa0
c00228a4:	e9 1f f9 ff ff       	jmp    c00221c8 <intr_entry>

c00228a9 <intra1_stub>:
c00228a9:	55                   	push   %ebp
c00228aa:	6a 00                	push   $0x0
c00228ac:	68 a1 00 00 00       	push   $0xa1
c00228b1:	e9 12 f9 ff ff       	jmp    c00221c8 <intr_entry>

c00228b6 <intra2_stub>:
c00228b6:	55                   	push   %ebp
c00228b7:	6a 00                	push   $0x0
c00228b9:	68 a2 00 00 00       	push   $0xa2
c00228be:	e9 05 f9 ff ff       	jmp    c00221c8 <intr_entry>

c00228c3 <intra3_stub>:
c00228c3:	55                   	push   %ebp
c00228c4:	6a 00                	push   $0x0
c00228c6:	68 a3 00 00 00       	push   $0xa3
c00228cb:	e9 f8 f8 ff ff       	jmp    c00221c8 <intr_entry>

c00228d0 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00228d0:	55                   	push   %ebp
c00228d1:	6a 00                	push   $0x0
c00228d3:	68 a4 00 00 00       	push   $0xa4
c00228d8:	e9 eb f8 ff ff       	jmp    c00221c8 <intr_entry>

c00228dd <intra5_stub>:
c00228dd:	55                   	push   %ebp
c00228de:	6a 00                	push   $0x0
c00228e0:	68 a5 00 00 00       	push   $0xa5
c00228e5:	e9 de f8 ff ff       	jmp    c00221c8 <intr_entry>

c00228ea <intra6_stub>:
c00228ea:	55                   	push   %ebp
c00228eb:	6a 00                	push   $0x0
c00228ed:	68 a6 00 00 00       	push   $0xa6
c00228f2:	e9 d1 f8 ff ff       	jmp    c00221c8 <intr_entry>

c00228f7 <intra7_stub>:
c00228f7:	55                   	push   %ebp
c00228f8:	6a 00                	push   $0x0
c00228fa:	68 a7 00 00 00       	push   $0xa7
c00228ff:	e9 c4 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022904 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022904:	55                   	push   %ebp
c0022905:	6a 00                	push   $0x0
c0022907:	68 a8 00 00 00       	push   $0xa8
c002290c:	e9 b7 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022911 <intra9_stub>:
c0022911:	55                   	push   %ebp
c0022912:	6a 00                	push   $0x0
c0022914:	68 a9 00 00 00       	push   $0xa9
c0022919:	e9 aa f8 ff ff       	jmp    c00221c8 <intr_entry>

c002291e <intraa_stub>:
c002291e:	55                   	push   %ebp
c002291f:	6a 00                	push   $0x0
c0022921:	68 aa 00 00 00       	push   $0xaa
c0022926:	e9 9d f8 ff ff       	jmp    c00221c8 <intr_entry>

c002292b <intrab_stub>:
c002292b:	55                   	push   %ebp
c002292c:	6a 00                	push   $0x0
c002292e:	68 ab 00 00 00       	push   $0xab
c0022933:	e9 90 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022938 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022938:	55                   	push   %ebp
c0022939:	6a 00                	push   $0x0
c002293b:	68 ac 00 00 00       	push   $0xac
c0022940:	e9 83 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022945 <intrad_stub>:
c0022945:	55                   	push   %ebp
c0022946:	6a 00                	push   $0x0
c0022948:	68 ad 00 00 00       	push   $0xad
c002294d:	e9 76 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022952 <intrae_stub>:
c0022952:	55                   	push   %ebp
c0022953:	6a 00                	push   $0x0
c0022955:	68 ae 00 00 00       	push   $0xae
c002295a:	e9 69 f8 ff ff       	jmp    c00221c8 <intr_entry>

c002295f <intraf_stub>:
c002295f:	55                   	push   %ebp
c0022960:	6a 00                	push   $0x0
c0022962:	68 af 00 00 00       	push   $0xaf
c0022967:	e9 5c f8 ff ff       	jmp    c00221c8 <intr_entry>

c002296c <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c002296c:	55                   	push   %ebp
c002296d:	6a 00                	push   $0x0
c002296f:	68 b0 00 00 00       	push   $0xb0
c0022974:	e9 4f f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022979 <intrb1_stub>:
c0022979:	55                   	push   %ebp
c002297a:	6a 00                	push   $0x0
c002297c:	68 b1 00 00 00       	push   $0xb1
c0022981:	e9 42 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022986 <intrb2_stub>:
c0022986:	55                   	push   %ebp
c0022987:	6a 00                	push   $0x0
c0022989:	68 b2 00 00 00       	push   $0xb2
c002298e:	e9 35 f8 ff ff       	jmp    c00221c8 <intr_entry>

c0022993 <intrb3_stub>:
c0022993:	55                   	push   %ebp
c0022994:	6a 00                	push   $0x0
c0022996:	68 b3 00 00 00       	push   $0xb3
c002299b:	e9 28 f8 ff ff       	jmp    c00221c8 <intr_entry>

c00229a0 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00229a0:	55                   	push   %ebp
c00229a1:	6a 00                	push   $0x0
c00229a3:	68 b4 00 00 00       	push   $0xb4
c00229a8:	e9 1b f8 ff ff       	jmp    c00221c8 <intr_entry>

c00229ad <intrb5_stub>:
c00229ad:	55                   	push   %ebp
c00229ae:	6a 00                	push   $0x0
c00229b0:	68 b5 00 00 00       	push   $0xb5
c00229b5:	e9 0e f8 ff ff       	jmp    c00221c8 <intr_entry>

c00229ba <intrb6_stub>:
c00229ba:	55                   	push   %ebp
c00229bb:	6a 00                	push   $0x0
c00229bd:	68 b6 00 00 00       	push   $0xb6
c00229c2:	e9 01 f8 ff ff       	jmp    c00221c8 <intr_entry>

c00229c7 <intrb7_stub>:
c00229c7:	55                   	push   %ebp
c00229c8:	6a 00                	push   $0x0
c00229ca:	68 b7 00 00 00       	push   $0xb7
c00229cf:	e9 f4 f7 ff ff       	jmp    c00221c8 <intr_entry>

c00229d4 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c00229d4:	55                   	push   %ebp
c00229d5:	6a 00                	push   $0x0
c00229d7:	68 b8 00 00 00       	push   $0xb8
c00229dc:	e9 e7 f7 ff ff       	jmp    c00221c8 <intr_entry>

c00229e1 <intrb9_stub>:
c00229e1:	55                   	push   %ebp
c00229e2:	6a 00                	push   $0x0
c00229e4:	68 b9 00 00 00       	push   $0xb9
c00229e9:	e9 da f7 ff ff       	jmp    c00221c8 <intr_entry>

c00229ee <intrba_stub>:
c00229ee:	55                   	push   %ebp
c00229ef:	6a 00                	push   $0x0
c00229f1:	68 ba 00 00 00       	push   $0xba
c00229f6:	e9 cd f7 ff ff       	jmp    c00221c8 <intr_entry>

c00229fb <intrbb_stub>:
c00229fb:	55                   	push   %ebp
c00229fc:	6a 00                	push   $0x0
c00229fe:	68 bb 00 00 00       	push   $0xbb
c0022a03:	e9 c0 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a08 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022a08:	55                   	push   %ebp
c0022a09:	6a 00                	push   $0x0
c0022a0b:	68 bc 00 00 00       	push   $0xbc
c0022a10:	e9 b3 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a15 <intrbd_stub>:
c0022a15:	55                   	push   %ebp
c0022a16:	6a 00                	push   $0x0
c0022a18:	68 bd 00 00 00       	push   $0xbd
c0022a1d:	e9 a6 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a22 <intrbe_stub>:
c0022a22:	55                   	push   %ebp
c0022a23:	6a 00                	push   $0x0
c0022a25:	68 be 00 00 00       	push   $0xbe
c0022a2a:	e9 99 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a2f <intrbf_stub>:
c0022a2f:	55                   	push   %ebp
c0022a30:	6a 00                	push   $0x0
c0022a32:	68 bf 00 00 00       	push   $0xbf
c0022a37:	e9 8c f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a3c <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022a3c:	55                   	push   %ebp
c0022a3d:	6a 00                	push   $0x0
c0022a3f:	68 c0 00 00 00       	push   $0xc0
c0022a44:	e9 7f f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a49 <intrc1_stub>:
c0022a49:	55                   	push   %ebp
c0022a4a:	6a 00                	push   $0x0
c0022a4c:	68 c1 00 00 00       	push   $0xc1
c0022a51:	e9 72 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a56 <intrc2_stub>:
c0022a56:	55                   	push   %ebp
c0022a57:	6a 00                	push   $0x0
c0022a59:	68 c2 00 00 00       	push   $0xc2
c0022a5e:	e9 65 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a63 <intrc3_stub>:
c0022a63:	55                   	push   %ebp
c0022a64:	6a 00                	push   $0x0
c0022a66:	68 c3 00 00 00       	push   $0xc3
c0022a6b:	e9 58 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a70 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022a70:	55                   	push   %ebp
c0022a71:	6a 00                	push   $0x0
c0022a73:	68 c4 00 00 00       	push   $0xc4
c0022a78:	e9 4b f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a7d <intrc5_stub>:
c0022a7d:	55                   	push   %ebp
c0022a7e:	6a 00                	push   $0x0
c0022a80:	68 c5 00 00 00       	push   $0xc5
c0022a85:	e9 3e f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a8a <intrc6_stub>:
c0022a8a:	55                   	push   %ebp
c0022a8b:	6a 00                	push   $0x0
c0022a8d:	68 c6 00 00 00       	push   $0xc6
c0022a92:	e9 31 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022a97 <intrc7_stub>:
c0022a97:	55                   	push   %ebp
c0022a98:	6a 00                	push   $0x0
c0022a9a:	68 c7 00 00 00       	push   $0xc7
c0022a9f:	e9 24 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022aa4 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022aa4:	55                   	push   %ebp
c0022aa5:	6a 00                	push   $0x0
c0022aa7:	68 c8 00 00 00       	push   $0xc8
c0022aac:	e9 17 f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022ab1 <intrc9_stub>:
c0022ab1:	55                   	push   %ebp
c0022ab2:	6a 00                	push   $0x0
c0022ab4:	68 c9 00 00 00       	push   $0xc9
c0022ab9:	e9 0a f7 ff ff       	jmp    c00221c8 <intr_entry>

c0022abe <intrca_stub>:
c0022abe:	55                   	push   %ebp
c0022abf:	6a 00                	push   $0x0
c0022ac1:	68 ca 00 00 00       	push   $0xca
c0022ac6:	e9 fd f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022acb <intrcb_stub>:
c0022acb:	55                   	push   %ebp
c0022acc:	6a 00                	push   $0x0
c0022ace:	68 cb 00 00 00       	push   $0xcb
c0022ad3:	e9 f0 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022ad8 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022ad8:	55                   	push   %ebp
c0022ad9:	6a 00                	push   $0x0
c0022adb:	68 cc 00 00 00       	push   $0xcc
c0022ae0:	e9 e3 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022ae5 <intrcd_stub>:
c0022ae5:	55                   	push   %ebp
c0022ae6:	6a 00                	push   $0x0
c0022ae8:	68 cd 00 00 00       	push   $0xcd
c0022aed:	e9 d6 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022af2 <intrce_stub>:
c0022af2:	55                   	push   %ebp
c0022af3:	6a 00                	push   $0x0
c0022af5:	68 ce 00 00 00       	push   $0xce
c0022afa:	e9 c9 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022aff <intrcf_stub>:
c0022aff:	55                   	push   %ebp
c0022b00:	6a 00                	push   $0x0
c0022b02:	68 cf 00 00 00       	push   $0xcf
c0022b07:	e9 bc f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b0c <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022b0c:	55                   	push   %ebp
c0022b0d:	6a 00                	push   $0x0
c0022b0f:	68 d0 00 00 00       	push   $0xd0
c0022b14:	e9 af f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b19 <intrd1_stub>:
c0022b19:	55                   	push   %ebp
c0022b1a:	6a 00                	push   $0x0
c0022b1c:	68 d1 00 00 00       	push   $0xd1
c0022b21:	e9 a2 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b26 <intrd2_stub>:
c0022b26:	55                   	push   %ebp
c0022b27:	6a 00                	push   $0x0
c0022b29:	68 d2 00 00 00       	push   $0xd2
c0022b2e:	e9 95 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b33 <intrd3_stub>:
c0022b33:	55                   	push   %ebp
c0022b34:	6a 00                	push   $0x0
c0022b36:	68 d3 00 00 00       	push   $0xd3
c0022b3b:	e9 88 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b40 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022b40:	55                   	push   %ebp
c0022b41:	6a 00                	push   $0x0
c0022b43:	68 d4 00 00 00       	push   $0xd4
c0022b48:	e9 7b f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b4d <intrd5_stub>:
c0022b4d:	55                   	push   %ebp
c0022b4e:	6a 00                	push   $0x0
c0022b50:	68 d5 00 00 00       	push   $0xd5
c0022b55:	e9 6e f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b5a <intrd6_stub>:
c0022b5a:	55                   	push   %ebp
c0022b5b:	6a 00                	push   $0x0
c0022b5d:	68 d6 00 00 00       	push   $0xd6
c0022b62:	e9 61 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b67 <intrd7_stub>:
c0022b67:	55                   	push   %ebp
c0022b68:	6a 00                	push   $0x0
c0022b6a:	68 d7 00 00 00       	push   $0xd7
c0022b6f:	e9 54 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b74 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022b74:	55                   	push   %ebp
c0022b75:	6a 00                	push   $0x0
c0022b77:	68 d8 00 00 00       	push   $0xd8
c0022b7c:	e9 47 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b81 <intrd9_stub>:
c0022b81:	55                   	push   %ebp
c0022b82:	6a 00                	push   $0x0
c0022b84:	68 d9 00 00 00       	push   $0xd9
c0022b89:	e9 3a f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b8e <intrda_stub>:
c0022b8e:	55                   	push   %ebp
c0022b8f:	6a 00                	push   $0x0
c0022b91:	68 da 00 00 00       	push   $0xda
c0022b96:	e9 2d f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022b9b <intrdb_stub>:
c0022b9b:	55                   	push   %ebp
c0022b9c:	6a 00                	push   $0x0
c0022b9e:	68 db 00 00 00       	push   $0xdb
c0022ba3:	e9 20 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022ba8 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022ba8:	55                   	push   %ebp
c0022ba9:	6a 00                	push   $0x0
c0022bab:	68 dc 00 00 00       	push   $0xdc
c0022bb0:	e9 13 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022bb5 <intrdd_stub>:
c0022bb5:	55                   	push   %ebp
c0022bb6:	6a 00                	push   $0x0
c0022bb8:	68 dd 00 00 00       	push   $0xdd
c0022bbd:	e9 06 f6 ff ff       	jmp    c00221c8 <intr_entry>

c0022bc2 <intrde_stub>:
c0022bc2:	55                   	push   %ebp
c0022bc3:	6a 00                	push   $0x0
c0022bc5:	68 de 00 00 00       	push   $0xde
c0022bca:	e9 f9 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022bcf <intrdf_stub>:
c0022bcf:	55                   	push   %ebp
c0022bd0:	6a 00                	push   $0x0
c0022bd2:	68 df 00 00 00       	push   $0xdf
c0022bd7:	e9 ec f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022bdc <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022bdc:	55                   	push   %ebp
c0022bdd:	6a 00                	push   $0x0
c0022bdf:	68 e0 00 00 00       	push   $0xe0
c0022be4:	e9 df f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022be9 <intre1_stub>:
c0022be9:	55                   	push   %ebp
c0022bea:	6a 00                	push   $0x0
c0022bec:	68 e1 00 00 00       	push   $0xe1
c0022bf1:	e9 d2 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022bf6 <intre2_stub>:
c0022bf6:	55                   	push   %ebp
c0022bf7:	6a 00                	push   $0x0
c0022bf9:	68 e2 00 00 00       	push   $0xe2
c0022bfe:	e9 c5 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c03 <intre3_stub>:
c0022c03:	55                   	push   %ebp
c0022c04:	6a 00                	push   $0x0
c0022c06:	68 e3 00 00 00       	push   $0xe3
c0022c0b:	e9 b8 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c10 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022c10:	55                   	push   %ebp
c0022c11:	6a 00                	push   $0x0
c0022c13:	68 e4 00 00 00       	push   $0xe4
c0022c18:	e9 ab f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c1d <intre5_stub>:
c0022c1d:	55                   	push   %ebp
c0022c1e:	6a 00                	push   $0x0
c0022c20:	68 e5 00 00 00       	push   $0xe5
c0022c25:	e9 9e f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c2a <intre6_stub>:
c0022c2a:	55                   	push   %ebp
c0022c2b:	6a 00                	push   $0x0
c0022c2d:	68 e6 00 00 00       	push   $0xe6
c0022c32:	e9 91 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c37 <intre7_stub>:
c0022c37:	55                   	push   %ebp
c0022c38:	6a 00                	push   $0x0
c0022c3a:	68 e7 00 00 00       	push   $0xe7
c0022c3f:	e9 84 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c44 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022c44:	55                   	push   %ebp
c0022c45:	6a 00                	push   $0x0
c0022c47:	68 e8 00 00 00       	push   $0xe8
c0022c4c:	e9 77 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c51 <intre9_stub>:
c0022c51:	55                   	push   %ebp
c0022c52:	6a 00                	push   $0x0
c0022c54:	68 e9 00 00 00       	push   $0xe9
c0022c59:	e9 6a f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c5e <intrea_stub>:
c0022c5e:	55                   	push   %ebp
c0022c5f:	6a 00                	push   $0x0
c0022c61:	68 ea 00 00 00       	push   $0xea
c0022c66:	e9 5d f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c6b <intreb_stub>:
c0022c6b:	55                   	push   %ebp
c0022c6c:	6a 00                	push   $0x0
c0022c6e:	68 eb 00 00 00       	push   $0xeb
c0022c73:	e9 50 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c78 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022c78:	55                   	push   %ebp
c0022c79:	6a 00                	push   $0x0
c0022c7b:	68 ec 00 00 00       	push   $0xec
c0022c80:	e9 43 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c85 <intred_stub>:
c0022c85:	55                   	push   %ebp
c0022c86:	6a 00                	push   $0x0
c0022c88:	68 ed 00 00 00       	push   $0xed
c0022c8d:	e9 36 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c92 <intree_stub>:
c0022c92:	55                   	push   %ebp
c0022c93:	6a 00                	push   $0x0
c0022c95:	68 ee 00 00 00       	push   $0xee
c0022c9a:	e9 29 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022c9f <intref_stub>:
c0022c9f:	55                   	push   %ebp
c0022ca0:	6a 00                	push   $0x0
c0022ca2:	68 ef 00 00 00       	push   $0xef
c0022ca7:	e9 1c f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022cac <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022cac:	55                   	push   %ebp
c0022cad:	6a 00                	push   $0x0
c0022caf:	68 f0 00 00 00       	push   $0xf0
c0022cb4:	e9 0f f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022cb9 <intrf1_stub>:
c0022cb9:	55                   	push   %ebp
c0022cba:	6a 00                	push   $0x0
c0022cbc:	68 f1 00 00 00       	push   $0xf1
c0022cc1:	e9 02 f5 ff ff       	jmp    c00221c8 <intr_entry>

c0022cc6 <intrf2_stub>:
c0022cc6:	55                   	push   %ebp
c0022cc7:	6a 00                	push   $0x0
c0022cc9:	68 f2 00 00 00       	push   $0xf2
c0022cce:	e9 f5 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022cd3 <intrf3_stub>:
c0022cd3:	55                   	push   %ebp
c0022cd4:	6a 00                	push   $0x0
c0022cd6:	68 f3 00 00 00       	push   $0xf3
c0022cdb:	e9 e8 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022ce0 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022ce0:	55                   	push   %ebp
c0022ce1:	6a 00                	push   $0x0
c0022ce3:	68 f4 00 00 00       	push   $0xf4
c0022ce8:	e9 db f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022ced <intrf5_stub>:
c0022ced:	55                   	push   %ebp
c0022cee:	6a 00                	push   $0x0
c0022cf0:	68 f5 00 00 00       	push   $0xf5
c0022cf5:	e9 ce f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022cfa <intrf6_stub>:
c0022cfa:	55                   	push   %ebp
c0022cfb:	6a 00                	push   $0x0
c0022cfd:	68 f6 00 00 00       	push   $0xf6
c0022d02:	e9 c1 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d07 <intrf7_stub>:
c0022d07:	55                   	push   %ebp
c0022d08:	6a 00                	push   $0x0
c0022d0a:	68 f7 00 00 00       	push   $0xf7
c0022d0f:	e9 b4 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d14 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022d14:	55                   	push   %ebp
c0022d15:	6a 00                	push   $0x0
c0022d17:	68 f8 00 00 00       	push   $0xf8
c0022d1c:	e9 a7 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d21 <intrf9_stub>:
c0022d21:	55                   	push   %ebp
c0022d22:	6a 00                	push   $0x0
c0022d24:	68 f9 00 00 00       	push   $0xf9
c0022d29:	e9 9a f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d2e <intrfa_stub>:
c0022d2e:	55                   	push   %ebp
c0022d2f:	6a 00                	push   $0x0
c0022d31:	68 fa 00 00 00       	push   $0xfa
c0022d36:	e9 8d f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d3b <intrfb_stub>:
c0022d3b:	55                   	push   %ebp
c0022d3c:	6a 00                	push   $0x0
c0022d3e:	68 fb 00 00 00       	push   $0xfb
c0022d43:	e9 80 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d48 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022d48:	55                   	push   %ebp
c0022d49:	6a 00                	push   $0x0
c0022d4b:	68 fc 00 00 00       	push   $0xfc
c0022d50:	e9 73 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d55 <intrfd_stub>:
c0022d55:	55                   	push   %ebp
c0022d56:	6a 00                	push   $0x0
c0022d58:	68 fd 00 00 00       	push   $0xfd
c0022d5d:	e9 66 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d62 <intrfe_stub>:
c0022d62:	55                   	push   %ebp
c0022d63:	6a 00                	push   $0x0
c0022d65:	68 fe 00 00 00       	push   $0xfe
c0022d6a:	e9 59 f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d6f <intrff_stub>:
c0022d6f:	55                   	push   %ebp
c0022d70:	6a 00                	push   $0x0
c0022d72:	68 ff 00 00 00       	push   $0xff
c0022d77:	e9 4c f4 ff ff       	jmp    c00221c8 <intr_entry>

c0022d7c <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c0022d7c:	55                   	push   %ebp
c0022d7d:	89 e5                	mov    %esp,%ebp
c0022d7f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c0022d82:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022d86:	75 1e                	jne    c0022da6 <sema_init+0x2a>
c0022d88:	83 ec 0c             	sub    $0xc,%esp
c0022d8b:	68 6c fa 02 c0       	push   $0xc002fa6c
c0022d90:	68 79 fa 02 c0       	push   $0xc002fa79
c0022d95:	68 40 fb 02 c0       	push   $0xc002fb40
c0022d9a:	6a 2f                	push   $0x2f
c0022d9c:	68 90 fa 02 c0       	push   $0xc002fa90
c0022da1:	e8 7c 72 00 00       	call   c002a022 <debug_panic>

  sema->value = value;
c0022da6:	8b 45 08             	mov    0x8(%ebp),%eax
c0022da9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0022dac:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022dae:	8b 45 08             	mov    0x8(%ebp),%eax
c0022db1:	83 c0 04             	add    $0x4,%eax
c0022db4:	83 ec 0c             	sub    $0xc,%esp
c0022db7:	50                   	push   %eax
c0022db8:	e8 d6 74 00 00       	call   c002a293 <list_init>
c0022dbd:	83 c4 10             	add    $0x10,%esp
}
c0022dc0:	90                   	nop
c0022dc1:	c9                   	leave  
c0022dc2:	c3                   	ret    

c0022dc3 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022dc3:	55                   	push   %ebp
c0022dc4:	89 e5                	mov    %esp,%ebp
c0022dc6:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022dc9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022dcd:	75 1e                	jne    c0022ded <sema_down+0x2a>
c0022dcf:	83 ec 0c             	sub    $0xc,%esp
c0022dd2:	68 6c fa 02 c0       	push   $0xc002fa6c
c0022dd7:	68 79 fa 02 c0       	push   $0xc002fa79
c0022ddc:	68 4c fb 02 c0       	push   $0xc002fb4c
c0022de1:	6a 41                	push   $0x41
c0022de3:	68 90 fa 02 c0       	push   $0xc002fa90
c0022de8:	e8 35 72 00 00       	call   c002a022 <debug_panic>
  ASSERT (!intr_context ());
c0022ded:	e8 58 ee ff ff       	call   c0021c4a <intr_context>
c0022df2:	83 f0 01             	xor    $0x1,%eax
c0022df5:	84 c0                	test   %al,%al
c0022df7:	75 1e                	jne    c0022e17 <sema_down+0x54>
c0022df9:	83 ec 0c             	sub    $0xc,%esp
c0022dfc:	68 a6 fa 02 c0       	push   $0xc002faa6
c0022e01:	68 79 fa 02 c0       	push   $0xc002fa79
c0022e06:	68 4c fb 02 c0       	push   $0xc002fb4c
c0022e0b:	6a 42                	push   $0x42
c0022e0d:	68 90 fa 02 c0       	push   $0xc002fa90
c0022e12:	e8 0b 72 00 00       	call   c002a022 <debug_panic>

  old_level = intr_disable ();
c0022e17:	e8 61 eb ff ff       	call   c002197d <intr_disable>
c0022e1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c0022e1f:	eb 24                	jmp    c0022e45 <sema_down+0x82>
    {
      list_insert_ordered (&sema->waiters, 
                            &thread_current ()->elem, thread_priority_cmp, NULL);
c0022e21:	e8 65 de ff ff       	call   c0020c8b <thread_current>
      list_insert_ordered (&sema->waiters, 
c0022e26:	8d 50 28             	lea    0x28(%eax),%edx
c0022e29:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e2c:	83 c0 04             	add    $0x4,%eax
c0022e2f:	6a 00                	push   $0x0
c0022e31:	68 83 14 02 c0       	push   $0xc0021483
c0022e36:	52                   	push   %edx
c0022e37:	50                   	push   %eax
c0022e38:	e8 f6 7e 00 00       	call   c002ad33 <list_insert_ordered>
c0022e3d:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c0022e40:	e8 22 dd ff ff       	call   c0020b67 <thread_block>
  while (sema->value == 0) 
c0022e45:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e48:	8b 00                	mov    (%eax),%eax
c0022e4a:	85 c0                	test   %eax,%eax
c0022e4c:	74 d3                	je     c0022e21 <sema_down+0x5e>
    }
  sema->value--;
c0022e4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e51:	8b 00                	mov    (%eax),%eax
c0022e53:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022e56:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e59:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022e5b:	83 ec 0c             	sub    $0xc,%esp
c0022e5e:	ff 75 f4             	pushl  -0xc(%ebp)
c0022e61:	e8 bf ea ff ff       	call   c0021925 <intr_set_level>
c0022e66:	83 c4 10             	add    $0x10,%esp
}
c0022e69:	90                   	nop
c0022e6a:	c9                   	leave  
c0022e6b:	c3                   	ret    

c0022e6c <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022e6c:	55                   	push   %ebp
c0022e6d:	89 e5                	mov    %esp,%ebp
c0022e6f:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c0022e72:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e76:	75 1e                	jne    c0022e96 <sema_try_down+0x2a>
c0022e78:	83 ec 0c             	sub    $0xc,%esp
c0022e7b:	68 6c fa 02 c0       	push   $0xc002fa6c
c0022e80:	68 79 fa 02 c0       	push   $0xc002fa79
c0022e85:	68 58 fb 02 c0       	push   $0xc002fb58
c0022e8a:	6a 5a                	push   $0x5a
c0022e8c:	68 90 fa 02 c0       	push   $0xc002fa90
c0022e91:	e8 8c 71 00 00       	call   c002a022 <debug_panic>

  old_level = intr_disable ();
c0022e96:	e8 e2 ea ff ff       	call   c002197d <intr_disable>
c0022e9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c0022e9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ea1:	8b 00                	mov    (%eax),%eax
c0022ea3:	85 c0                	test   %eax,%eax
c0022ea5:	74 13                	je     c0022eba <sema_try_down+0x4e>
    {
      sema->value--;
c0022ea7:	8b 45 08             	mov    0x8(%ebp),%eax
c0022eaa:	8b 00                	mov    (%eax),%eax
c0022eac:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022eaf:	8b 45 08             	mov    0x8(%ebp),%eax
c0022eb2:	89 10                	mov    %edx,(%eax)
      success = true; 
c0022eb4:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c0022eb8:	eb 04                	jmp    c0022ebe <sema_try_down+0x52>
    }
  else
    success = false;
c0022eba:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c0022ebe:	83 ec 0c             	sub    $0xc,%esp
c0022ec1:	ff 75 f0             	pushl  -0x10(%ebp)
c0022ec4:	e8 5c ea ff ff       	call   c0021925 <intr_set_level>
c0022ec9:	83 c4 10             	add    $0x10,%esp

  return success;
c0022ecc:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0022ecf:	c9                   	leave  
c0022ed0:	c3                   	ret    

c0022ed1 <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022ed1:	55                   	push   %ebp
c0022ed2:	89 e5                	mov    %esp,%ebp
c0022ed4:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022ed7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022edb:	75 1e                	jne    c0022efb <sema_up+0x2a>
c0022edd:	83 ec 0c             	sub    $0xc,%esp
c0022ee0:	68 6c fa 02 c0       	push   $0xc002fa6c
c0022ee5:	68 79 fa 02 c0       	push   $0xc002fa79
c0022eea:	68 68 fb 02 c0       	push   $0xc002fb68
c0022eef:	6a 72                	push   $0x72
c0022ef1:	68 90 fa 02 c0       	push   $0xc002fa90
c0022ef6:	e8 27 71 00 00       	call   c002a022 <debug_panic>

  old_level = intr_disable ();
c0022efb:	e8 7d ea ff ff       	call   c002197d <intr_disable>
c0022f00:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) {
c0022f03:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f06:	83 c0 04             	add    $0x4,%eax
c0022f09:	83 ec 0c             	sub    $0xc,%esp
c0022f0c:	50                   	push   %eax
c0022f0d:	e8 08 79 00 00       	call   c002a81a <list_empty>
c0022f12:	83 c4 10             	add    $0x10,%esp
c0022f15:	83 f0 01             	xor    $0x1,%eax
c0022f18:	84 c0                	test   %al,%al
c0022f1a:	74 3d                	je     c0022f59 <sema_up+0x88>
    list_sort (&sema->waiters, thread_priority_cmp, NULL);
c0022f1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f1f:	83 c0 04             	add    $0x4,%eax
c0022f22:	83 ec 04             	sub    $0x4,%esp
c0022f25:	6a 00                	push   $0x0
c0022f27:	68 83 14 02 c0       	push   $0xc0021483
c0022f2c:	50                   	push   %eax
c0022f2d:	e8 99 7c 00 00       	call   c002abcb <list_sort>
c0022f32:	83 c4 10             	add    $0x10,%esp
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022f35:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f38:	83 c0 04             	add    $0x4,%eax
c0022f3b:	83 ec 0c             	sub    $0xc,%esp
c0022f3e:	50                   	push   %eax
c0022f3f:	e8 ae 77 00 00       	call   c002a6f2 <list_pop_front>
c0022f44:	83 c4 10             	add    $0x10,%esp
c0022f47:	83 c0 04             	add    $0x4,%eax
c0022f4a:	83 e8 2c             	sub    $0x2c,%eax
c0022f4d:	83 ec 0c             	sub    $0xc,%esp
c0022f50:	50                   	push   %eax
c0022f51:	e8 82 dc ff ff       	call   c0020bd8 <thread_unblock>
c0022f56:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  }
                                
  sema->value++;
c0022f59:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f5c:	8b 00                	mov    (%eax),%eax
c0022f5e:	8d 50 01             	lea    0x1(%eax),%edx
c0022f61:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f64:	89 10                	mov    %edx,(%eax)
  if (!intr_context())
c0022f66:	e8 df ec ff ff       	call   c0021c4a <intr_context>
c0022f6b:	83 f0 01             	xor    $0x1,%eax
c0022f6e:	84 c0                	test   %al,%al
c0022f70:	74 05                	je     c0022f77 <sema_up+0xa6>
    thread_yield();
c0022f72:	e8 0a de ff ff       	call   c0020d81 <thread_yield>
  intr_set_level (old_level);
c0022f77:	83 ec 0c             	sub    $0xc,%esp
c0022f7a:	ff 75 f4             	pushl  -0xc(%ebp)
c0022f7d:	e8 a3 e9 ff ff       	call   c0021925 <intr_set_level>
c0022f82:	83 c4 10             	add    $0x10,%esp
}
c0022f85:	90                   	nop
c0022f86:	c9                   	leave  
c0022f87:	c3                   	ret    

c0022f88 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022f88:	55                   	push   %ebp
c0022f89:	89 e5                	mov    %esp,%ebp
c0022f8b:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c0022f8e:	83 ec 0c             	sub    $0xc,%esp
c0022f91:	68 b7 fa 02 c0       	push   $0xc002fab7
c0022f96:	e8 b6 4b 00 00       	call   c0027b51 <printf>
c0022f9b:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c0022f9e:	83 ec 08             	sub    $0x8,%esp
c0022fa1:	6a 00                	push   $0x0
c0022fa3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fa6:	50                   	push   %eax
c0022fa7:	e8 d0 fd ff ff       	call   c0022d7c <sema_init>
c0022fac:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0022faf:	83 ec 08             	sub    $0x8,%esp
c0022fb2:	6a 00                	push   $0x0
c0022fb4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fb7:	83 c0 14             	add    $0x14,%eax
c0022fba:	50                   	push   %eax
c0022fbb:	e8 bc fd ff ff       	call   c0022d7c <sema_init>
c0022fc0:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022fc3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fc6:	50                   	push   %eax
c0022fc7:	68 21 30 02 c0       	push   $0xc0023021
c0022fcc:	6a 1f                	push   $0x1f
c0022fce:	68 cd fa 02 c0       	push   $0xc002facd
c0022fd3:	e8 84 da ff ff       	call   c0020a5c <thread_create>
c0022fd8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022fdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022fe2:	eb 24                	jmp    c0023008 <sema_self_test+0x80>
    {
      sema_up (&sema[0]);
c0022fe4:	83 ec 0c             	sub    $0xc,%esp
c0022fe7:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fea:	50                   	push   %eax
c0022feb:	e8 e1 fe ff ff       	call   c0022ed1 <sema_up>
c0022ff0:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0022ff3:	83 ec 0c             	sub    $0xc,%esp
c0022ff6:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022ff9:	83 c0 14             	add    $0x14,%eax
c0022ffc:	50                   	push   %eax
c0022ffd:	e8 c1 fd ff ff       	call   c0022dc3 <sema_down>
c0023002:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0023005:	ff 45 f4             	incl   -0xc(%ebp)
c0023008:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002300c:	7e d6                	jle    c0022fe4 <sema_self_test+0x5c>
    }
  printf ("done.\n");
c002300e:	83 ec 0c             	sub    $0xc,%esp
c0023011:	68 d7 fa 02 c0       	push   $0xc002fad7
c0023016:	e8 c8 91 00 00       	call   c002c1e3 <puts>
c002301b:	83 c4 10             	add    $0x10,%esp
}
c002301e:	90                   	nop
c002301f:	c9                   	leave  
c0023020:	c3                   	ret    

c0023021 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0023021:	55                   	push   %ebp
c0023022:	89 e5                	mov    %esp,%ebp
c0023024:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0023027:	8b 45 08             	mov    0x8(%ebp),%eax
c002302a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c002302d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023034:	eb 23                	jmp    c0023059 <sema_test_helper+0x38>
    {
      sema_down (&sema[0]);
c0023036:	83 ec 0c             	sub    $0xc,%esp
c0023039:	ff 75 f0             	pushl  -0x10(%ebp)
c002303c:	e8 82 fd ff ff       	call   c0022dc3 <sema_down>
c0023041:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0023044:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023047:	83 c0 14             	add    $0x14,%eax
c002304a:	83 ec 0c             	sub    $0xc,%esp
c002304d:	50                   	push   %eax
c002304e:	e8 7e fe ff ff       	call   c0022ed1 <sema_up>
c0023053:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0023056:	ff 45 f4             	incl   -0xc(%ebp)
c0023059:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002305d:	7e d7                	jle    c0023036 <sema_test_helper+0x15>
    }
}
c002305f:	90                   	nop
c0023060:	c9                   	leave  
c0023061:	c3                   	ret    

c0023062 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0023062:	55                   	push   %ebp
c0023063:	89 e5                	mov    %esp,%ebp
c0023065:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0023068:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002306c:	75 21                	jne    c002308f <lock_init+0x2d>
c002306e:	83 ec 0c             	sub    $0xc,%esp
c0023071:	68 dd fa 02 c0       	push   $0xc002fadd
c0023076:	68 79 fa 02 c0       	push   $0xc002fa79
c002307b:	68 70 fb 02 c0       	push   $0xc002fb70
c0023080:	68 b8 00 00 00       	push   $0xb8
c0023085:	68 90 fa 02 c0       	push   $0xc002fa90
c002308a:	e8 93 6f 00 00       	call   c002a022 <debug_panic>

  lock->holder = NULL;
c002308f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023092:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0023098:	8b 45 08             	mov    0x8(%ebp),%eax
c002309b:	83 c0 04             	add    $0x4,%eax
c002309e:	83 ec 08             	sub    $0x8,%esp
c00230a1:	6a 01                	push   $0x1
c00230a3:	50                   	push   %eax
c00230a4:	e8 d3 fc ff ff       	call   c0022d7c <sema_init>
c00230a9:	83 c4 10             	add    $0x10,%esp
}
c00230ac:	90                   	nop
c00230ad:	c9                   	leave  
c00230ae:	c3                   	ret    

c00230af <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c00230af:	55                   	push   %ebp
c00230b0:	89 e5                	mov    %esp,%ebp
c00230b2:	83 ec 18             	sub    $0x18,%esp
  ASSERT (lock != NULL);
c00230b5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00230b9:	75 21                	jne    c00230dc <lock_acquire+0x2d>
c00230bb:	83 ec 0c             	sub    $0xc,%esp
c00230be:	68 dd fa 02 c0       	push   $0xc002fadd
c00230c3:	68 79 fa 02 c0       	push   $0xc002fa79
c00230c8:	68 7c fb 02 c0       	push   $0xc002fb7c
c00230cd:	68 c9 00 00 00       	push   $0xc9
c00230d2:	68 90 fa 02 c0       	push   $0xc002fa90
c00230d7:	e8 46 6f 00 00       	call   c002a022 <debug_panic>
  ASSERT (!intr_context ());
c00230dc:	e8 69 eb ff ff       	call   c0021c4a <intr_context>
c00230e1:	83 f0 01             	xor    $0x1,%eax
c00230e4:	84 c0                	test   %al,%al
c00230e6:	75 21                	jne    c0023109 <lock_acquire+0x5a>
c00230e8:	83 ec 0c             	sub    $0xc,%esp
c00230eb:	68 a6 fa 02 c0       	push   $0xc002faa6
c00230f0:	68 79 fa 02 c0       	push   $0xc002fa79
c00230f5:	68 7c fb 02 c0       	push   $0xc002fb7c
c00230fa:	68 ca 00 00 00       	push   $0xca
c00230ff:	68 90 fa 02 c0       	push   $0xc002fa90
c0023104:	e8 19 6f 00 00       	call   c002a022 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0023109:	83 ec 0c             	sub    $0xc,%esp
c002310c:	ff 75 08             	pushl  0x8(%ebp)
c002310f:	e8 8b 02 00 00       	call   c002339f <lock_held_by_current_thread>
c0023114:	83 c4 10             	add    $0x10,%esp
c0023117:	83 f0 01             	xor    $0x1,%eax
c002311a:	84 c0                	test   %al,%al
c002311c:	75 21                	jne    c002313f <lock_acquire+0x90>
c002311e:	83 ec 0c             	sub    $0xc,%esp
c0023121:	68 ec fa 02 c0       	push   $0xc002faec
c0023126:	68 79 fa 02 c0       	push   $0xc002fa79
c002312b:	68 7c fb 02 c0       	push   $0xc002fb7c
c0023130:	68 cb 00 00 00       	push   $0xcb
c0023135:	68 90 fa 02 c0       	push   $0xc002fa90
c002313a:	e8 e3 6e 00 00       	call   c002a022 <debug_panic>

  struct thread* cur_thread = thread_current();
c002313f:	e8 47 db ff ff       	call   c0020c8b <thread_current>
c0023144:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (!thread_mlfqs) /* Highlight: lock schedule policy is priority donate */
c0023147:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002314c:	83 f0 01             	xor    $0x1,%eax
c002314f:	84 c0                	test   %al,%al
c0023151:	74 59                	je     c00231ac <lock_acquire+0xfd>
  { 
    if (lock->holder != NULL) 
c0023153:	8b 45 08             	mov    0x8(%ebp),%eax
c0023156:	8b 00                	mov    (%eax),%eax
c0023158:	85 c0                	test   %eax,%eax
c002315a:	74 50                	je     c00231ac <lock_acquire+0xfd>
    {
      cur_thread->lock_waiting = lock;
c002315c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002315f:	8b 55 08             	mov    0x8(%ebp),%edx
c0023162:	89 50 54             	mov    %edx,0x54(%eax)

      struct lock* cur_waiting_lock = lock;
c0023165:	8b 45 08             	mov    0x8(%ebp),%eax
c0023168:	89 45 f4             	mov    %eax,-0xc(%ebp)
      int now_priority = cur_thread->priority;
c002316b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002316e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023171:	89 45 ec             	mov    %eax,-0x14(%ebp)
      while (cur_waiting_lock != NULL 
c0023174:	eb 25                	jmp    c002319b <lock_acquire+0xec>
              && now_priority > cur_waiting_lock -> max_priority) /* hodler of lock */
      {
        cur_waiting_lock->max_priority = now_priority;
c0023176:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023179:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002317c:	89 50 20             	mov    %edx,0x20(%eax)
        thread_donate_priority(cur_waiting_lock->holder);
c002317f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023182:	8b 00                	mov    (%eax),%eax
c0023184:	83 ec 0c             	sub    $0xc,%esp
c0023187:	50                   	push   %eax
c0023188:	e8 27 e3 ff ff       	call   c00214b4 <thread_donate_priority>
c002318d:	83 c4 10             	add    $0x10,%esp
        cur_waiting_lock = cur_waiting_lock->holder->lock_waiting;
c0023190:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023193:	8b 00                	mov    (%eax),%eax
c0023195:	8b 40 54             	mov    0x54(%eax),%eax
c0023198:	89 45 f4             	mov    %eax,-0xc(%ebp)
      while (cur_waiting_lock != NULL 
c002319b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002319f:	74 0b                	je     c00231ac <lock_acquire+0xfd>
              && now_priority > cur_waiting_lock -> max_priority) /* hodler of lock */
c00231a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00231a4:	8b 40 20             	mov    0x20(%eax),%eax
c00231a7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00231aa:	7c ca                	jl     c0023176 <lock_acquire+0xc7>
      }
    }
  }
  
  sema_down (&lock->semaphore);
c00231ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00231af:	83 c0 04             	add    $0x4,%eax
c00231b2:	83 ec 0c             	sub    $0xc,%esp
c00231b5:	50                   	push   %eax
c00231b6:	e8 08 fc ff ff       	call   c0022dc3 <sema_down>
c00231bb:	83 c4 10             	add    $0x10,%esp

  enum intr_level old_level = intr_disable ();
c00231be:	e8 ba e7 ff ff       	call   c002197d <intr_disable>
c00231c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /* finally can get the lock */
  cur_thread = thread_current();
c00231c6:	e8 c0 da ff ff       	call   c0020c8b <thread_current>
c00231cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (!thread_mlfqs)
c00231ce:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c00231d3:	83 f0 01             	xor    $0x1,%eax
c00231d6:	84 c0                	test   %al,%al
c00231d8:	74 5e                	je     c0023238 <lock_acquire+0x189>
  {
    cur_thread->lock_waiting = NULL;
c00231da:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00231dd:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
    lock->max_priority = cur_thread->priority;
c00231e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00231e7:	8b 50 1c             	mov    0x1c(%eax),%edx
c00231ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00231ed:	89 50 20             	mov    %edx,0x20(%eax)
    lock->holder = cur_thread;
c00231f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00231f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00231f6:	89 10                	mov    %edx,(%eax)
    list_insert_ordered (&cur_thread->holding_locks, &lock->lock_elem, lock_priority_cmp, NULL);
c00231f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00231fb:	8d 50 18             	lea    0x18(%eax),%edx
c00231fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023201:	83 c0 40             	add    $0x40,%eax
c0023204:	6a 00                	push   $0x0
c0023206:	68 b1 36 02 c0       	push   $0xc00236b1
c002320b:	52                   	push   %edx
c002320c:	50                   	push   %eax
c002320d:	e8 21 7b 00 00       	call   c002ad33 <list_insert_ordered>
c0023212:	83 c4 10             	add    $0x10,%esp
    if (cur_thread->priority < lock->max_priority)
c0023215:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023218:	8b 50 1c             	mov    0x1c(%eax),%edx
c002321b:	8b 45 08             	mov    0x8(%ebp),%eax
c002321e:	8b 40 20             	mov    0x20(%eax),%eax
c0023221:	39 c2                	cmp    %eax,%edx
c0023223:	7d 1b                	jge    c0023240 <lock_acquire+0x191>
    {
      cur_thread->priority = lock->max_priority;
c0023225:	8b 45 08             	mov    0x8(%ebp),%eax
c0023228:	8b 50 20             	mov    0x20(%eax),%edx
c002322b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002322e:	89 50 1c             	mov    %edx,0x1c(%eax)
      thread_yield ();
c0023231:	e8 4b db ff ff       	call   c0020d81 <thread_yield>
c0023236:	eb 08                	jmp    c0023240 <lock_acquire+0x191>
    }
  } else
  {
    lock->holder = cur_thread;
c0023238:	8b 45 08             	mov    0x8(%ebp),%eax
c002323b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002323e:	89 10                	mov    %edx,(%eax)
  }
  
  intr_set_level (old_level);
c0023240:	83 ec 0c             	sub    $0xc,%esp
c0023243:	ff 75 e8             	pushl  -0x18(%ebp)
c0023246:	e8 da e6 ff ff       	call   c0021925 <intr_set_level>
c002324b:	83 c4 10             	add    $0x10,%esp
}
c002324e:	90                   	nop
c002324f:	c9                   	leave  
c0023250:	c3                   	ret    

c0023251 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0023251:	55                   	push   %ebp
c0023252:	89 e5                	mov    %esp,%ebp
c0023254:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0023257:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002325b:	75 21                	jne    c002327e <lock_try_acquire+0x2d>
c002325d:	83 ec 0c             	sub    $0xc,%esp
c0023260:	68 dd fa 02 c0       	push   $0xc002fadd
c0023265:	68 79 fa 02 c0       	push   $0xc002fa79
c002326a:	68 8c fb 02 c0       	push   $0xc002fb8c
c002326f:	68 03 01 00 00       	push   $0x103
c0023274:	68 90 fa 02 c0       	push   $0xc002fa90
c0023279:	e8 a4 6d 00 00       	call   c002a022 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c002327e:	83 ec 0c             	sub    $0xc,%esp
c0023281:	ff 75 08             	pushl  0x8(%ebp)
c0023284:	e8 16 01 00 00       	call   c002339f <lock_held_by_current_thread>
c0023289:	83 c4 10             	add    $0x10,%esp
c002328c:	83 f0 01             	xor    $0x1,%eax
c002328f:	84 c0                	test   %al,%al
c0023291:	75 21                	jne    c00232b4 <lock_try_acquire+0x63>
c0023293:	83 ec 0c             	sub    $0xc,%esp
c0023296:	68 ec fa 02 c0       	push   $0xc002faec
c002329b:	68 79 fa 02 c0       	push   $0xc002fa79
c00232a0:	68 8c fb 02 c0       	push   $0xc002fb8c
c00232a5:	68 04 01 00 00       	push   $0x104
c00232aa:	68 90 fa 02 c0       	push   $0xc002fa90
c00232af:	e8 6e 6d 00 00       	call   c002a022 <debug_panic>

  success = sema_try_down (&lock->semaphore);
c00232b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00232b7:	83 c0 04             	add    $0x4,%eax
c00232ba:	83 ec 0c             	sub    $0xc,%esp
c00232bd:	50                   	push   %eax
c00232be:	e8 a9 fb ff ff       	call   c0022e6c <sema_try_down>
c00232c3:	83 c4 10             	add    $0x10,%esp
c00232c6:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c00232c9:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c00232cd:	74 0c                	je     c00232db <lock_try_acquire+0x8a>
    lock->holder = thread_current ();
c00232cf:	e8 b7 d9 ff ff       	call   c0020c8b <thread_current>
c00232d4:	89 c2                	mov    %eax,%edx
c00232d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00232d9:	89 10                	mov    %edx,(%eax)
  return success;
c00232db:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c00232de:	c9                   	leave  
c00232df:	c3                   	ret    

c00232e0 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c00232e0:	55                   	push   %ebp
c00232e1:	89 e5                	mov    %esp,%ebp
c00232e3:	83 ec 18             	sub    $0x18,%esp
  ASSERT (lock != NULL);
c00232e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00232ea:	75 21                	jne    c002330d <lock_release+0x2d>
c00232ec:	83 ec 0c             	sub    $0xc,%esp
c00232ef:	68 dd fa 02 c0       	push   $0xc002fadd
c00232f4:	68 79 fa 02 c0       	push   $0xc002fa79
c00232f9:	68 a0 fb 02 c0       	push   $0xc002fba0
c00232fe:	68 14 01 00 00       	push   $0x114
c0023303:	68 90 fa 02 c0       	push   $0xc002fa90
c0023308:	e8 15 6d 00 00       	call   c002a022 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c002330d:	83 ec 0c             	sub    $0xc,%esp
c0023310:	ff 75 08             	pushl  0x8(%ebp)
c0023313:	e8 87 00 00 00       	call   c002339f <lock_held_by_current_thread>
c0023318:	83 c4 10             	add    $0x10,%esp
c002331b:	84 c0                	test   %al,%al
c002331d:	75 21                	jne    c0023340 <lock_release+0x60>
c002331f:	83 ec 0c             	sub    $0xc,%esp
c0023322:	68 10 fb 02 c0       	push   $0xc002fb10
c0023327:	68 79 fa 02 c0       	push   $0xc002fa79
c002332c:	68 a0 fb 02 c0       	push   $0xc002fba0
c0023331:	68 15 01 00 00       	push   $0x115
c0023336:	68 90 fa 02 c0       	push   $0xc002fa90
c002333b:	e8 e2 6c 00 00       	call   c002a022 <debug_panic>

  enum intr_level old_level = intr_disable ();
c0023340:	e8 38 e6 ff ff       	call   c002197d <intr_disable>
c0023345:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (! thread_mlfqs) {
c0023348:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002334d:	83 f0 01             	xor    $0x1,%eax
c0023350:	84 c0                	test   %al,%al
c0023352:	74 1f                	je     c0023373 <lock_release+0x93>
    thread_remove_lock(lock);
c0023354:	83 ec 0c             	sub    $0xc,%esp
c0023357:	ff 75 08             	pushl  0x8(%ebp)
c002335a:	e8 c2 e2 ff ff       	call   c0021621 <thread_remove_lock>
c002335f:	83 c4 10             	add    $0x10,%esp
    thread_update_priority(thread_current());
c0023362:	e8 24 d9 ff ff       	call   c0020c8b <thread_current>
c0023367:	83 ec 0c             	sub    $0xc,%esp
c002336a:	50                   	push   %eax
c002336b:	e8 0e e2 ff ff       	call   c002157e <thread_update_priority>
c0023370:	83 c4 10             	add    $0x10,%esp
  }

  lock->holder = NULL;
c0023373:	8b 45 08             	mov    0x8(%ebp),%eax
c0023376:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c002337c:	8b 45 08             	mov    0x8(%ebp),%eax
c002337f:	83 c0 04             	add    $0x4,%eax
c0023382:	83 ec 0c             	sub    $0xc,%esp
c0023385:	50                   	push   %eax
c0023386:	e8 46 fb ff ff       	call   c0022ed1 <sema_up>
c002338b:	83 c4 10             	add    $0x10,%esp

  intr_set_level(old_level);
c002338e:	83 ec 0c             	sub    $0xc,%esp
c0023391:	ff 75 f4             	pushl  -0xc(%ebp)
c0023394:	e8 8c e5 ff ff       	call   c0021925 <intr_set_level>
c0023399:	83 c4 10             	add    $0x10,%esp
}
c002339c:	90                   	nop
c002339d:	c9                   	leave  
c002339e:	c3                   	ret    

c002339f <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c002339f:	55                   	push   %ebp
c00233a0:	89 e5                	mov    %esp,%ebp
c00233a2:	53                   	push   %ebx
c00233a3:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c00233a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00233aa:	75 21                	jne    c00233cd <lock_held_by_current_thread+0x2e>
c00233ac:	83 ec 0c             	sub    $0xc,%esp
c00233af:	68 dd fa 02 c0       	push   $0xc002fadd
c00233b4:	68 79 fa 02 c0       	push   $0xc002fa79
c00233b9:	68 b0 fb 02 c0       	push   $0xc002fbb0
c00233be:	68 2a 01 00 00       	push   $0x12a
c00233c3:	68 90 fa 02 c0       	push   $0xc002fa90
c00233c8:	e8 55 6c 00 00       	call   c002a022 <debug_panic>

  return lock->holder == thread_current ();
c00233cd:	8b 45 08             	mov    0x8(%ebp),%eax
c00233d0:	8b 18                	mov    (%eax),%ebx
c00233d2:	e8 b4 d8 ff ff       	call   c0020c8b <thread_current>
c00233d7:	39 c3                	cmp    %eax,%ebx
c00233d9:	0f 94 c0             	sete   %al
}
c00233dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00233df:	c9                   	leave  
c00233e0:	c3                   	ret    

c00233e1 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c00233e1:	55                   	push   %ebp
c00233e2:	89 e5                	mov    %esp,%ebp
c00233e4:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c00233e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00233eb:	75 21                	jne    c002340e <cond_init+0x2d>
c00233ed:	83 ec 0c             	sub    $0xc,%esp
c00233f0:	68 33 fb 02 c0       	push   $0xc002fb33
c00233f5:	68 79 fa 02 c0       	push   $0xc002fa79
c00233fa:	68 cc fb 02 c0       	push   $0xc002fbcc
c00233ff:	68 3c 01 00 00       	push   $0x13c
c0023404:	68 90 fa 02 c0       	push   $0xc002fa90
c0023409:	e8 14 6c 00 00       	call   c002a022 <debug_panic>

  list_init (&cond->waiters);
c002340e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023411:	83 ec 0c             	sub    $0xc,%esp
c0023414:	50                   	push   %eax
c0023415:	e8 79 6e 00 00       	call   c002a293 <list_init>
c002341a:	83 c4 10             	add    $0x10,%esp
}
c002341d:	90                   	nop
c002341e:	c9                   	leave  
c002341f:	c3                   	ret    

c0023420 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0023420:	55                   	push   %ebp
c0023421:	89 e5                	mov    %esp,%ebp
c0023423:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0023426:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002342a:	75 21                	jne    c002344d <cond_wait+0x2d>
c002342c:	83 ec 0c             	sub    $0xc,%esp
c002342f:	68 33 fb 02 c0       	push   $0xc002fb33
c0023434:	68 79 fa 02 c0       	push   $0xc002fa79
c0023439:	68 d8 fb 02 c0       	push   $0xc002fbd8
c002343e:	68 5a 01 00 00       	push   $0x15a
c0023443:	68 90 fa 02 c0       	push   $0xc002fa90
c0023448:	e8 d5 6b 00 00       	call   c002a022 <debug_panic>
  ASSERT (lock != NULL);
c002344d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023451:	75 21                	jne    c0023474 <cond_wait+0x54>
c0023453:	83 ec 0c             	sub    $0xc,%esp
c0023456:	68 dd fa 02 c0       	push   $0xc002fadd
c002345b:	68 79 fa 02 c0       	push   $0xc002fa79
c0023460:	68 d8 fb 02 c0       	push   $0xc002fbd8
c0023465:	68 5b 01 00 00       	push   $0x15b
c002346a:	68 90 fa 02 c0       	push   $0xc002fa90
c002346f:	e8 ae 6b 00 00       	call   c002a022 <debug_panic>
  ASSERT (!intr_context ());
c0023474:	e8 d1 e7 ff ff       	call   c0021c4a <intr_context>
c0023479:	83 f0 01             	xor    $0x1,%eax
c002347c:	84 c0                	test   %al,%al
c002347e:	75 21                	jne    c00234a1 <cond_wait+0x81>
c0023480:	83 ec 0c             	sub    $0xc,%esp
c0023483:	68 a6 fa 02 c0       	push   $0xc002faa6
c0023488:	68 79 fa 02 c0       	push   $0xc002fa79
c002348d:	68 d8 fb 02 c0       	push   $0xc002fbd8
c0023492:	68 5c 01 00 00       	push   $0x15c
c0023497:	68 90 fa 02 c0       	push   $0xc002fa90
c002349c:	e8 81 6b 00 00       	call   c002a022 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00234a1:	83 ec 0c             	sub    $0xc,%esp
c00234a4:	ff 75 0c             	pushl  0xc(%ebp)
c00234a7:	e8 f3 fe ff ff       	call   c002339f <lock_held_by_current_thread>
c00234ac:	83 c4 10             	add    $0x10,%esp
c00234af:	84 c0                	test   %al,%al
c00234b1:	75 21                	jne    c00234d4 <cond_wait+0xb4>
c00234b3:	83 ec 0c             	sub    $0xc,%esp
c00234b6:	68 10 fb 02 c0       	push   $0xc002fb10
c00234bb:	68 79 fa 02 c0       	push   $0xc002fa79
c00234c0:	68 d8 fb 02 c0       	push   $0xc002fbd8
c00234c5:	68 5d 01 00 00       	push   $0x15d
c00234ca:	68 90 fa 02 c0       	push   $0xc002fa90
c00234cf:	e8 4e 6b 00 00       	call   c002a022 <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c00234d4:	83 ec 08             	sub    $0x8,%esp
c00234d7:	6a 00                	push   $0x0
c00234d9:	8d 45 dc             	lea    -0x24(%ebp),%eax
c00234dc:	83 c0 08             	add    $0x8,%eax
c00234df:	50                   	push   %eax
c00234e0:	e8 97 f8 ff ff       	call   c0022d7c <sema_init>
c00234e5:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c00234e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00234eb:	83 ec 08             	sub    $0x8,%esp
c00234ee:	8d 55 dc             	lea    -0x24(%ebp),%edx
c00234f1:	52                   	push   %edx
c00234f2:	50                   	push   %eax
c00234f3:	e8 7b 71 00 00       	call   c002a673 <list_push_back>
c00234f8:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c00234fb:	83 ec 0c             	sub    $0xc,%esp
c00234fe:	ff 75 0c             	pushl  0xc(%ebp)
c0023501:	e8 da fd ff ff       	call   c00232e0 <lock_release>
c0023506:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0023509:	83 ec 0c             	sub    $0xc,%esp
c002350c:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002350f:	83 c0 08             	add    $0x8,%eax
c0023512:	50                   	push   %eax
c0023513:	e8 ab f8 ff ff       	call   c0022dc3 <sema_down>
c0023518:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002351b:	83 ec 0c             	sub    $0xc,%esp
c002351e:	ff 75 0c             	pushl  0xc(%ebp)
c0023521:	e8 89 fb ff ff       	call   c00230af <lock_acquire>
c0023526:	83 c4 10             	add    $0x10,%esp
}
c0023529:	90                   	nop
c002352a:	c9                   	leave  
c002352b:	c3                   	ret    

c002352c <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c002352c:	55                   	push   %ebp
c002352d:	89 e5                	mov    %esp,%ebp
c002352f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0023532:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023536:	75 21                	jne    c0023559 <cond_signal+0x2d>
c0023538:	83 ec 0c             	sub    $0xc,%esp
c002353b:	68 33 fb 02 c0       	push   $0xc002fb33
c0023540:	68 79 fa 02 c0       	push   $0xc002fa79
c0023545:	68 e4 fb 02 c0       	push   $0xc002fbe4
c002354a:	68 70 01 00 00       	push   $0x170
c002354f:	68 90 fa 02 c0       	push   $0xc002fa90
c0023554:	e8 c9 6a 00 00       	call   c002a022 <debug_panic>
  ASSERT (lock != NULL);
c0023559:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002355d:	75 21                	jne    c0023580 <cond_signal+0x54>
c002355f:	83 ec 0c             	sub    $0xc,%esp
c0023562:	68 dd fa 02 c0       	push   $0xc002fadd
c0023567:	68 79 fa 02 c0       	push   $0xc002fa79
c002356c:	68 e4 fb 02 c0       	push   $0xc002fbe4
c0023571:	68 71 01 00 00       	push   $0x171
c0023576:	68 90 fa 02 c0       	push   $0xc002fa90
c002357b:	e8 a2 6a 00 00       	call   c002a022 <debug_panic>
  ASSERT (!intr_context ());
c0023580:	e8 c5 e6 ff ff       	call   c0021c4a <intr_context>
c0023585:	83 f0 01             	xor    $0x1,%eax
c0023588:	84 c0                	test   %al,%al
c002358a:	75 21                	jne    c00235ad <cond_signal+0x81>
c002358c:	83 ec 0c             	sub    $0xc,%esp
c002358f:	68 a6 fa 02 c0       	push   $0xc002faa6
c0023594:	68 79 fa 02 c0       	push   $0xc002fa79
c0023599:	68 e4 fb 02 c0       	push   $0xc002fbe4
c002359e:	68 72 01 00 00       	push   $0x172
c00235a3:	68 90 fa 02 c0       	push   $0xc002fa90
c00235a8:	e8 75 6a 00 00       	call   c002a022 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00235ad:	83 ec 0c             	sub    $0xc,%esp
c00235b0:	ff 75 0c             	pushl  0xc(%ebp)
c00235b3:	e8 e7 fd ff ff       	call   c002339f <lock_held_by_current_thread>
c00235b8:	83 c4 10             	add    $0x10,%esp
c00235bb:	84 c0                	test   %al,%al
c00235bd:	75 21                	jne    c00235e0 <cond_signal+0xb4>
c00235bf:	83 ec 0c             	sub    $0xc,%esp
c00235c2:	68 10 fb 02 c0       	push   $0xc002fb10
c00235c7:	68 79 fa 02 c0       	push   $0xc002fa79
c00235cc:	68 e4 fb 02 c0       	push   $0xc002fbe4
c00235d1:	68 73 01 00 00       	push   $0x173
c00235d6:	68 90 fa 02 c0       	push   $0xc002fa90
c00235db:	e8 42 6a 00 00       	call   c002a022 <debug_panic>

  if (!list_empty (&cond->waiters)) 
c00235e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00235e3:	83 ec 0c             	sub    $0xc,%esp
c00235e6:	50                   	push   %eax
c00235e7:	e8 2e 72 00 00       	call   c002a81a <list_empty>
c00235ec:	83 c4 10             	add    $0x10,%esp
c00235ef:	83 f0 01             	xor    $0x1,%eax
c00235f2:	84 c0                	test   %al,%al
c00235f4:	74 3a                	je     c0023630 <cond_signal+0x104>
  {
    list_sort (&cond->waiters, cond_sema_cmp, NULL);
c00235f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00235f9:	83 ec 04             	sub    $0x4,%esp
c00235fc:	6a 00                	push   $0x0
c00235fe:	68 e2 36 02 c0       	push   $0xc00236e2
c0023603:	50                   	push   %eax
c0023604:	e8 c2 75 00 00       	call   c002abcb <list_sort>
c0023609:	83 c4 10             	add    $0x10,%esp
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c002360c:	8b 45 08             	mov    0x8(%ebp),%eax
c002360f:	83 ec 0c             	sub    $0xc,%esp
c0023612:	50                   	push   %eax
c0023613:	e8 da 70 00 00       	call   c002a6f2 <list_pop_front>
c0023618:	83 c4 10             	add    $0x10,%esp
c002361b:	83 c0 04             	add    $0x4,%eax
c002361e:	83 e8 04             	sub    $0x4,%eax
c0023621:	83 c0 08             	add    $0x8,%eax
c0023624:	83 ec 0c             	sub    $0xc,%esp
c0023627:	50                   	push   %eax
c0023628:	e8 a4 f8 ff ff       	call   c0022ed1 <sema_up>
c002362d:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
  }
}
c0023630:	90                   	nop
c0023631:	c9                   	leave  
c0023632:	c3                   	ret    

c0023633 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0023633:	55                   	push   %ebp
c0023634:	89 e5                	mov    %esp,%ebp
c0023636:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0023639:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002363d:	75 21                	jne    c0023660 <cond_broadcast+0x2d>
c002363f:	83 ec 0c             	sub    $0xc,%esp
c0023642:	68 33 fb 02 c0       	push   $0xc002fb33
c0023647:	68 79 fa 02 c0       	push   $0xc002fa79
c002364c:	68 f0 fb 02 c0       	push   $0xc002fbf0
c0023651:	68 86 01 00 00       	push   $0x186
c0023656:	68 90 fa 02 c0       	push   $0xc002fa90
c002365b:	e8 c2 69 00 00       	call   c002a022 <debug_panic>
  ASSERT (lock != NULL);
c0023660:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023664:	75 32                	jne    c0023698 <cond_broadcast+0x65>
c0023666:	83 ec 0c             	sub    $0xc,%esp
c0023669:	68 dd fa 02 c0       	push   $0xc002fadd
c002366e:	68 79 fa 02 c0       	push   $0xc002fa79
c0023673:	68 f0 fb 02 c0       	push   $0xc002fbf0
c0023678:	68 87 01 00 00       	push   $0x187
c002367d:	68 90 fa 02 c0       	push   $0xc002fa90
c0023682:	e8 9b 69 00 00       	call   c002a022 <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0023687:	83 ec 08             	sub    $0x8,%esp
c002368a:	ff 75 0c             	pushl  0xc(%ebp)
c002368d:	ff 75 08             	pushl  0x8(%ebp)
c0023690:	e8 97 fe ff ff       	call   c002352c <cond_signal>
c0023695:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c0023698:	8b 45 08             	mov    0x8(%ebp),%eax
c002369b:	83 ec 0c             	sub    $0xc,%esp
c002369e:	50                   	push   %eax
c002369f:	e8 76 71 00 00       	call   c002a81a <list_empty>
c00236a4:	83 c4 10             	add    $0x10,%esp
c00236a7:	83 f0 01             	xor    $0x1,%eax
c00236aa:	84 c0                	test   %al,%al
c00236ac:	75 d9                	jne    c0023687 <cond_broadcast+0x54>
}
c00236ae:	90                   	nop
c00236af:	c9                   	leave  
c00236b0:	c3                   	ret    

c00236b1 <lock_priority_cmp>:


/* Used to compare lock_priority */
bool 
lock_priority_cmp (const struct list_elem* l1, const struct list_elem* l2, void* aux UNUSED)
{
c00236b1:	55                   	push   %ebp
c00236b2:	89 e5                	mov    %esp,%ebp
c00236b4:	83 ec 10             	sub    $0x10,%esp
  struct lock* lock1 = list_entry(l1, struct lock, lock_elem);
c00236b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00236ba:	83 c0 04             	add    $0x4,%eax
c00236bd:	83 e8 1c             	sub    $0x1c,%eax
c00236c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct lock* lock2 = list_entry(l2, struct lock, lock_elem);
c00236c3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00236c6:	83 c0 04             	add    $0x4,%eax
c00236c9:	83 e8 1c             	sub    $0x1c,%eax
c00236cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return lock1->max_priority > lock2->max_priority;
c00236cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00236d2:	8b 50 20             	mov    0x20(%eax),%edx
c00236d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00236d8:	8b 40 20             	mov    0x20(%eax),%eax
c00236db:	39 c2                	cmp    %eax,%edx
c00236dd:	0f 9f c0             	setg   %al
};
c00236e0:	c9                   	leave  
c00236e1:	c3                   	ret    

c00236e2 <cond_sema_cmp>:

/* Used to compare semaphore_elem for cond_signals */
bool 
cond_sema_cmp (const struct list_elem* t1, const struct list_elem* t2, void* aux UNUSED)  
{
c00236e2:	55                   	push   %ebp
c00236e3:	89 e5                	mov    %esp,%ebp
c00236e5:	83 ec 18             	sub    $0x18,%esp
  struct semaphore_elem *sema1 = list_entry (t1, struct semaphore_elem, elem);
c00236e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00236eb:	83 c0 04             	add    $0x4,%eax
c00236ee:	83 e8 04             	sub    $0x4,%eax
c00236f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct semaphore_elem *sema2 = list_entry (t2, struct semaphore_elem, elem);
c00236f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00236f7:	83 c0 04             	add    $0x4,%eax
c00236fa:	83 e8 04             	sub    $0x4,%eax
c00236fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread* thread1 = list_entry (list_front (&sema1->semaphore.waiters), struct thread, elem);
c0023700:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023703:	83 c0 0c             	add    $0xc,%eax
c0023706:	83 ec 0c             	sub    $0xc,%esp
c0023709:	50                   	push   %eax
c002370a:	e8 37 70 00 00       	call   c002a746 <list_front>
c002370f:	83 c4 10             	add    $0x10,%esp
c0023712:	83 c0 04             	add    $0x4,%eax
c0023715:	83 e8 2c             	sub    $0x2c,%eax
c0023718:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread* thread2 = list_entry (list_front (&sema2->semaphore.waiters), struct thread, elem);
c002371b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002371e:	83 c0 0c             	add    $0xc,%eax
c0023721:	83 ec 0c             	sub    $0xc,%esp
c0023724:	50                   	push   %eax
c0023725:	e8 1c 70 00 00       	call   c002a746 <list_front>
c002372a:	83 c4 10             	add    $0x10,%esp
c002372d:	83 c0 04             	add    $0x4,%eax
c0023730:	83 e8 2c             	sub    $0x2c,%eax
c0023733:	89 45 e8             	mov    %eax,-0x18(%ebp)
  return thread1->priority > thread2->priority;
c0023736:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023739:	8b 50 1c             	mov    0x1c(%eax),%edx
c002373c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002373f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023742:	39 c2                	cmp    %eax,%edx
c0023744:	0f 9f c0             	setg   %al
}
c0023747:	c9                   	leave  
c0023748:	c3                   	ret    

c0023749 <lock_update_priority>:


bool
lock_update_priority(struct lock* lock) 
{
c0023749:	55                   	push   %ebp
c002374a:	89 e5                	mov    %esp,%ebp
c002374c:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable();
c002374f:	e8 29 e2 ff ff       	call   c002197d <intr_disable>
c0023754:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (list_empty (&lock->semaphore.waiters))
c0023757:	8b 45 08             	mov    0x8(%ebp),%eax
c002375a:	83 c0 08             	add    $0x8,%eax
c002375d:	83 ec 0c             	sub    $0xc,%esp
c0023760:	50                   	push   %eax
c0023761:	e8 b4 70 00 00       	call   c002a81a <list_empty>
c0023766:	83 c4 10             	add    $0x10,%esp
c0023769:	84 c0                	test   %al,%al
c002376b:	74 0c                	je     c0023779 <lock_update_priority+0x30>
    lock->max_priority = PRI_MIN;
c002376d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023770:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c0023777:	eb 21                	jmp    c002379a <lock_update_priority+0x51>
  else
    lock->max_priority = list_entry (list_front (&lock->semaphore.waiters), struct thread, elem)->priority;
c0023779:	8b 45 08             	mov    0x8(%ebp),%eax
c002377c:	83 c0 08             	add    $0x8,%eax
c002377f:	83 ec 0c             	sub    $0xc,%esp
c0023782:	50                   	push   %eax
c0023783:	e8 be 6f 00 00       	call   c002a746 <list_front>
c0023788:	83 c4 10             	add    $0x10,%esp
c002378b:	83 c0 04             	add    $0x4,%eax
c002378e:	83 e8 2c             	sub    $0x2c,%eax
c0023791:	8b 50 1c             	mov    0x1c(%eax),%edx
c0023794:	8b 45 08             	mov    0x8(%ebp),%eax
c0023797:	89 50 20             	mov    %edx,0x20(%eax)
  intr_set_level (old_level);
c002379a:	83 ec 0c             	sub    $0xc,%esp
c002379d:	ff 75 f4             	pushl  -0xc(%ebp)
c00237a0:	e8 80 e1 ff ff       	call   c0021925 <intr_set_level>
c00237a5:	83 c4 10             	add    $0x10,%esp
c00237a8:	90                   	nop
c00237a9:	c9                   	leave  
c00237aa:	c3                   	ret    

c00237ab <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c00237ab:	55                   	push   %ebp
c00237ac:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c00237ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00237b1:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00237b6:	5d                   	pop    %ebp
c00237b7:	c3                   	ret    

c00237b8 <pg_no>:
static inline uintptr_t pg_no (const void *va) {
c00237b8:	55                   	push   %ebp
c00237b9:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c00237bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00237be:	c1 e8 0c             	shr    $0xc,%eax
}
c00237c1:	5d                   	pop    %ebp
c00237c2:	c3                   	ret    

c00237c3 <ptov>:
{
c00237c3:	55                   	push   %ebp
c00237c4:	89 e5                	mov    %esp,%ebp
c00237c6:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00237c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00237cc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00237d1:	76 1e                	jbe    c00237f1 <ptov+0x2e>
c00237d3:	83 ec 0c             	sub    $0xc,%esp
c00237d6:	68 00 fc 02 c0       	push   $0xc002fc00
c00237db:	68 1b fc 02 c0       	push   $0xc002fc1b
c00237e0:	68 38 fd 02 c0       	push   $0xc002fd38
c00237e5:	6a 4a                	push   $0x4a
c00237e7:	68 32 fc 02 c0       	push   $0xc002fc32
c00237ec:	e8 31 68 00 00       	call   c002a022 <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c00237f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00237f4:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00237f9:	c9                   	leave  
c00237fa:	c3                   	ret    

c00237fb <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c00237fb:	55                   	push   %ebp
c00237fc:	89 e5                	mov    %esp,%ebp
c00237fe:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c0023801:	83 ec 0c             	sub    $0xc,%esp
c0023804:	68 00 00 10 00       	push   $0x100000
c0023809:	e8 b5 ff ff ff       	call   c00237c3 <ptov>
c002380e:	83 c4 10             	add    $0x10,%esp
c0023811:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0023814:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c0023819:	c1 e0 0c             	shl    $0xc,%eax
c002381c:	83 ec 0c             	sub    $0xc,%esp
c002381f:	50                   	push   %eax
c0023820:	e8 9e ff ff ff       	call   c00237c3 <ptov>
c0023825:	83 c4 10             	add    $0x10,%esp
c0023828:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c002382b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002382e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023831:	29 c2                	sub    %eax,%edx
c0023833:	89 d0                	mov    %edx,%eax
c0023835:	85 c0                	test   %eax,%eax
c0023837:	79 05                	jns    c002383e <palloc_init+0x43>
c0023839:	05 ff 0f 00 00       	add    $0xfff,%eax
c002383e:	c1 f8 0c             	sar    $0xc,%eax
c0023841:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c0023844:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023847:	d1 e8                	shr    %eax
c0023849:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c002384c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002384f:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023852:	76 06                	jbe    c002385a <palloc_init+0x5f>
    user_pages = user_page_limit;
c0023854:	8b 45 08             	mov    0x8(%ebp),%eax
c0023857:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c002385a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002385d:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0023860:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023863:	68 48 fc 02 c0       	push   $0xc002fc48
c0023868:	ff 75 e4             	pushl  -0x1c(%ebp)
c002386b:	ff 75 f0             	pushl  -0x10(%ebp)
c002386e:	68 00 9a 03 c0       	push   $0xc0039a00
c0023873:	e8 6e 02 00 00       	call   c0023ae6 <init_pool>
c0023878:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c002387b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002387e:	c1 e0 0c             	shl    $0xc,%eax
c0023881:	89 c2                	mov    %eax,%edx
c0023883:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023886:	01 d0                	add    %edx,%eax
c0023888:	68 54 fc 02 c0       	push   $0xc002fc54
c002388d:	ff 75 f4             	pushl  -0xc(%ebp)
c0023890:	50                   	push   %eax
c0023891:	68 40 9a 03 c0       	push   $0xc0039a40
c0023896:	e8 4b 02 00 00       	call   c0023ae6 <init_pool>
c002389b:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c002389e:	90                   	nop
c002389f:	c9                   	leave  
c00238a0:	c3                   	ret    

c00238a1 <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c00238a1:	55                   	push   %ebp
c00238a2:	89 e5                	mov    %esp,%ebp
c00238a4:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c00238a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00238aa:	83 e0 04             	and    $0x4,%eax
c00238ad:	85 c0                	test   %eax,%eax
c00238af:	74 07                	je     c00238b8 <palloc_get_multiple+0x17>
c00238b1:	b8 40 9a 03 c0       	mov    $0xc0039a40,%eax
c00238b6:	eb 05                	jmp    c00238bd <palloc_get_multiple+0x1c>
c00238b8:	b8 00 9a 03 c0       	mov    $0xc0039a00,%eax
c00238bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c00238c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00238c4:	75 0a                	jne    c00238d0 <palloc_get_multiple+0x2f>
    return NULL;
c00238c6:	b8 00 00 00 00       	mov    $0x0,%eax
c00238cb:	e9 a3 00 00 00       	jmp    c0023973 <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c00238d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00238d3:	83 ec 0c             	sub    $0xc,%esp
c00238d6:	50                   	push   %eax
c00238d7:	e8 d3 f7 ff ff       	call   c00230af <lock_acquire>
c00238dc:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00238df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00238e2:	8b 40 24             	mov    0x24(%eax),%eax
c00238e5:	6a 00                	push   $0x0
c00238e7:	ff 75 0c             	pushl  0xc(%ebp)
c00238ea:	6a 00                	push   $0x0
c00238ec:	50                   	push   %eax
c00238ed:	e8 55 7e 00 00       	call   c002b747 <bitmap_scan_and_flip>
c00238f2:	83 c4 10             	add    $0x10,%esp
c00238f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c00238f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00238fb:	83 ec 0c             	sub    $0xc,%esp
c00238fe:	50                   	push   %eax
c00238ff:	e8 dc f9 ff ff       	call   c00232e0 <lock_release>
c0023904:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c0023907:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c002390b:	74 13                	je     c0023920 <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c002390d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023910:	8b 40 28             	mov    0x28(%eax),%eax
c0023913:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023916:	c1 e2 0c             	shl    $0xc,%edx
c0023919:	01 d0                	add    %edx,%eax
c002391b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002391e:	eb 07                	jmp    c0023927 <palloc_get_multiple+0x86>
  else
    pages = NULL;
c0023920:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c0023927:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002392b:	74 23                	je     c0023950 <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c002392d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023930:	83 e0 02             	and    $0x2,%eax
c0023933:	85 c0                	test   %eax,%eax
c0023935:	74 39                	je     c0023970 <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c0023937:	8b 45 0c             	mov    0xc(%ebp),%eax
c002393a:	c1 e0 0c             	shl    $0xc,%eax
c002393d:	83 ec 04             	sub    $0x4,%esp
c0023940:	50                   	push   %eax
c0023941:	6a 00                	push   $0x0
c0023943:	ff 75 f4             	pushl  -0xc(%ebp)
c0023946:	e8 df 59 00 00       	call   c002932a <memset>
c002394b:	83 c4 10             	add    $0x10,%esp
c002394e:	eb 20                	jmp    c0023970 <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c0023950:	8b 45 08             	mov    0x8(%ebp),%eax
c0023953:	83 e0 01             	and    $0x1,%eax
c0023956:	85 c0                	test   %eax,%eax
c0023958:	74 16                	je     c0023970 <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c002395a:	68 5e fc 02 c0       	push   $0xc002fc5e
c002395f:	68 40 fd 02 c0       	push   $0xc002fd40
c0023964:	6a 61                	push   $0x61
c0023966:	68 77 fc 02 c0       	push   $0xc002fc77
c002396b:	e8 b2 66 00 00       	call   c002a022 <debug_panic>
    }

  return pages;
c0023970:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023973:	c9                   	leave  
c0023974:	c3                   	ret    

c0023975 <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c0023975:	55                   	push   %ebp
c0023976:	89 e5                	mov    %esp,%ebp
c0023978:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c002397b:	83 ec 08             	sub    $0x8,%esp
c002397e:	6a 01                	push   $0x1
c0023980:	ff 75 08             	pushl  0x8(%ebp)
c0023983:	e8 19 ff ff ff       	call   c00238a1 <palloc_get_multiple>
c0023988:	83 c4 10             	add    $0x10,%esp
}
c002398b:	c9                   	leave  
c002398c:	c3                   	ret    

c002398d <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c002398d:	55                   	push   %ebp
c002398e:	89 e5                	mov    %esp,%ebp
c0023990:	53                   	push   %ebx
c0023991:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c0023994:	ff 75 08             	pushl  0x8(%ebp)
c0023997:	e8 0f fe ff ff       	call   c00237ab <pg_ofs>
c002399c:	83 c4 04             	add    $0x4,%esp
c002399f:	85 c0                	test   %eax,%eax
c00239a1:	74 1e                	je     c00239c1 <palloc_free_multiple+0x34>
c00239a3:	83 ec 0c             	sub    $0xc,%esp
c00239a6:	68 8e fc 02 c0       	push   $0xc002fc8e
c00239ab:	68 1b fc 02 c0       	push   $0xc002fc1b
c00239b0:	68 54 fd 02 c0       	push   $0xc002fd54
c00239b5:	6a 7b                	push   $0x7b
c00239b7:	68 77 fc 02 c0       	push   $0xc002fc77
c00239bc:	e8 61 66 00 00       	call   c002a022 <debug_panic>
  if (pages == NULL || page_cnt == 0)
c00239c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00239c5:	0f 84 fc 00 00 00    	je     c0023ac7 <palloc_free_multiple+0x13a>
c00239cb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00239cf:	0f 84 f2 00 00 00    	je     c0023ac7 <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c00239d5:	83 ec 08             	sub    $0x8,%esp
c00239d8:	ff 75 08             	pushl  0x8(%ebp)
c00239db:	68 00 9a 03 c0       	push   $0xc0039a00
c00239e0:	e8 a8 01 00 00       	call   c0023b8d <page_from_pool>
c00239e5:	83 c4 10             	add    $0x10,%esp
c00239e8:	84 c0                	test   %al,%al
c00239ea:	74 09                	je     c00239f5 <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c00239ec:	c7 45 f4 00 9a 03 c0 	movl   $0xc0039a00,-0xc(%ebp)
c00239f3:	eb 39                	jmp    c0023a2e <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c00239f5:	83 ec 08             	sub    $0x8,%esp
c00239f8:	ff 75 08             	pushl  0x8(%ebp)
c00239fb:	68 40 9a 03 c0       	push   $0xc0039a40
c0023a00:	e8 88 01 00 00       	call   c0023b8d <page_from_pool>
c0023a05:	83 c4 10             	add    $0x10,%esp
c0023a08:	84 c0                	test   %al,%al
c0023a0a:	74 09                	je     c0023a15 <palloc_free_multiple+0x88>
    pool = &user_pool;
c0023a0c:	c7 45 f4 40 9a 03 c0 	movl   $0xc0039a40,-0xc(%ebp)
c0023a13:	eb 19                	jmp    c0023a2e <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c0023a15:	68 a4 fc 02 c0       	push   $0xc002fca4
c0023a1a:	68 54 fd 02 c0       	push   $0xc002fd54
c0023a1f:	68 84 00 00 00       	push   $0x84
c0023a24:	68 77 fc 02 c0       	push   $0xc002fc77
c0023a29:	e8 f4 65 00 00       	call   c002a022 <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c0023a2e:	83 ec 0c             	sub    $0xc,%esp
c0023a31:	ff 75 08             	pushl  0x8(%ebp)
c0023a34:	e8 7f fd ff ff       	call   c00237b8 <pg_no>
c0023a39:	83 c4 10             	add    $0x10,%esp
c0023a3c:	89 c3                	mov    %eax,%ebx
c0023a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a41:	8b 40 28             	mov    0x28(%eax),%eax
c0023a44:	83 ec 0c             	sub    $0xc,%esp
c0023a47:	50                   	push   %eax
c0023a48:	e8 6b fd ff ff       	call   c00237b8 <pg_no>
c0023a4d:	83 c4 10             	add    $0x10,%esp
c0023a50:	29 c3                	sub    %eax,%ebx
c0023a52:	89 d8                	mov    %ebx,%eax
c0023a54:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c0023a57:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023a5a:	c1 e0 0c             	shl    $0xc,%eax
c0023a5d:	83 ec 04             	sub    $0x4,%esp
c0023a60:	50                   	push   %eax
c0023a61:	68 cc 00 00 00       	push   $0xcc
c0023a66:	ff 75 08             	pushl  0x8(%ebp)
c0023a69:	e8 bc 58 00 00       	call   c002932a <memset>
c0023a6e:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023a71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a74:	8b 40 24             	mov    0x24(%eax),%eax
c0023a77:	83 ec 04             	sub    $0x4,%esp
c0023a7a:	ff 75 0c             	pushl  0xc(%ebp)
c0023a7d:	ff 75 f0             	pushl  -0x10(%ebp)
c0023a80:	50                   	push   %eax
c0023a81:	e8 d5 7b 00 00       	call   c002b65b <bitmap_all>
c0023a86:	83 c4 10             	add    $0x10,%esp
c0023a89:	84 c0                	test   %al,%al
c0023a8b:	75 21                	jne    c0023aae <palloc_free_multiple+0x121>
c0023a8d:	83 ec 0c             	sub    $0xc,%esp
c0023a90:	68 c8 fc 02 c0       	push   $0xc002fcc8
c0023a95:	68 1b fc 02 c0       	push   $0xc002fc1b
c0023a9a:	68 54 fd 02 c0       	push   $0xc002fd54
c0023a9f:	68 8c 00 00 00       	push   $0x8c
c0023aa4:	68 77 fc 02 c0       	push   $0xc002fc77
c0023aa9:	e8 74 65 00 00       	call   c002a022 <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023aae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ab1:	8b 40 24             	mov    0x24(%eax),%eax
c0023ab4:	6a 00                	push   $0x0
c0023ab6:	ff 75 0c             	pushl  0xc(%ebp)
c0023ab9:	ff 75 f0             	pushl  -0x10(%ebp)
c0023abc:	50                   	push   %eax
c0023abd:	e8 f8 78 00 00       	call   c002b3ba <bitmap_set_multiple>
c0023ac2:	83 c4 10             	add    $0x10,%esp
c0023ac5:	eb 01                	jmp    c0023ac8 <palloc_free_multiple+0x13b>
    return;
c0023ac7:	90                   	nop
}
c0023ac8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023acb:	c9                   	leave  
c0023acc:	c3                   	ret    

c0023acd <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c0023acd:	55                   	push   %ebp
c0023ace:	89 e5                	mov    %esp,%ebp
c0023ad0:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c0023ad3:	83 ec 08             	sub    $0x8,%esp
c0023ad6:	6a 01                	push   $0x1
c0023ad8:	ff 75 08             	pushl  0x8(%ebp)
c0023adb:	e8 ad fe ff ff       	call   c002398d <palloc_free_multiple>
c0023ae0:	83 c4 10             	add    $0x10,%esp
}
c0023ae3:	90                   	nop
c0023ae4:	c9                   	leave  
c0023ae5:	c3                   	ret    

c0023ae6 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023ae6:	55                   	push   %ebp
c0023ae7:	89 e5                	mov    %esp,%ebp
c0023ae9:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c0023aec:	83 ec 0c             	sub    $0xc,%esp
c0023aef:	ff 75 10             	pushl  0x10(%ebp)
c0023af2:	e8 59 76 00 00       	call   c002b150 <bitmap_buf_size>
c0023af7:	83 c4 10             	add    $0x10,%esp
c0023afa:	05 ff 0f 00 00       	add    $0xfff,%eax
c0023aff:	c1 e8 0c             	shr    $0xc,%eax
c0023b02:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c0023b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b08:	3b 45 10             	cmp    0x10(%ebp),%eax
c0023b0b:	76 1f                	jbe    c0023b2c <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c0023b0d:	83 ec 0c             	sub    $0xc,%esp
c0023b10:	ff 75 14             	pushl  0x14(%ebp)
c0023b13:	68 f8 fc 02 c0       	push   $0xc002fcf8
c0023b18:	68 6c fd 02 c0       	push   $0xc002fd6c
c0023b1d:	68 a1 00 00 00       	push   $0xa1
c0023b22:	68 77 fc 02 c0       	push   $0xc002fc77
c0023b27:	e8 f6 64 00 00       	call   c002a022 <debug_panic>
  page_cnt -= bm_pages;
c0023b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b2f:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c0023b32:	83 ec 04             	sub    $0x4,%esp
c0023b35:	ff 75 14             	pushl  0x14(%ebp)
c0023b38:	ff 75 10             	pushl  0x10(%ebp)
c0023b3b:	68 1c fd 02 c0       	push   $0xc002fd1c
c0023b40:	e8 0c 40 00 00       	call   c0027b51 <printf>
c0023b45:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c0023b48:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b4b:	83 ec 0c             	sub    $0xc,%esp
c0023b4e:	50                   	push   %eax
c0023b4f:	e8 0e f5 ff ff       	call   c0023062 <lock_init>
c0023b54:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0023b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b5a:	c1 e0 0c             	shl    $0xc,%eax
c0023b5d:	83 ec 04             	sub    $0x4,%esp
c0023b60:	50                   	push   %eax
c0023b61:	ff 75 0c             	pushl  0xc(%ebp)
c0023b64:	ff 75 10             	pushl  0x10(%ebp)
c0023b67:	e8 7e 75 00 00       	call   c002b0ea <bitmap_create_in_buf>
c0023b6c:	83 c4 10             	add    $0x10,%esp
c0023b6f:	89 c2                	mov    %eax,%edx
c0023b71:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b74:	89 50 24             	mov    %edx,0x24(%eax)
  p->base = base + bm_pages * PGSIZE;
c0023b77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b7a:	c1 e0 0c             	shl    $0xc,%eax
c0023b7d:	89 c2                	mov    %eax,%edx
c0023b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023b82:	01 c2                	add    %eax,%edx
c0023b84:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b87:	89 50 28             	mov    %edx,0x28(%eax)
}
c0023b8a:	90                   	nop
c0023b8b:	c9                   	leave  
c0023b8c:	c3                   	ret    

c0023b8d <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c0023b8d:	55                   	push   %ebp
c0023b8e:	89 e5                	mov    %esp,%ebp
c0023b90:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c0023b93:	ff 75 0c             	pushl  0xc(%ebp)
c0023b96:	e8 1d fc ff ff       	call   c00237b8 <pg_no>
c0023b9b:	83 c4 04             	add    $0x4,%esp
c0023b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c0023ba1:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ba4:	8b 40 28             	mov    0x28(%eax),%eax
c0023ba7:	50                   	push   %eax
c0023ba8:	e8 0b fc ff ff       	call   c00237b8 <pg_no>
c0023bad:	83 c4 04             	add    $0x4,%esp
c0023bb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023bb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0023bb6:	8b 40 24             	mov    0x24(%eax),%eax
c0023bb9:	83 ec 0c             	sub    $0xc,%esp
c0023bbc:	50                   	push   %eax
c0023bbd:	e8 d0 75 00 00       	call   c002b192 <bitmap_size>
c0023bc2:	83 c4 10             	add    $0x10,%esp
c0023bc5:	89 c2                	mov    %eax,%edx
c0023bc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023bca:	01 d0                	add    %edx,%eax
c0023bcc:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c0023bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023bd2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023bd5:	72 0f                	jb     c0023be6 <page_from_pool+0x59>
c0023bd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023bda:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0023bdd:	73 07                	jae    c0023be6 <page_from_pool+0x59>
c0023bdf:	b8 01 00 00 00       	mov    $0x1,%eax
c0023be4:	eb 05                	jmp    c0023beb <page_from_pool+0x5e>
c0023be6:	b8 00 00 00 00       	mov    $0x0,%eax
c0023beb:	83 e0 01             	and    $0x1,%eax
}
c0023bee:	c9                   	leave  
c0023bef:	c3                   	ret    

c0023bf0 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c0023bf0:	55                   	push   %ebp
c0023bf1:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0023bf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0023bf6:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0023bfb:	5d                   	pop    %ebp
c0023bfc:	c3                   	ret    

c0023bfd <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c0023bfd:	55                   	push   %ebp
c0023bfe:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c0023c00:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c03:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c0023c08:	5d                   	pop    %ebp
c0023c09:	c3                   	ret    

c0023c0a <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c0023c0a:	55                   	push   %ebp
c0023c0b:	89 e5                	mov    %esp,%ebp
c0023c0d:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023c10:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0023c17:	e9 99 00 00 00       	jmp    c0023cb5 <malloc_init+0xab>
    {
      struct desc *d = &descs[desc_cnt++];
c0023c1c:	8b 15 d8 9c 03 c0    	mov    0xc0039cd8,%edx
c0023c22:	8d 42 01             	lea    0x1(%edx),%eax
c0023c25:	a3 d8 9c 03 c0       	mov    %eax,0xc0039cd8
c0023c2a:	89 d0                	mov    %edx,%eax
c0023c2c:	01 c0                	add    %eax,%eax
c0023c2e:	01 d0                	add    %edx,%eax
c0023c30:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0023c37:	01 d0                	add    %edx,%eax
c0023c39:	c1 e0 02             	shl    $0x2,%eax
c0023c3c:	05 80 9a 03 c0       	add    $0xc0039a80,%eax
c0023c41:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023c44:	a1 d8 9c 03 c0       	mov    0xc0039cd8,%eax
c0023c49:	83 f8 0a             	cmp    $0xa,%eax
c0023c4c:	76 1e                	jbe    c0023c6c <malloc_init+0x62>
c0023c4e:	83 ec 0c             	sub    $0xc,%esp
c0023c51:	68 78 fd 02 c0       	push   $0xc002fd78
c0023c56:	68 a1 fd 02 c0       	push   $0xc002fda1
c0023c5b:	68 ac fe 02 c0       	push   $0xc002feac
c0023c60:	6a 4f                	push   $0x4f
c0023c62:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0023c67:	e8 b6 63 00 00       	call   c002a022 <debug_panic>
      d->block_size = block_size;
c0023c6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023c72:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023c74:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023c79:	ba 00 00 00 00       	mov    $0x0,%edx
c0023c7e:	f7 75 f4             	divl   -0xc(%ebp)
c0023c81:	89 c2                	mov    %eax,%edx
c0023c83:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c86:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c0023c89:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c8c:	83 c0 08             	add    $0x8,%eax
c0023c8f:	83 ec 0c             	sub    $0xc,%esp
c0023c92:	50                   	push   %eax
c0023c93:	e8 fb 65 00 00       	call   c002a293 <list_init>
c0023c98:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c0023c9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c9e:	83 c0 18             	add    $0x18,%eax
c0023ca1:	83 ec 0c             	sub    $0xc,%esp
c0023ca4:	50                   	push   %eax
c0023ca5:	e8 b8 f3 ff ff       	call   c0023062 <lock_init>
c0023caa:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023cad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023cb0:	01 c0                	add    %eax,%eax
c0023cb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023cb5:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023cbc:	0f 86 5a ff ff ff    	jbe    c0023c1c <malloc_init+0x12>
    }
}
c0023cc2:	90                   	nop
c0023cc3:	c9                   	leave  
c0023cc4:	c3                   	ret    

c0023cc5 <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c0023cc5:	55                   	push   %ebp
c0023cc6:	89 e5                	mov    %esp,%ebp
c0023cc8:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023ccb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023ccf:	75 0a                	jne    c0023cdb <malloc+0x16>
    return NULL;
c0023cd1:	b8 00 00 00 00       	mov    $0x0,%eax
c0023cd6:	e9 c3 01 00 00       	jmp    c0023e9e <malloc+0x1d9>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0023cdb:	c7 45 f4 80 9a 03 c0 	movl   $0xc0039a80,-0xc(%ebp)
c0023ce2:	eb 0e                	jmp    c0023cf2 <malloc+0x2d>
    if (d->block_size >= size)
c0023ce4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ce7:	8b 00                	mov    (%eax),%eax
c0023ce9:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023cec:	73 28                	jae    c0023d16 <malloc+0x51>
  for (d = descs; d < descs + desc_cnt; d++)
c0023cee:	83 45 f4 3c          	addl   $0x3c,-0xc(%ebp)
c0023cf2:	8b 15 d8 9c 03 c0    	mov    0xc0039cd8,%edx
c0023cf8:	89 d0                	mov    %edx,%eax
c0023cfa:	01 c0                	add    %eax,%eax
c0023cfc:	01 d0                	add    %edx,%eax
c0023cfe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0023d05:	01 d0                	add    %edx,%eax
c0023d07:	c1 e0 02             	shl    $0x2,%eax
c0023d0a:	05 80 9a 03 c0       	add    $0xc0039a80,%eax
c0023d0f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023d12:	77 d0                	ja     c0023ce4 <malloc+0x1f>
c0023d14:	eb 01                	jmp    c0023d17 <malloc+0x52>
      break;
c0023d16:	90                   	nop
  if (d == descs + desc_cnt) 
c0023d17:	8b 15 d8 9c 03 c0    	mov    0xc0039cd8,%edx
c0023d1d:	89 d0                	mov    %edx,%eax
c0023d1f:	01 c0                	add    %eax,%eax
c0023d21:	01 d0                	add    %edx,%eax
c0023d23:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0023d2a:	01 d0                	add    %edx,%eax
c0023d2c:	c1 e0 02             	shl    $0x2,%eax
c0023d2f:	05 80 9a 03 c0       	add    $0xc0039a80,%eax
c0023d34:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023d37:	75 58                	jne    c0023d91 <malloc+0xcc>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023d39:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d3c:	05 0b 10 00 00       	add    $0x100b,%eax
c0023d41:	c1 e8 0c             	shr    $0xc,%eax
c0023d44:	89 45 ec             	mov    %eax,-0x14(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c0023d47:	83 ec 08             	sub    $0x8,%esp
c0023d4a:	ff 75 ec             	pushl  -0x14(%ebp)
c0023d4d:	6a 00                	push   $0x0
c0023d4f:	e8 4d fb ff ff       	call   c00238a1 <palloc_get_multiple>
c0023d54:	83 c4 10             	add    $0x10,%esp
c0023d57:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL)
c0023d5a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023d5e:	75 0a                	jne    c0023d6a <malloc+0xa5>
        return NULL;
c0023d60:	b8 00 00 00 00       	mov    $0x0,%eax
c0023d65:	e9 34 01 00 00       	jmp    c0023e9e <malloc+0x1d9>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c0023d6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d6d:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023d73:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d76:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023d7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d80:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023d83:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c0023d86:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d89:	83 c0 0c             	add    $0xc,%eax
c0023d8c:	e9 0d 01 00 00       	jmp    c0023e9e <malloc+0x1d9>
    }

  lock_acquire (&d->lock);
c0023d91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023d94:	83 c0 18             	add    $0x18,%eax
c0023d97:	83 ec 0c             	sub    $0xc,%esp
c0023d9a:	50                   	push   %eax
c0023d9b:	e8 0f f3 ff ff       	call   c00230af <lock_acquire>
c0023da0:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c0023da3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023da6:	83 c0 08             	add    $0x8,%eax
c0023da9:	83 ec 0c             	sub    $0xc,%esp
c0023dac:	50                   	push   %eax
c0023dad:	e8 68 6a 00 00       	call   c002a81a <list_empty>
c0023db2:	83 c4 10             	add    $0x10,%esp
c0023db5:	84 c0                	test   %al,%al
c0023db7:	0f 84 91 00 00 00    	je     c0023e4e <malloc+0x189>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023dbd:	83 ec 0c             	sub    $0xc,%esp
c0023dc0:	6a 00                	push   $0x0
c0023dc2:	e8 ae fb ff ff       	call   c0023975 <palloc_get_page>
c0023dc7:	83 c4 10             	add    $0x10,%esp
c0023dca:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL) 
c0023dcd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023dd1:	75 1c                	jne    c0023def <malloc+0x12a>
        {
          lock_release (&d->lock);
c0023dd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023dd6:	83 c0 18             	add    $0x18,%eax
c0023dd9:	83 ec 0c             	sub    $0xc,%esp
c0023ddc:	50                   	push   %eax
c0023ddd:	e8 fe f4 ff ff       	call   c00232e0 <lock_release>
c0023de2:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0023de5:	b8 00 00 00 00       	mov    $0x0,%eax
c0023dea:	e9 af 00 00 00       	jmp    c0023e9e <malloc+0x1d9>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c0023def:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023df2:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023df8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023dfb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023dfe:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023e01:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e04:	8b 50 04             	mov    0x4(%eax),%edx
c0023e07:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e0a:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023e0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0023e14:	eb 2d                	jmp    c0023e43 <malloc+0x17e>
        {
          struct block *b = arena_to_block (a, i);
c0023e16:	83 ec 08             	sub    $0x8,%esp
c0023e19:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e1c:	ff 75 e8             	pushl  -0x18(%ebp)
c0023e1f:	e8 ea 03 00 00       	call   c002420e <arena_to_block>
c0023e24:	83 c4 10             	add    $0x10,%esp
c0023e27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c0023e2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023e2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023e30:	83 c2 08             	add    $0x8,%edx
c0023e33:	83 ec 08             	sub    $0x8,%esp
c0023e36:	50                   	push   %eax
c0023e37:	52                   	push   %edx
c0023e38:	e8 36 68 00 00       	call   c002a673 <list_push_back>
c0023e3d:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023e40:	ff 45 f0             	incl   -0x10(%ebp)
c0023e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e46:	8b 40 04             	mov    0x4(%eax),%eax
c0023e49:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023e4c:	77 c8                	ja     c0023e16 <malloc+0x151>
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e51:	83 c0 08             	add    $0x8,%eax
c0023e54:	83 ec 0c             	sub    $0xc,%esp
c0023e57:	50                   	push   %eax
c0023e58:	e8 95 68 00 00       	call   c002a6f2 <list_pop_front>
c0023e5d:	83 c4 10             	add    $0x10,%esp
c0023e60:	83 c0 04             	add    $0x4,%eax
c0023e63:	83 e8 04             	sub    $0x4,%eax
c0023e66:	89 45 e0             	mov    %eax,-0x20(%ebp)
  a = block_to_arena (b);
c0023e69:	83 ec 0c             	sub    $0xc,%esp
c0023e6c:	ff 75 e0             	pushl  -0x20(%ebp)
c0023e6f:	e8 9c 02 00 00       	call   c0024110 <block_to_arena>
c0023e74:	83 c4 10             	add    $0x10,%esp
c0023e77:	89 45 e8             	mov    %eax,-0x18(%ebp)
  a->free_cnt--;
c0023e7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e7d:	8b 40 08             	mov    0x8(%eax),%eax
c0023e80:	8d 50 ff             	lea    -0x1(%eax),%edx
c0023e83:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e86:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c0023e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e8c:	83 c0 18             	add    $0x18,%eax
c0023e8f:	83 ec 0c             	sub    $0xc,%esp
c0023e92:	50                   	push   %eax
c0023e93:	e8 48 f4 ff ff       	call   c00232e0 <lock_release>
c0023e98:	83 c4 10             	add    $0x10,%esp
  return b;
c0023e9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c0023e9e:	c9                   	leave  
c0023e9f:	c3                   	ret    

c0023ea0 <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c0023ea0:	55                   	push   %ebp
c0023ea1:	89 e5                	mov    %esp,%ebp
c0023ea3:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c0023ea6:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ea9:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023ead:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c0023eb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023eb3:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023eb6:	72 08                	jb     c0023ec0 <calloc+0x20>
c0023eb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ebb:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023ebe:	73 07                	jae    c0023ec7 <calloc+0x27>
    return NULL;
c0023ec0:	b8 00 00 00 00       	mov    $0x0,%eax
c0023ec5:	eb 2d                	jmp    c0023ef4 <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c0023ec7:	83 ec 0c             	sub    $0xc,%esp
c0023eca:	ff 75 f4             	pushl  -0xc(%ebp)
c0023ecd:	e8 f3 fd ff ff       	call   c0023cc5 <malloc>
c0023ed2:	83 c4 10             	add    $0x10,%esp
c0023ed5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c0023ed8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023edc:	74 13                	je     c0023ef1 <calloc+0x51>
    memset (p, 0, size);
c0023ede:	83 ec 04             	sub    $0x4,%esp
c0023ee1:	ff 75 f4             	pushl  -0xc(%ebp)
c0023ee4:	6a 00                	push   $0x0
c0023ee6:	ff 75 f0             	pushl  -0x10(%ebp)
c0023ee9:	e8 3c 54 00 00       	call   c002932a <memset>
c0023eee:	83 c4 10             	add    $0x10,%esp

  return p;
c0023ef1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0023ef4:	c9                   	leave  
c0023ef5:	c3                   	ret    

c0023ef6 <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c0023ef6:	55                   	push   %ebp
c0023ef7:	89 e5                	mov    %esp,%ebp
c0023ef9:	53                   	push   %ebx
c0023efa:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c0023efd:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f00:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c0023f03:	83 ec 0c             	sub    $0xc,%esp
c0023f06:	ff 75 f4             	pushl  -0xc(%ebp)
c0023f09:	e8 02 02 00 00       	call   c0024110 <block_to_arena>
c0023f0e:	83 c4 10             	add    $0x10,%esp
c0023f11:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c0023f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023f17:	8b 40 04             	mov    0x4(%eax),%eax
c0023f1a:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023f1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0023f21:	74 07                	je     c0023f2a <block_size+0x34>
c0023f23:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023f26:	8b 00                	mov    (%eax),%eax
c0023f28:	eb 1d                	jmp    c0023f47 <block_size+0x51>
c0023f2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023f2d:	8b 40 08             	mov    0x8(%eax),%eax
c0023f30:	c1 e0 0c             	shl    $0xc,%eax
c0023f33:	89 c3                	mov    %eax,%ebx
c0023f35:	83 ec 0c             	sub    $0xc,%esp
c0023f38:	ff 75 08             	pushl  0x8(%ebp)
c0023f3b:	e8 b0 fc ff ff       	call   c0023bf0 <pg_ofs>
c0023f40:	83 c4 10             	add    $0x10,%esp
c0023f43:	29 c3                	sub    %eax,%ebx
c0023f45:	89 d8                	mov    %ebx,%eax
}
c0023f47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023f4a:	c9                   	leave  
c0023f4b:	c3                   	ret    

c0023f4c <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c0023f4c:	55                   	push   %ebp
c0023f4d:	89 e5                	mov    %esp,%ebp
c0023f4f:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c0023f52:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023f56:	75 15                	jne    c0023f6d <realloc+0x21>
    {
      free (old_block);
c0023f58:	83 ec 0c             	sub    $0xc,%esp
c0023f5b:	ff 75 08             	pushl  0x8(%ebp)
c0023f5e:	e8 6e 00 00 00       	call   c0023fd1 <free>
c0023f63:	83 c4 10             	add    $0x10,%esp
      return NULL;
c0023f66:	b8 00 00 00 00       	mov    $0x0,%eax
c0023f6b:	eb 62                	jmp    c0023fcf <realloc+0x83>
    }
  else 
    {
      void *new_block = malloc (new_size);
c0023f6d:	83 ec 0c             	sub    $0xc,%esp
c0023f70:	ff 75 0c             	pushl  0xc(%ebp)
c0023f73:	e8 4d fd ff ff       	call   c0023cc5 <malloc>
c0023f78:	83 c4 10             	add    $0x10,%esp
c0023f7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c0023f7e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023f82:	74 48                	je     c0023fcc <realloc+0x80>
c0023f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023f88:	74 42                	je     c0023fcc <realloc+0x80>
        {
          size_t old_size = block_size (old_block);
c0023f8a:	83 ec 0c             	sub    $0xc,%esp
c0023f8d:	ff 75 08             	pushl  0x8(%ebp)
c0023f90:	e8 61 ff ff ff       	call   c0023ef6 <block_size>
c0023f95:	83 c4 10             	add    $0x10,%esp
c0023f98:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023f9b:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023f9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023fa1:	39 d0                	cmp    %edx,%eax
c0023fa3:	76 02                	jbe    c0023fa7 <realloc+0x5b>
c0023fa5:	89 d0                	mov    %edx,%eax
c0023fa7:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c0023faa:	83 ec 04             	sub    $0x4,%esp
c0023fad:	ff 75 ec             	pushl  -0x14(%ebp)
c0023fb0:	ff 75 08             	pushl  0x8(%ebp)
c0023fb3:	ff 75 f4             	pushl  -0xc(%ebp)
c0023fb6:	e8 95 4d 00 00       	call   c0028d50 <memcpy>
c0023fbb:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0023fbe:	83 ec 0c             	sub    $0xc,%esp
c0023fc1:	ff 75 08             	pushl  0x8(%ebp)
c0023fc4:	e8 08 00 00 00       	call   c0023fd1 <free>
c0023fc9:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0023fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0023fcf:	c9                   	leave  
c0023fd0:	c3                   	ret    

c0023fd1 <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0023fd1:	55                   	push   %ebp
c0023fd2:	89 e5                	mov    %esp,%ebp
c0023fd4:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c0023fd7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023fdb:	0f 84 2d 01 00 00    	je     c002410e <free+0x13d>
    {
      struct block *b = p;
c0023fe1:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fe4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c0023fe7:	83 ec 0c             	sub    $0xc,%esp
c0023fea:	ff 75 f0             	pushl  -0x10(%ebp)
c0023fed:	e8 1e 01 00 00       	call   c0024110 <block_to_arena>
c0023ff2:	83 c4 10             	add    $0x10,%esp
c0023ff5:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c0023ff8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023ffb:	8b 40 04             	mov    0x4(%eax),%eax
c0023ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c0024001:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0024005:	0f 84 ed 00 00 00    	je     c00240f8 <free+0x127>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c002400b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002400e:	8b 00                	mov    (%eax),%eax
c0024010:	83 ec 04             	sub    $0x4,%esp
c0024013:	50                   	push   %eax
c0024014:	68 cc 00 00 00       	push   $0xcc
c0024019:	ff 75 f0             	pushl  -0x10(%ebp)
c002401c:	e8 09 53 00 00       	call   c002932a <memset>
c0024021:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c0024024:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024027:	83 c0 18             	add    $0x18,%eax
c002402a:	83 ec 0c             	sub    $0xc,%esp
c002402d:	50                   	push   %eax
c002402e:	e8 7c f0 ff ff       	call   c00230af <lock_acquire>
c0024033:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c0024036:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024039:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002403c:	83 c2 08             	add    $0x8,%edx
c002403f:	83 ec 08             	sub    $0x8,%esp
c0024042:	50                   	push   %eax
c0024043:	52                   	push   %edx
c0024044:	e8 04 66 00 00       	call   c002a64d <list_push_front>
c0024049:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c002404c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002404f:	8b 40 08             	mov    0x8(%eax),%eax
c0024052:	8d 50 01             	lea    0x1(%eax),%edx
c0024055:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024058:	89 50 08             	mov    %edx,0x8(%eax)
c002405b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002405e:	8b 50 08             	mov    0x8(%eax),%edx
c0024061:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024064:	8b 40 04             	mov    0x4(%eax),%eax
c0024067:	39 c2                	cmp    %eax,%edx
c0024069:	72 79                	jb     c00240e4 <free+0x113>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c002406b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002406e:	8b 50 08             	mov    0x8(%eax),%edx
c0024071:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024074:	8b 40 04             	mov    0x4(%eax),%eax
c0024077:	39 c2                	cmp    %eax,%edx
c0024079:	74 21                	je     c002409c <free+0xcb>
c002407b:	83 ec 0c             	sub    $0xc,%esp
c002407e:	68 d0 fd 02 c0       	push   $0xc002fdd0
c0024083:	68 a1 fd 02 c0       	push   $0xc002fda1
c0024088:	68 b8 fe 02 c0       	push   $0xc002feb8
c002408d:	68 f6 00 00 00       	push   $0xf6
c0024092:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024097:	e8 86 5f 00 00       	call   c002a022 <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c002409c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00240a3:	eb 26                	jmp    c00240cb <free+0xfa>
                {
                  struct block *b = arena_to_block (a, i);
c00240a5:	83 ec 08             	sub    $0x8,%esp
c00240a8:	ff 75 f4             	pushl  -0xc(%ebp)
c00240ab:	ff 75 ec             	pushl  -0x14(%ebp)
c00240ae:	e8 5b 01 00 00       	call   c002420e <arena_to_block>
c00240b3:	83 c4 10             	add    $0x10,%esp
c00240b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c00240b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00240bc:	83 ec 0c             	sub    $0xc,%esp
c00240bf:	50                   	push   %eax
c00240c0:	e8 d4 65 00 00       	call   c002a699 <list_remove>
c00240c5:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < d->blocks_per_arena; i++) 
c00240c8:	ff 45 f4             	incl   -0xc(%ebp)
c00240cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00240ce:	8b 40 04             	mov    0x4(%eax),%eax
c00240d1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00240d4:	77 cf                	ja     c00240a5 <free+0xd4>
                }
              palloc_free_page (a);
c00240d6:	83 ec 0c             	sub    $0xc,%esp
c00240d9:	ff 75 ec             	pushl  -0x14(%ebp)
c00240dc:	e8 ec f9 ff ff       	call   c0023acd <palloc_free_page>
c00240e1:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c00240e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00240e7:	83 c0 18             	add    $0x18,%eax
c00240ea:	83 ec 0c             	sub    $0xc,%esp
c00240ed:	50                   	push   %eax
c00240ee:	e8 ed f1 ff ff       	call   c00232e0 <lock_release>
c00240f3:	83 c4 10             	add    $0x10,%esp
c00240f6:	eb 16                	jmp    c002410e <free+0x13d>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c00240f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00240fb:	8b 40 08             	mov    0x8(%eax),%eax
c00240fe:	83 ec 08             	sub    $0x8,%esp
c0024101:	50                   	push   %eax
c0024102:	ff 75 ec             	pushl  -0x14(%ebp)
c0024105:	e8 83 f8 ff ff       	call   c002398d <palloc_free_multiple>
c002410a:	83 c4 10             	add    $0x10,%esp
          return;
c002410d:	90                   	nop
        }
    }
}
c002410e:	c9                   	leave  
c002410f:	c3                   	ret    

c0024110 <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c0024110:	55                   	push   %ebp
c0024111:	89 e5                	mov    %esp,%ebp
c0024113:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c0024116:	ff 75 08             	pushl  0x8(%ebp)
c0024119:	e8 df fa ff ff       	call   c0023bfd <pg_round_down>
c002411e:	83 c4 04             	add    $0x4,%esp
c0024121:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c0024124:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024128:	75 21                	jne    c002414b <block_to_arena+0x3b>
c002412a:	83 ec 0c             	sub    $0xc,%esp
c002412d:	68 f3 fd 02 c0       	push   $0xc002fdf3
c0024132:	68 a1 fd 02 c0       	push   $0xc002fda1
c0024137:	68 c0 fe 02 c0       	push   $0xc002fec0
c002413c:	68 11 01 00 00       	push   $0x111
c0024141:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024146:	e8 d7 5e 00 00       	call   c002a022 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c002414b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002414e:	8b 00                	mov    (%eax),%eax
c0024150:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0024155:	74 21                	je     c0024178 <block_to_arena+0x68>
c0024157:	83 ec 0c             	sub    $0xc,%esp
c002415a:	68 fd fd 02 c0       	push   $0xc002fdfd
c002415f:	68 a1 fd 02 c0       	push   $0xc002fda1
c0024164:	68 c0 fe 02 c0       	push   $0xc002fec0
c0024169:	68 12 01 00 00       	push   $0x112
c002416e:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024173:	e8 aa 5e 00 00       	call   c002a022 <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c0024178:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002417b:	8b 40 04             	mov    0x4(%eax),%eax
c002417e:	85 c0                	test   %eax,%eax
c0024180:	74 49                	je     c00241cb <block_to_arena+0xbb>
c0024182:	83 ec 0c             	sub    $0xc,%esp
c0024185:	ff 75 08             	pushl  0x8(%ebp)
c0024188:	e8 63 fa ff ff       	call   c0023bf0 <pg_ofs>
c002418d:	83 c4 10             	add    $0x10,%esp
c0024190:	8d 50 f4             	lea    -0xc(%eax),%edx
c0024193:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024196:	8b 40 04             	mov    0x4(%eax),%eax
c0024199:	8b 08                	mov    (%eax),%ecx
c002419b:	89 d0                	mov    %edx,%eax
c002419d:	ba 00 00 00 00       	mov    $0x0,%edx
c00241a2:	f7 f1                	div    %ecx
c00241a4:	89 d0                	mov    %edx,%eax
c00241a6:	85 c0                	test   %eax,%eax
c00241a8:	74 21                	je     c00241cb <block_to_arena+0xbb>
c00241aa:	83 ec 0c             	sub    $0xc,%esp
c00241ad:	68 18 fe 02 c0       	push   $0xc002fe18
c00241b2:	68 a1 fd 02 c0       	push   $0xc002fda1
c00241b7:	68 c0 fe 02 c0       	push   $0xc002fec0
c00241bc:	68 16 01 00 00       	push   $0x116
c00241c1:	68 b8 fd 02 c0       	push   $0xc002fdb8
c00241c6:	e8 57 5e 00 00       	call   c002a022 <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c00241cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00241ce:	8b 40 04             	mov    0x4(%eax),%eax
c00241d1:	85 c0                	test   %eax,%eax
c00241d3:	75 34                	jne    c0024209 <block_to_arena+0xf9>
c00241d5:	83 ec 0c             	sub    $0xc,%esp
c00241d8:	ff 75 08             	pushl  0x8(%ebp)
c00241db:	e8 10 fa ff ff       	call   c0023bf0 <pg_ofs>
c00241e0:	83 c4 10             	add    $0x10,%esp
c00241e3:	83 f8 0c             	cmp    $0xc,%eax
c00241e6:	74 21                	je     c0024209 <block_to_arena+0xf9>
c00241e8:	83 ec 0c             	sub    $0xc,%esp
c00241eb:	68 60 fe 02 c0       	push   $0xc002fe60
c00241f0:	68 a1 fd 02 c0       	push   $0xc002fda1
c00241f5:	68 c0 fe 02 c0       	push   $0xc002fec0
c00241fa:	68 17 01 00 00       	push   $0x117
c00241ff:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024204:	e8 19 5e 00 00       	call   c002a022 <debug_panic>

  return a;
c0024209:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002420c:	c9                   	leave  
c002420d:	c3                   	ret    

c002420e <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c002420e:	55                   	push   %ebp
c002420f:	89 e5                	mov    %esp,%ebp
c0024211:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0024214:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024218:	75 21                	jne    c002423b <arena_to_block+0x2d>
c002421a:	83 ec 0c             	sub    $0xc,%esp
c002421d:	68 f3 fd 02 c0       	push   $0xc002fdf3
c0024222:	68 a1 fd 02 c0       	push   $0xc002fda1
c0024227:	68 d0 fe 02 c0       	push   $0xc002fed0
c002422c:	68 20 01 00 00       	push   $0x120
c0024231:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024236:	e8 e7 5d 00 00       	call   c002a022 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c002423b:	8b 45 08             	mov    0x8(%ebp),%eax
c002423e:	8b 00                	mov    (%eax),%eax
c0024240:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0024245:	74 21                	je     c0024268 <arena_to_block+0x5a>
c0024247:	83 ec 0c             	sub    $0xc,%esp
c002424a:	68 fd fd 02 c0       	push   $0xc002fdfd
c002424f:	68 a1 fd 02 c0       	push   $0xc002fda1
c0024254:	68 d0 fe 02 c0       	push   $0xc002fed0
c0024259:	68 21 01 00 00       	push   $0x121
c002425e:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024263:	e8 ba 5d 00 00       	call   c002a022 <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0024268:	8b 45 08             	mov    0x8(%ebp),%eax
c002426b:	8b 40 04             	mov    0x4(%eax),%eax
c002426e:	8b 40 04             	mov    0x4(%eax),%eax
c0024271:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024274:	77 21                	ja     c0024297 <arena_to_block+0x89>
c0024276:	83 ec 0c             	sub    $0xc,%esp
c0024279:	68 8c fe 02 c0       	push   $0xc002fe8c
c002427e:	68 a1 fd 02 c0       	push   $0xc002fda1
c0024283:	68 d0 fe 02 c0       	push   $0xc002fed0
c0024288:	68 22 01 00 00       	push   $0x122
c002428d:	68 b8 fd 02 c0       	push   $0xc002fdb8
c0024292:	e8 8b 5d 00 00       	call   c002a022 <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0024297:	8b 45 08             	mov    0x8(%ebp),%eax
c002429a:	8b 40 04             	mov    0x4(%eax),%eax
c002429d:	8b 00                	mov    (%eax),%eax
c002429f:	0f af 45 0c          	imul   0xc(%ebp),%eax
c00242a3:	8d 50 0c             	lea    0xc(%eax),%edx
  return (struct block *) ((uint8_t *) a
c00242a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00242a9:	01 d0                	add    %edx,%eax
}
c00242ab:	c9                   	leave  
c00242ac:	c3                   	ret    

c00242ad <outb>:
{
c00242ad:	55                   	push   %ebp
c00242ae:	89 e5                	mov    %esp,%ebp
c00242b0:	83 ec 08             	sub    $0x8,%esp
c00242b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00242b6:	8b 55 0c             	mov    0xc(%ebp),%edx
c00242b9:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00242bd:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00242c0:	8a 45 f8             	mov    -0x8(%ebp),%al
c00242c3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00242c6:	ee                   	out    %al,(%dx)
}
c00242c7:	90                   	nop
c00242c8:	c9                   	leave  
c00242c9:	c3                   	ret    

c00242ca <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c00242ca:	55                   	push   %ebp
c00242cb:	89 e5                	mov    %esp,%ebp
c00242cd:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c00242d0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00242d4:	74 24                	je     c00242fa <pit_configure_channel+0x30>
c00242d6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00242da:	74 1e                	je     c00242fa <pit_configure_channel+0x30>
c00242dc:	83 ec 0c             	sub    $0xc,%esp
c00242df:	68 e0 fe 02 c0       	push   $0xc002fee0
c00242e4:	68 fd fe 02 c0       	push   $0xc002fefd
c00242e9:	68 40 ff 02 c0       	push   $0xc002ff40
c00242ee:	6a 33                	push   $0x33
c00242f0:	68 14 ff 02 c0       	push   $0xc002ff14
c00242f5:	e8 28 5d 00 00       	call   c002a022 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c00242fa:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c00242fe:	74 24                	je     c0024324 <pit_configure_channel+0x5a>
c0024300:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0024304:	74 1e                	je     c0024324 <pit_configure_channel+0x5a>
c0024306:	83 ec 0c             	sub    $0xc,%esp
c0024309:	68 28 ff 02 c0       	push   $0xc002ff28
c002430e:	68 fd fe 02 c0       	push   $0xc002fefd
c0024313:	68 40 ff 02 c0       	push   $0xc002ff40
c0024318:	6a 34                	push   $0x34
c002431a:	68 14 ff 02 c0       	push   $0xc002ff14
c002431f:	e8 fe 5c 00 00       	call   c002a022 <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0024324:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0024328:	7f 08                	jg     c0024332 <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c002432a:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0024330:	eb 2a                	jmp    c002435c <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0024332:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0024339:	7e 08                	jle    c0024343 <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c002433b:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0024341:	eb 19                	jmp    c002435c <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0024343:	8b 45 10             	mov    0x10(%ebp),%eax
c0024346:	89 c2                	mov    %eax,%edx
c0024348:	c1 ea 1f             	shr    $0x1f,%edx
c002434b:	01 d0                	add    %edx,%eax
c002434d:	d1 f8                	sar    %eax
c002434f:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0024354:	99                   	cltd   
c0024355:	f7 7d 10             	idivl  0x10(%ebp)
c0024358:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c002435c:	e8 1c d6 ff ff       	call   c002197d <intr_disable>
c0024361:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0024364:	8b 45 08             	mov    0x8(%ebp),%eax
c0024367:	c1 e0 06             	shl    $0x6,%eax
c002436a:	83 c8 30             	or     $0x30,%eax
c002436d:	88 c2                	mov    %al,%dl
c002436f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024372:	01 c0                	add    %eax,%eax
c0024374:	09 d0                	or     %edx,%eax
c0024376:	0f b6 c0             	movzbl %al,%eax
c0024379:	83 ec 08             	sub    $0x8,%esp
c002437c:	50                   	push   %eax
c002437d:	6a 43                	push   $0x43
c002437f:	e8 29 ff ff ff       	call   c00242ad <outb>
c0024384:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0024387:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c002438b:	0f b6 d0             	movzbl %al,%edx
c002438e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024391:	83 c0 40             	add    $0x40,%eax
c0024394:	0f b7 c0             	movzwl %ax,%eax
c0024397:	83 ec 08             	sub    $0x8,%esp
c002439a:	52                   	push   %edx
c002439b:	50                   	push   %eax
c002439c:	e8 0c ff ff ff       	call   c00242ad <outb>
c00243a1:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c00243a4:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c00243a8:	66 c1 e8 08          	shr    $0x8,%ax
c00243ac:	0f b6 d0             	movzbl %al,%edx
c00243af:	8b 45 08             	mov    0x8(%ebp),%eax
c00243b2:	83 c0 40             	add    $0x40,%eax
c00243b5:	0f b7 c0             	movzwl %ax,%eax
c00243b8:	83 ec 08             	sub    $0x8,%esp
c00243bb:	52                   	push   %edx
c00243bc:	50                   	push   %eax
c00243bd:	e8 eb fe ff ff       	call   c00242ad <outb>
c00243c2:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c00243c5:	83 ec 0c             	sub    $0xc,%esp
c00243c8:	ff 75 f0             	pushl  -0x10(%ebp)
c00243cb:	e8 55 d5 ff ff       	call   c0021925 <intr_set_level>
c00243d0:	83 c4 10             	add    $0x10,%esp
}
c00243d3:	90                   	nop
c00243d4:	c9                   	leave  
c00243d5:	c3                   	ret    

c00243d6 <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c00243d6:	55                   	push   %ebp
c00243d7:	89 e5                	mov    %esp,%ebp
c00243d9:	83 ec 08             	sub    $0x8,%esp
  list_init(&sleepingThreads);
c00243dc:	83 ec 0c             	sub    $0xc,%esp
c00243df:	68 ec 9c 03 c0       	push   $0xc0039cec
c00243e4:	e8 aa 5e 00 00       	call   c002a293 <list_init>
c00243e9:	83 c4 10             	add    $0x10,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c00243ec:	83 ec 04             	sub    $0x4,%esp
c00243ef:	6a 64                	push   $0x64
c00243f1:	6a 02                	push   $0x2
c00243f3:	6a 00                	push   $0x0
c00243f5:	e8 d0 fe ff ff       	call   c00242ca <pit_configure_channel>
c00243fa:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c00243fd:	83 ec 04             	sub    $0x4,%esp
c0024400:	68 58 ff 02 c0       	push   $0xc002ff58
c0024405:	68 5f 47 02 c0       	push   $0xc002475f
c002440a:	6a 20                	push   $0x20
c002440c:	e8 8b d7 ff ff       	call   c0021b9c <intr_register_ext>
c0024411:	83 c4 10             	add    $0x10,%esp
}
c0024414:	90                   	nop
c0024415:	c9                   	leave  
c0024416:	c3                   	ret    

c0024417 <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0024417:	55                   	push   %ebp
c0024418:	89 e5                	mov    %esp,%ebp
c002441a:	53                   	push   %ebx
c002441b:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c002441e:	e8 e5 d4 ff ff       	call   c0021908 <intr_get_level>
c0024423:	83 f8 01             	cmp    $0x1,%eax
c0024426:	74 1e                	je     c0024446 <timer_calibrate+0x2f>
c0024428:	83 ec 0c             	sub    $0xc,%esp
c002442b:	68 63 ff 02 c0       	push   $0xc002ff63
c0024430:	68 80 ff 02 c0       	push   $0xc002ff80
c0024435:	68 10 00 03 c0       	push   $0xc0030010
c002443a:	6a 34                	push   $0x34
c002443c:	68 97 ff 02 c0       	push   $0xc002ff97
c0024441:	e8 dc 5b 00 00       	call   c002a022 <debug_panic>
  printf ("Calibrating timer...  ");
c0024446:	83 ec 0c             	sub    $0xc,%esp
c0024449:	68 ad ff 02 c0       	push   $0xc002ffad
c002444e:	e8 fe 36 00 00       	call   c0027b51 <printf>
c0024453:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0024456:	c7 05 e8 9c 03 c0 00 	movl   $0x400,0xc0039ce8
c002445d:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0024460:	eb 33                	jmp    c0024495 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0024462:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c0024467:	01 c0                	add    %eax,%eax
c0024469:	a3 e8 9c 03 c0       	mov    %eax,0xc0039ce8
      ASSERT (loops_per_tick != 0);
c002446e:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c0024473:	85 c0                	test   %eax,%eax
c0024475:	75 1e                	jne    c0024495 <timer_calibrate+0x7e>
c0024477:	83 ec 0c             	sub    $0xc,%esp
c002447a:	68 c4 ff 02 c0       	push   $0xc002ffc4
c002447f:	68 80 ff 02 c0       	push   $0xc002ff80
c0024484:	68 10 00 03 c0       	push   $0xc0030010
c0024489:	6a 3d                	push   $0x3d
c002448b:	68 97 ff 02 c0       	push   $0xc002ff97
c0024490:	e8 8d 5b 00 00       	call   c002a022 <debug_panic>
  while (!too_many_loops (loops_per_tick << 1)) 
c0024495:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c002449a:	01 c0                	add    %eax,%eax
c002449c:	83 ec 0c             	sub    $0xc,%esp
c002449f:	50                   	push   %eax
c00244a0:	e8 f4 03 00 00       	call   c0024899 <too_many_loops>
c00244a5:	83 c4 10             	add    $0x10,%esp
c00244a8:	83 f0 01             	xor    $0x1,%eax
c00244ab:	84 c0                	test   %al,%al
c00244ad:	75 b3                	jne    c0024462 <timer_calibrate+0x4b>
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c00244af:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c00244b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00244b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00244ba:	d1 e8                	shr    %eax
c00244bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00244bf:	eb 29                	jmp    c00244ea <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c00244c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00244c4:	0b 45 f4             	or     -0xc(%ebp),%eax
c00244c7:	83 ec 0c             	sub    $0xc,%esp
c00244ca:	50                   	push   %eax
c00244cb:	e8 c9 03 00 00       	call   c0024899 <too_many_loops>
c00244d0:	83 c4 10             	add    $0x10,%esp
c00244d3:	83 f0 01             	xor    $0x1,%eax
c00244d6:	84 c0                	test   %al,%al
c00244d8:	74 0d                	je     c00244e7 <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c00244da:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c00244df:	0b 45 f4             	or     -0xc(%ebp),%eax
c00244e2:	a3 e8 9c 03 c0       	mov    %eax,0xc0039ce8
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00244e7:	d1 6d f4             	shrl   -0xc(%ebp)
c00244ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00244ed:	c1 e8 0a             	shr    $0xa,%eax
c00244f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00244f3:	75 cc                	jne    c00244c1 <timer_calibrate+0xaa>

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c00244f5:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c00244fa:	ba 00 00 00 00       	mov    $0x0,%edx
c00244ff:	6b da 64             	imul   $0x64,%edx,%ebx
c0024502:	6b c8 00             	imul   $0x0,%eax,%ecx
c0024505:	01 d9                	add    %ebx,%ecx
c0024507:	bb 64 00 00 00       	mov    $0x64,%ebx
c002450c:	f7 e3                	mul    %ebx
c002450e:	01 d1                	add    %edx,%ecx
c0024510:	89 ca                	mov    %ecx,%edx
c0024512:	83 ec 04             	sub    $0x4,%esp
c0024515:	52                   	push   %edx
c0024516:	50                   	push   %eax
c0024517:	68 d8 ff 02 c0       	push   $0xc002ffd8
c002451c:	e8 30 36 00 00       	call   c0027b51 <printf>
c0024521:	83 c4 10             	add    $0x10,%esp
}
c0024524:	90                   	nop
c0024525:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024528:	c9                   	leave  
c0024529:	c3                   	ret    

c002452a <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c002452a:	55                   	push   %ebp
c002452b:	89 e5                	mov    %esp,%ebp
c002452d:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024530:	e8 48 d4 ff ff       	call   c002197d <intr_disable>
c0024535:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0024538:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c002453d:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c0024543:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0024546:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0024549:	83 ec 0c             	sub    $0xc,%esp
c002454c:	ff 75 f4             	pushl  -0xc(%ebp)
c002454f:	e8 d1 d3 ff ff       	call   c0021925 <intr_set_level>
c0024554:	83 c4 10             	add    $0x10,%esp
  return t;
c0024557:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002455a:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c002455d:	c9                   	leave  
c002455e:	c3                   	ret    

c002455f <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c002455f:	55                   	push   %ebp
c0024560:	89 e5                	mov    %esp,%ebp
c0024562:	83 ec 18             	sub    $0x18,%esp
c0024565:	8b 45 08             	mov    0x8(%ebp),%eax
c0024568:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002456b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002456e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0024571:	e8 b4 ff ff ff       	call   c002452a <timer_ticks>
c0024576:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0024579:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c002457c:	c9                   	leave  
c002457d:	c3                   	ret    

c002457e <timer_sleep>:
      block calling thread && put it to a sleeping queue.
      timer_interrupt check the queue to unblock those no longer need to sleep.
   */
void
timer_sleep (int64_t ticks) 
{
c002457e:	55                   	push   %ebp
c002457f:	89 e5                	mov    %esp,%ebp
c0024581:	53                   	push   %ebx
c0024582:	83 ec 24             	sub    $0x24,%esp
c0024585:	8b 45 08             	mov    0x8(%ebp),%eax
c0024588:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002458b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002458e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (ticks <= 0) return;
c0024591:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0024595:	7f 14                	jg     c00245ab <timer_sleep+0x2d>
c0024597:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002459b:	0f 88 96 00 00 00    	js     c0024637 <timer_sleep+0xb9>
c00245a1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00245a5:	0f 86 8c 00 00 00    	jbe    c0024637 <timer_sleep+0xb9>
  int64_t start = timer_ticks ();
c00245ab:	e8 7a ff ff ff       	call   c002452a <timer_ticks>
c00245b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00245b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_ON);
c00245b6:	e8 4d d3 ff ff       	call   c0021908 <intr_get_level>
c00245bb:	83 f8 01             	cmp    $0x1,%eax
c00245be:	74 1e                	je     c00245de <timer_sleep+0x60>
c00245c0:	83 ec 0c             	sub    $0xc,%esp
c00245c3:	68 63 ff 02 c0       	push   $0xc002ff63
c00245c8:	68 80 ff 02 c0       	push   $0xc002ff80
c00245cd:	68 20 00 03 c0       	push   $0xc0030020
c00245d2:	6a 69                	push   $0x69
c00245d4:	68 97 ff 02 c0       	push   $0xc002ff97
c00245d9:	e8 44 5a 00 00       	call   c002a022 <debug_panic>

  enum intr_level old_level = intr_disable ();
c00245de:	e8 9a d3 ff ff       	call   c002197d <intr_disable>
c00245e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread* callingThread = thread_current();
c00245e6:	e8 a0 c6 ff ff       	call   c0020c8b <thread_current>
c00245eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  callingThread->wake_tick = start + ticks;
c00245ee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00245f1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c00245f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00245f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00245fa:	01 c8                	add    %ecx,%eax
c00245fc:	11 da                	adc    %ebx,%edx
c00245fe:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0024601:	89 41 30             	mov    %eax,0x30(%ecx)
c0024604:	89 51 34             	mov    %edx,0x34(%ecx)
  list_insert_ordered(&sleepingThreads, &callingThread->sleepelem, sleep_thread_cmp, NULL);
c0024607:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002460a:	83 c0 38             	add    $0x38,%eax
c002460d:	6a 00                	push   $0x0
c002460f:	68 32 14 02 c0       	push   $0xc0021432
c0024614:	50                   	push   %eax
c0024615:	68 ec 9c 03 c0       	push   $0xc0039cec
c002461a:	e8 14 67 00 00       	call   c002ad33 <list_insert_ordered>
c002461f:	83 c4 10             	add    $0x10,%esp
  thread_block();
c0024622:	e8 40 c5 ff ff       	call   c0020b67 <thread_block>
  intr_set_level(old_level);
c0024627:	83 ec 0c             	sub    $0xc,%esp
c002462a:	ff 75 ec             	pushl  -0x14(%ebp)
c002462d:	e8 f3 d2 ff ff       	call   c0021925 <intr_set_level>
c0024632:	83 c4 10             	add    $0x10,%esp
c0024635:	eb 01                	jmp    c0024638 <timer_sleep+0xba>
  if (ticks <= 0) return;
c0024637:	90                   	nop
}
c0024638:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002463b:	c9                   	leave  
c002463c:	c3                   	ret    

c002463d <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c002463d:	55                   	push   %ebp
c002463e:	89 e5                	mov    %esp,%ebp
c0024640:	83 ec 18             	sub    $0x18,%esp
c0024643:	8b 45 08             	mov    0x8(%ebp),%eax
c0024646:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024649:	8b 45 0c             	mov    0xc(%ebp),%eax
c002464c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c002464f:	83 ec 04             	sub    $0x4,%esp
c0024652:	68 e8 03 00 00       	push   $0x3e8
c0024657:	ff 75 f4             	pushl  -0xc(%ebp)
c002465a:	ff 75 f0             	pushl  -0x10(%ebp)
c002465d:	e8 09 03 00 00       	call   c002496b <real_time_sleep>
c0024662:	83 c4 10             	add    $0x10,%esp
}
c0024665:	90                   	nop
c0024666:	c9                   	leave  
c0024667:	c3                   	ret    

c0024668 <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0024668:	55                   	push   %ebp
c0024669:	89 e5                	mov    %esp,%ebp
c002466b:	83 ec 18             	sub    $0x18,%esp
c002466e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024671:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024674:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024677:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c002467a:	83 ec 04             	sub    $0x4,%esp
c002467d:	68 40 42 0f 00       	push   $0xf4240
c0024682:	ff 75 f4             	pushl  -0xc(%ebp)
c0024685:	ff 75 f0             	pushl  -0x10(%ebp)
c0024688:	e8 de 02 00 00       	call   c002496b <real_time_sleep>
c002468d:	83 c4 10             	add    $0x10,%esp
}
c0024690:	90                   	nop
c0024691:	c9                   	leave  
c0024692:	c3                   	ret    

c0024693 <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0024693:	55                   	push   %ebp
c0024694:	89 e5                	mov    %esp,%ebp
c0024696:	83 ec 18             	sub    $0x18,%esp
c0024699:	8b 45 08             	mov    0x8(%ebp),%eax
c002469c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002469f:	8b 45 0c             	mov    0xc(%ebp),%eax
c00246a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c00246a5:	83 ec 04             	sub    $0x4,%esp
c00246a8:	68 00 ca 9a 3b       	push   $0x3b9aca00
c00246ad:	ff 75 f4             	pushl  -0xc(%ebp)
c00246b0:	ff 75 f0             	pushl  -0x10(%ebp)
c00246b3:	e8 b3 02 00 00       	call   c002496b <real_time_sleep>
c00246b8:	83 c4 10             	add    $0x10,%esp
}
c00246bb:	90                   	nop
c00246bc:	c9                   	leave  
c00246bd:	c3                   	ret    

c00246be <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c00246be:	55                   	push   %ebp
c00246bf:	89 e5                	mov    %esp,%ebp
c00246c1:	83 ec 18             	sub    $0x18,%esp
c00246c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00246c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00246ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c00246cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c00246d0:	83 ec 04             	sub    $0x4,%esp
c00246d3:	68 e8 03 00 00       	push   $0x3e8
c00246d8:	ff 75 f4             	pushl  -0xc(%ebp)
c00246db:	ff 75 f0             	pushl  -0x10(%ebp)
c00246de:	e8 3a 03 00 00       	call   c0024a1d <real_time_delay>
c00246e3:	83 c4 10             	add    $0x10,%esp
}
c00246e6:	90                   	nop
c00246e7:	c9                   	leave  
c00246e8:	c3                   	ret    

c00246e9 <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c00246e9:	55                   	push   %ebp
c00246ea:	89 e5                	mov    %esp,%ebp
c00246ec:	83 ec 18             	sub    $0x18,%esp
c00246ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00246f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00246f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00246f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c00246fb:	83 ec 04             	sub    $0x4,%esp
c00246fe:	68 40 42 0f 00       	push   $0xf4240
c0024703:	ff 75 f4             	pushl  -0xc(%ebp)
c0024706:	ff 75 f0             	pushl  -0x10(%ebp)
c0024709:	e8 0f 03 00 00       	call   c0024a1d <real_time_delay>
c002470e:	83 c4 10             	add    $0x10,%esp
}
c0024711:	90                   	nop
c0024712:	c9                   	leave  
c0024713:	c3                   	ret    

c0024714 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c0024714:	55                   	push   %ebp
c0024715:	89 e5                	mov    %esp,%ebp
c0024717:	83 ec 18             	sub    $0x18,%esp
c002471a:	8b 45 08             	mov    0x8(%ebp),%eax
c002471d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024720:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024723:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c0024726:	83 ec 04             	sub    $0x4,%esp
c0024729:	68 00 ca 9a 3b       	push   $0x3b9aca00
c002472e:	ff 75 f4             	pushl  -0xc(%ebp)
c0024731:	ff 75 f0             	pushl  -0x10(%ebp)
c0024734:	e8 e4 02 00 00       	call   c0024a1d <real_time_delay>
c0024739:	83 c4 10             	add    $0x10,%esp
}
c002473c:	90                   	nop
c002473d:	c9                   	leave  
c002473e:	c3                   	ret    

c002473f <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c002473f:	55                   	push   %ebp
c0024740:	89 e5                	mov    %esp,%ebp
c0024742:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0024745:	e8 e0 fd ff ff       	call   c002452a <timer_ticks>
c002474a:	83 ec 04             	sub    $0x4,%esp
c002474d:	52                   	push   %edx
c002474e:	50                   	push   %eax
c002474f:	68 e8 ff 02 c0       	push   $0xc002ffe8
c0024754:	e8 f8 33 00 00       	call   c0027b51 <printf>
c0024759:	83 c4 10             	add    $0x10,%esp
}
c002475c:	90                   	nop
c002475d:	c9                   	leave  
c002475e:	c3                   	ret    

c002475f <timer_interrupt>:


/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c002475f:	55                   	push   %ebp
c0024760:	89 e5                	mov    %esp,%ebp
c0024762:	56                   	push   %esi
c0024763:	53                   	push   %ebx
c0024764:	83 ec 20             	sub    $0x20,%esp
  ticks++;
c0024767:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c002476c:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c0024772:	83 c0 01             	add    $0x1,%eax
c0024775:	83 d2 00             	adc    $0x0,%edx
c0024778:	a3 e0 9c 03 c0       	mov    %eax,0xc0039ce0
c002477d:	89 15 e4 9c 03 c0    	mov    %edx,0xc0039ce4
  thread_tick ();
c0024783:	e8 1a c2 ff ff       	call   c00209a2 <thread_tick>

  if (thread_mlfqs) {
c0024788:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002478d:	84 c0                	test   %al,%al
c002478f:	0f 84 e2 00 00 00    	je     c0024877 <timer_interrupt+0x118>
    thread_update_recent_cpu_one();
c0024795:	e8 45 d0 ff ff       	call   c00217df <thread_update_recent_cpu_one>
    if (ticks % 4 == 0)
c002479a:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c002479f:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c00247a5:	89 c1                	mov    %eax,%ecx
c00247a7:	83 e1 03             	and    $0x3,%ecx
c00247aa:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c00247ad:	89 d0                	mov    %edx,%eax
c00247af:	83 e0 00             	and    $0x0,%eax
c00247b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00247b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00247b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00247bb:	89 c1                	mov    %eax,%ecx
c00247bd:	80 f5 00             	xor    $0x0,%ch
c00247c0:	89 4d d8             	mov    %ecx,-0x28(%ebp)
c00247c3:	89 d0                	mov    %edx,%eax
c00247c5:	80 f4 00             	xor    $0x0,%ah
c00247c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
c00247cb:	8b 55 d8             	mov    -0x28(%ebp),%edx
c00247ce:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c00247d1:	89 c8                	mov    %ecx,%eax
c00247d3:	09 d0                	or     %edx,%eax
c00247d5:	85 c0                	test   %eax,%eax
c00247d7:	75 11                	jne    c00247ea <timer_interrupt+0x8b>
      thread_update_priority_mlfqs(thread_current());
c00247d9:	e8 ad c4 ff ff       	call   c0020c8b <thread_current>
c00247de:	83 ec 0c             	sub    $0xc,%esp
c00247e1:	50                   	push   %eax
c00247e2:	e8 31 d0 ff ff       	call   c0021818 <thread_update_priority_mlfqs>
c00247e7:	83 c4 10             	add    $0x10,%esp
    if (ticks % TIMER_FREQ == 0)
c00247ea:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c00247ef:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c00247f5:	6a 00                	push   $0x0
c00247f7:	6a 64                	push   $0x64
c00247f9:	52                   	push   %edx
c00247fa:	50                   	push   %eax
c00247fb:	e8 4a 51 00 00       	call   c002994a <__moddi3>
c0024800:	83 c4 10             	add    $0x10,%esp
c0024803:	89 c1                	mov    %eax,%ecx
c0024805:	80 f5 00             	xor    $0x0,%ch
c0024808:	89 cb                	mov    %ecx,%ebx
c002480a:	89 d0                	mov    %edx,%eax
c002480c:	80 f4 00             	xor    $0x0,%ah
c002480f:	89 c6                	mov    %eax,%esi
c0024811:	89 f0                	mov    %esi,%eax
c0024813:	09 d8                	or     %ebx,%eax
c0024815:	85 c0                	test   %eax,%eax
c0024817:	75 5e                	jne    c0024877 <timer_interrupt+0x118>
      thread_update_recent_cpu_and_load_avg();
c0024819:	e8 4a ce ff ff       	call   c0021668 <thread_update_recent_cpu_and_load_avg>
  }
  
  while (!list_empty(&sleepingThreads)) {
c002481e:	eb 57                	jmp    c0024877 <timer_interrupt+0x118>
    struct thread* t = list_entry (list_front (&sleepingThreads), struct thread, sleepelem);
c0024820:	83 ec 0c             	sub    $0xc,%esp
c0024823:	68 ec 9c 03 c0       	push   $0xc0039cec
c0024828:	e8 19 5f 00 00       	call   c002a746 <list_front>
c002482d:	83 c4 10             	add    $0x10,%esp
c0024830:	83 c0 04             	add    $0x4,%eax
c0024833:	83 e8 3c             	sub    $0x3c,%eax
c0024836:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (t->wake_tick <= ticks)
c0024839:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002483c:	8b 48 30             	mov    0x30(%eax),%ecx
c002483f:	8b 58 34             	mov    0x34(%eax),%ebx
c0024842:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c0024847:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c002484d:	39 d3                	cmp    %edx,%ebx
c002484f:	7f 3f                	jg     c0024890 <timer_interrupt+0x131>
c0024851:	39 d3                	cmp    %edx,%ebx
c0024853:	7c 04                	jl     c0024859 <timer_interrupt+0xfa>
c0024855:	39 c1                	cmp    %eax,%ecx
c0024857:	77 37                	ja     c0024890 <timer_interrupt+0x131>
      {
        thread_unblock(t);
c0024859:	83 ec 0c             	sub    $0xc,%esp
c002485c:	ff 75 f4             	pushl  -0xc(%ebp)
c002485f:	e8 74 c3 ff ff       	call   c0020bd8 <thread_unblock>
c0024864:	83 c4 10             	add    $0x10,%esp
        list_pop_front(&sleepingThreads);
c0024867:	83 ec 0c             	sub    $0xc,%esp
c002486a:	68 ec 9c 03 c0       	push   $0xc0039cec
c002486f:	e8 7e 5e 00 00       	call   c002a6f2 <list_pop_front>
c0024874:	83 c4 10             	add    $0x10,%esp
  while (!list_empty(&sleepingThreads)) {
c0024877:	83 ec 0c             	sub    $0xc,%esp
c002487a:	68 ec 9c 03 c0       	push   $0xc0039cec
c002487f:	e8 96 5f 00 00       	call   c002a81a <list_empty>
c0024884:	83 c4 10             	add    $0x10,%esp
c0024887:	83 f0 01             	xor    $0x1,%eax
c002488a:	84 c0                	test   %al,%al
c002488c:	75 92                	jne    c0024820 <timer_interrupt+0xc1>
      }
    else
      break;
  }
  
}
c002488e:	eb 01                	jmp    c0024891 <timer_interrupt+0x132>
      break;
c0024890:	90                   	nop
}
c0024891:	90                   	nop
c0024892:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024895:	5b                   	pop    %ebx
c0024896:	5e                   	pop    %esi
c0024897:	5d                   	pop    %ebp
c0024898:	c3                   	ret    

c0024899 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c0024899:	55                   	push   %ebp
c002489a:	89 e5                	mov    %esp,%ebp
c002489c:	56                   	push   %esi
c002489d:	53                   	push   %ebx
c002489e:	83 ec 20             	sub    $0x20,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c00248a1:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c00248a6:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c00248ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00248af:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c00248b2:	eb 00                	jmp    c00248b4 <too_many_loops+0x1b>
c00248b4:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c00248b9:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c00248bf:	89 c1                	mov    %eax,%ecx
c00248c1:	33 4d f0             	xor    -0x10(%ebp),%ecx
c00248c4:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c00248c7:	89 d0                	mov    %edx,%eax
c00248c9:	33 45 f4             	xor    -0xc(%ebp),%eax
c00248cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00248cf:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00248d2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c00248d5:	89 c8                	mov    %ecx,%eax
c00248d7:	09 d0                	or     %edx,%eax
c00248d9:	85 c0                	test   %eax,%eax
c00248db:	74 d7                	je     c00248b4 <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c00248dd:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c00248e2:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c00248e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00248eb:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c00248ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00248f1:	ba 00 00 00 00       	mov    $0x0,%edx
c00248f6:	83 ec 08             	sub    $0x8,%esp
c00248f9:	52                   	push   %edx
c00248fa:	50                   	push   %eax
c00248fb:	e8 2c 00 00 00       	call   c002492c <busy_wait>
c0024900:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0024903:	a1 e0 9c 03 c0       	mov    0xc0039ce0,%eax
c0024908:	8b 15 e4 9c 03 c0    	mov    0xc0039ce4,%edx
c002490e:	89 c1                	mov    %eax,%ecx
c0024910:	33 4d f0             	xor    -0x10(%ebp),%ecx
c0024913:	89 cb                	mov    %ecx,%ebx
c0024915:	89 d0                	mov    %edx,%eax
c0024917:	33 45 f4             	xor    -0xc(%ebp),%eax
c002491a:	89 c6                	mov    %eax,%esi
c002491c:	89 d8                	mov    %ebx,%eax
c002491e:	09 f0                	or     %esi,%eax
c0024920:	85 c0                	test   %eax,%eax
c0024922:	0f 95 c0             	setne  %al
}
c0024925:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024928:	5b                   	pop    %ebx
c0024929:	5e                   	pop    %esi
c002492a:	5d                   	pop    %ebp
c002492b:	c3                   	ret    

c002492c <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c002492c:	55                   	push   %ebp
c002492d:	89 e5                	mov    %esp,%ebp
c002492f:	53                   	push   %ebx
c0024930:	83 ec 0c             	sub    $0xc,%esp
c0024933:	8b 45 08             	mov    0x8(%ebp),%eax
c0024936:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024939:	8b 45 0c             	mov    0xc(%ebp),%eax
c002493c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c002493f:	eb 00                	jmp    c0024941 <busy_wait+0x15>
c0024941:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024944:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0024947:	89 c1                	mov    %eax,%ecx
c0024949:	89 d3                	mov    %edx,%ebx
c002494b:	83 c1 ff             	add    $0xffffffff,%ecx
c002494e:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024951:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0024954:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0024957:	85 d2                	test   %edx,%edx
c0024959:	7f e6                	jg     c0024941 <busy_wait+0x15>
c002495b:	85 d2                	test   %edx,%edx
c002495d:	78 05                	js     c0024964 <busy_wait+0x38>
c002495f:	83 f8 00             	cmp    $0x0,%eax
c0024962:	77 dd                	ja     c0024941 <busy_wait+0x15>
    barrier ();
}
c0024964:	90                   	nop
c0024965:	83 c4 0c             	add    $0xc,%esp
c0024968:	5b                   	pop    %ebx
c0024969:	5d                   	pop    %ebp
c002496a:	c3                   	ret    

c002496b <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c002496b:	55                   	push   %ebp
c002496c:	89 e5                	mov    %esp,%ebp
c002496e:	53                   	push   %ebx
c002496f:	83 ec 24             	sub    $0x24,%esp
c0024972:	8b 45 08             	mov    0x8(%ebp),%eax
c0024975:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0024978:	8b 45 0c             	mov    0xc(%ebp),%eax
c002497b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c002497e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0024981:	6b d0 64             	imul   $0x64,%eax,%edx
c0024984:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0024987:	6b c0 00             	imul   $0x0,%eax,%eax
c002498a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c002498d:	b8 64 00 00 00       	mov    $0x64,%eax
c0024992:	f7 65 e0             	mull   -0x20(%ebp)
c0024995:	01 d1                	add    %edx,%ecx
c0024997:	89 ca                	mov    %ecx,%edx
c0024999:	8b 4d 10             	mov    0x10(%ebp),%ecx
c002499c:	89 cb                	mov    %ecx,%ebx
c002499e:	c1 fb 1f             	sar    $0x1f,%ebx
c00249a1:	53                   	push   %ebx
c00249a2:	51                   	push   %ecx
c00249a3:	52                   	push   %edx
c00249a4:	50                   	push   %eax
c00249a5:	e8 6c 4f 00 00       	call   c0029916 <__divdi3>
c00249aa:	83 c4 10             	add    $0x10,%esp
c00249ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00249b0:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c00249b3:	e8 50 cf ff ff       	call   c0021908 <intr_get_level>
c00249b8:	83 f8 01             	cmp    $0x1,%eax
c00249bb:	74 21                	je     c00249de <real_time_sleep+0x73>
c00249bd:	83 ec 0c             	sub    $0xc,%esp
c00249c0:	68 63 ff 02 c0       	push   $0xc002ff63
c00249c5:	68 80 ff 02 c0       	push   $0xc002ff80
c00249ca:	68 2c 00 03 c0       	push   $0xc003002c
c00249cf:	68 03 01 00 00       	push   $0x103
c00249d4:	68 97 ff 02 c0       	push   $0xc002ff97
c00249d9:	e8 44 56 00 00       	call   c002a022 <debug_panic>
  if (ticks > 0)
c00249de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00249e2:	78 1f                	js     c0024a03 <real_time_sleep+0x98>
c00249e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00249e8:	7f 06                	jg     c00249f0 <real_time_sleep+0x85>
c00249ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00249ee:	76 13                	jbe    c0024a03 <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c00249f0:	83 ec 08             	sub    $0x8,%esp
c00249f3:	ff 75 f4             	pushl  -0xc(%ebp)
c00249f6:	ff 75 f0             	pushl  -0x10(%ebp)
c00249f9:	e8 80 fb ff ff       	call   c002457e <timer_sleep>
c00249fe:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c0024a01:	eb 14                	jmp    c0024a17 <real_time_sleep+0xac>
      real_time_delay (num, denom); 
c0024a03:	83 ec 04             	sub    $0x4,%esp
c0024a06:	ff 75 10             	pushl  0x10(%ebp)
c0024a09:	ff 75 e4             	pushl  -0x1c(%ebp)
c0024a0c:	ff 75 e0             	pushl  -0x20(%ebp)
c0024a0f:	e8 09 00 00 00       	call   c0024a1d <real_time_delay>
c0024a14:	83 c4 10             	add    $0x10,%esp
}
c0024a17:	90                   	nop
c0024a18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024a1b:	c9                   	leave  
c0024a1c:	c3                   	ret    

c0024a1d <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024a1d:	55                   	push   %ebp
c0024a1e:	89 e5                	mov    %esp,%ebp
c0024a20:	56                   	push   %esi
c0024a21:	53                   	push   %ebx
c0024a22:	83 ec 10             	sub    $0x10,%esp
c0024a25:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a28:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024a2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0024a31:	8b 45 10             	mov    0x10(%ebp),%eax
c0024a34:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024a39:	99                   	cltd   
c0024a3a:	f7 f9                	idiv   %ecx
c0024a3c:	89 d0                	mov    %edx,%eax
c0024a3e:	85 c0                	test   %eax,%eax
c0024a40:	74 21                	je     c0024a63 <real_time_delay+0x46>
c0024a42:	83 ec 0c             	sub    $0xc,%esp
c0024a45:	68 fb ff 02 c0       	push   $0xc002fffb
c0024a4a:	68 80 ff 02 c0       	push   $0xc002ff80
c0024a4f:	68 3c 00 03 c0       	push   $0xc003003c
c0024a54:	68 19 01 00 00       	push   $0x119
c0024a59:	68 97 ff 02 c0       	push   $0xc002ff97
c0024a5e:	e8 bf 55 00 00       	call   c002a022 <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0024a63:	a1 e8 9c 03 c0       	mov    0xc0039ce8,%eax
c0024a68:	ba 00 00 00 00       	mov    $0x0,%edx
c0024a6d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0024a70:	89 cb                	mov    %ecx,%ebx
c0024a72:	0f af da             	imul   %edx,%ebx
c0024a75:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0024a78:	0f af c8             	imul   %eax,%ecx
c0024a7b:	01 d9                	add    %ebx,%ecx
c0024a7d:	f7 65 f0             	mull   -0x10(%ebp)
c0024a80:	01 d1                	add    %edx,%ecx
c0024a82:	89 ca                	mov    %ecx,%edx
c0024a84:	6a 00                	push   $0x0
c0024a86:	68 e8 03 00 00       	push   $0x3e8
c0024a8b:	52                   	push   %edx
c0024a8c:	50                   	push   %eax
c0024a8d:	e8 84 4e 00 00       	call   c0029916 <__divdi3>
c0024a92:	83 c4 10             	add    $0x10,%esp
c0024a95:	6b da 64             	imul   $0x64,%edx,%ebx
c0024a98:	6b c8 00             	imul   $0x0,%eax,%ecx
c0024a9b:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c0024a9e:	b9 64 00 00 00       	mov    $0x64,%ecx
c0024aa3:	f7 e1                	mul    %ecx
c0024aa5:	89 c1                	mov    %eax,%ecx
c0024aa7:	89 d3                	mov    %edx,%ebx
c0024aa9:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c0024aac:	89 c3                	mov    %eax,%ebx
c0024aae:	8b 75 10             	mov    0x10(%ebp),%esi
c0024ab1:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c0024ab6:	f7 ee                	imul   %esi
c0024ab8:	c1 fa 06             	sar    $0x6,%edx
c0024abb:	89 f0                	mov    %esi,%eax
c0024abd:	c1 f8 1f             	sar    $0x1f,%eax
c0024ac0:	29 c2                	sub    %eax,%edx
c0024ac2:	89 d0                	mov    %edx,%eax
c0024ac4:	99                   	cltd   
c0024ac5:	52                   	push   %edx
c0024ac6:	50                   	push   %eax
c0024ac7:	53                   	push   %ebx
c0024ac8:	51                   	push   %ecx
c0024ac9:	e8 48 4e 00 00       	call   c0029916 <__divdi3>
c0024ace:	83 c4 10             	add    $0x10,%esp
c0024ad1:	83 ec 08             	sub    $0x8,%esp
c0024ad4:	52                   	push   %edx
c0024ad5:	50                   	push   %eax
c0024ad6:	e8 51 fe ff ff       	call   c002492c <busy_wait>
c0024adb:	83 c4 10             	add    $0x10,%esp
}
c0024ade:	90                   	nop
c0024adf:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024ae2:	5b                   	pop    %ebx
c0024ae3:	5e                   	pop    %esi
c0024ae4:	5d                   	pop    %ebp
c0024ae5:	c3                   	ret    

c0024ae6 <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0024ae6:	55                   	push   %ebp
c0024ae7:	89 e5                	mov    %esp,%ebp
c0024ae9:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0024aed:	7e 0d                	jle    c0024afc <isupper+0x16>
c0024aef:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0024af3:	7f 07                	jg     c0024afc <isupper+0x16>
c0024af5:	b8 01 00 00 00       	mov    $0x1,%eax
c0024afa:	eb 05                	jmp    c0024b01 <isupper+0x1b>
c0024afc:	b8 00 00 00 00       	mov    $0x0,%eax
c0024b01:	5d                   	pop    %ebp
c0024b02:	c3                   	ret    

c0024b03 <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024b03:	55                   	push   %ebp
c0024b04:	89 e5                	mov    %esp,%ebp
c0024b06:	ff 75 08             	pushl  0x8(%ebp)
c0024b09:	e8 d8 ff ff ff       	call   c0024ae6 <isupper>
c0024b0e:	83 c4 04             	add    $0x4,%esp
c0024b11:	85 c0                	test   %eax,%eax
c0024b13:	74 08                	je     c0024b1d <tolower+0x1a>
c0024b15:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b18:	83 c0 20             	add    $0x20,%eax
c0024b1b:	eb 03                	jmp    c0024b20 <tolower+0x1d>
c0024b1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b20:	c9                   	leave  
c0024b21:	c3                   	ret    

c0024b22 <inb>:
{
c0024b22:	55                   	push   %ebp
c0024b23:	89 e5                	mov    %esp,%ebp
c0024b25:	83 ec 14             	sub    $0x14,%esp
c0024b28:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b2b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024b32:	89 c2                	mov    %eax,%edx
c0024b34:	ec                   	in     (%dx),%al
c0024b35:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024b38:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024b3b:	c9                   	leave  
c0024b3c:	c3                   	ret    

c0024b3d <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c0024b3d:	55                   	push   %ebp
c0024b3e:	89 e5                	mov    %esp,%ebp
c0024b40:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0024b43:	83 ec 04             	sub    $0x4,%esp
c0024b46:	68 60 00 03 c0       	push   $0xc0030060
c0024b4b:	68 83 4b 02 c0       	push   $0xc0024b83
c0024b50:	6a 21                	push   $0x21
c0024b52:	e8 45 d0 ff ff       	call   c0021b9c <intr_register_ext>
c0024b57:	83 c4 10             	add    $0x10,%esp
}
c0024b5a:	90                   	nop
c0024b5b:	c9                   	leave  
c0024b5c:	c3                   	ret    

c0024b5d <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c0024b5d:	55                   	push   %ebp
c0024b5e:	89 e5                	mov    %esp,%ebp
c0024b60:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c0024b63:	a1 08 9d 03 c0       	mov    0xc0039d08,%eax
c0024b68:	8b 15 0c 9d 03 c0    	mov    0xc0039d0c,%edx
c0024b6e:	83 ec 04             	sub    $0x4,%esp
c0024b71:	52                   	push   %edx
c0024b72:	50                   	push   %eax
c0024b73:	68 6e 00 03 c0       	push   $0xc003006e
c0024b78:	e8 d4 2f 00 00       	call   c0027b51 <printf>
c0024b7d:	83 c4 10             	add    $0x10,%esp
}
c0024b80:	90                   	nop
c0024b81:	c9                   	leave  
c0024b82:	c3                   	ret    

c0024b83 <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c0024b83:	55                   	push   %ebp
c0024b84:	89 e5                	mov    %esp,%ebp
c0024b86:	53                   	push   %ebx
c0024b87:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c0024b8a:	a0 00 9d 03 c0       	mov    0xc0039d00,%al
c0024b8f:	84 c0                	test   %al,%al
c0024b91:	75 09                	jne    c0024b9c <keyboard_interrupt+0x19>
c0024b93:	a0 01 9d 03 c0       	mov    0xc0039d01,%al
c0024b98:	84 c0                	test   %al,%al
c0024b9a:	74 07                	je     c0024ba3 <keyboard_interrupt+0x20>
c0024b9c:	b8 01 00 00 00       	mov    $0x1,%eax
c0024ba1:	eb 05                	jmp    c0024ba8 <keyboard_interrupt+0x25>
c0024ba3:	b8 00 00 00 00       	mov    $0x0,%eax
c0024ba8:	88 45 ef             	mov    %al,-0x11(%ebp)
c0024bab:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c0024baf:	a0 02 9d 03 c0       	mov    0xc0039d02,%al
c0024bb4:	84 c0                	test   %al,%al
c0024bb6:	75 09                	jne    c0024bc1 <keyboard_interrupt+0x3e>
c0024bb8:	a0 03 9d 03 c0       	mov    0xc0039d03,%al
c0024bbd:	84 c0                	test   %al,%al
c0024bbf:	74 07                	je     c0024bc8 <keyboard_interrupt+0x45>
c0024bc1:	b8 01 00 00 00       	mov    $0x1,%eax
c0024bc6:	eb 05                	jmp    c0024bcd <keyboard_interrupt+0x4a>
c0024bc8:	b8 00 00 00 00       	mov    $0x0,%eax
c0024bcd:	88 45 ee             	mov    %al,-0x12(%ebp)
c0024bd0:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c0024bd4:	a0 04 9d 03 c0       	mov    0xc0039d04,%al
c0024bd9:	84 c0                	test   %al,%al
c0024bdb:	75 09                	jne    c0024be6 <keyboard_interrupt+0x63>
c0024bdd:	a0 05 9d 03 c0       	mov    0xc0039d05,%al
c0024be2:	84 c0                	test   %al,%al
c0024be4:	74 07                	je     c0024bed <keyboard_interrupt+0x6a>
c0024be6:	b8 01 00 00 00       	mov    $0x1,%eax
c0024beb:	eb 05                	jmp    c0024bf2 <keyboard_interrupt+0x6f>
c0024bed:	b8 00 00 00 00       	mov    $0x0,%eax
c0024bf2:	88 45 ed             	mov    %al,-0x13(%ebp)
c0024bf5:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0024bf9:	6a 60                	push   $0x60
c0024bfb:	e8 22 ff ff ff       	call   c0024b22 <inb>
c0024c00:	83 c4 04             	add    $0x4,%esp
c0024c03:	0f b6 c0             	movzbl %al,%eax
c0024c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c0024c09:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0024c10:	75 1a                	jne    c0024c2c <keyboard_interrupt+0xa9>
    code = (code << 8) | inb (DATA_REG);
c0024c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024c15:	c1 e0 08             	shl    $0x8,%eax
c0024c18:	89 c3                	mov    %eax,%ebx
c0024c1a:	6a 60                	push   $0x60
c0024c1c:	e8 01 ff ff ff       	call   c0024b22 <inb>
c0024c21:	83 c4 04             	add    $0x4,%esp
c0024c24:	0f b6 c0             	movzbl %al,%eax
c0024c27:	09 d8                	or     %ebx,%eax
c0024c29:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c0024c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024c2f:	25 80 00 00 00       	and    $0x80,%eax
c0024c34:	85 c0                	test   %eax,%eax
c0024c36:	0f 95 c0             	setne  %al
c0024c39:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c0024c3c:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c0024c43:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c0024c47:	75 2e                	jne    c0024c77 <keyboard_interrupt+0xf4>
    {
      /* Caps Lock. */
      if (!release)
c0024c49:	8a 45 ec             	mov    -0x14(%ebp),%al
c0024c4c:	83 f0 01             	xor    $0x1,%eax
c0024c4f:	84 c0                	test   %al,%al
c0024c51:	0f 84 77 01 00 00    	je     c0024dce <keyboard_interrupt+0x24b>
        caps_lock = !caps_lock;
c0024c57:	a0 06 9d 03 c0       	mov    0xc0039d06,%al
c0024c5c:	0f b6 c0             	movzbl %al,%eax
c0024c5f:	85 c0                	test   %eax,%eax
c0024c61:	0f 95 c0             	setne  %al
c0024c64:	83 f0 01             	xor    $0x1,%eax
c0024c67:	0f b6 c0             	movzbl %al,%eax
c0024c6a:	83 e0 01             	and    $0x1,%eax
c0024c6d:	a2 06 9d 03 c0       	mov    %al,0xc0039d06
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024c72:	e9 57 01 00 00       	jmp    c0024dce <keyboard_interrupt+0x24b>
  else if (map_key (invariant_keymap, code, &c)
c0024c77:	83 ec 04             	sub    $0x4,%esp
c0024c7a:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024c7d:	50                   	push   %eax
c0024c7e:	ff 75 f4             	pushl  -0xc(%ebp)
c0024c81:	68 c0 00 03 c0       	push   $0xc00300c0
c0024c86:	e8 49 01 00 00       	call   c0024dd4 <map_key>
c0024c8b:	83 c4 10             	add    $0x10,%esp
c0024c8e:	84 c0                	test   %al,%al
c0024c90:	75 4e                	jne    c0024ce0 <keyboard_interrupt+0x15d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c0024c92:	8a 45 ef             	mov    -0x11(%ebp),%al
c0024c95:	83 f0 01             	xor    $0x1,%eax
c0024c98:	84 c0                	test   %al,%al
c0024c9a:	74 1b                	je     c0024cb7 <keyboard_interrupt+0x134>
c0024c9c:	83 ec 04             	sub    $0x4,%esp
c0024c9f:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024ca2:	50                   	push   %eax
c0024ca3:	ff 75 f4             	pushl  -0xc(%ebp)
c0024ca6:	68 40 01 03 c0       	push   $0xc0030140
c0024cab:	e8 24 01 00 00       	call   c0024dd4 <map_key>
c0024cb0:	83 c4 10             	add    $0x10,%esp
c0024cb3:	84 c0                	test   %al,%al
c0024cb5:	75 29                	jne    c0024ce0 <keyboard_interrupt+0x15d>
           || (shift && map_key (shifted_keymap, code, &c)))
c0024cb7:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0024cbb:	0f 84 ce 00 00 00    	je     c0024d8f <keyboard_interrupt+0x20c>
c0024cc1:	83 ec 04             	sub    $0x4,%esp
c0024cc4:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024cc7:	50                   	push   %eax
c0024cc8:	ff 75 f4             	pushl  -0xc(%ebp)
c0024ccb:	68 a0 01 03 c0       	push   $0xc00301a0
c0024cd0:	e8 ff 00 00 00       	call   c0024dd4 <map_key>
c0024cd5:	83 c4 10             	add    $0x10,%esp
c0024cd8:	84 c0                	test   %al,%al
c0024cda:	0f 84 af 00 00 00    	je     c0024d8f <keyboard_interrupt+0x20c>
      if (!release) 
c0024ce0:	8a 45 ec             	mov    -0x14(%ebp),%al
c0024ce3:	83 f0 01             	xor    $0x1,%eax
c0024ce6:	84 c0                	test   %al,%al
c0024ce8:	0f 84 df 00 00 00    	je     c0024dcd <keyboard_interrupt+0x24a>
          if (c == 0177 && ctrl && alt)
c0024cee:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024cf1:	3c 7f                	cmp    $0x7f,%al
c0024cf3:	75 11                	jne    c0024d06 <keyboard_interrupt+0x183>
c0024cf5:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024cf9:	74 0b                	je     c0024d06 <keyboard_interrupt+0x183>
c0024cfb:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024cff:	74 05                	je     c0024d06 <keyboard_interrupt+0x183>
            shutdown_reboot ();
c0024d01:	e8 df 28 00 00       	call   c00275e5 <shutdown_reboot>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024d06:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024d0a:	74 19                	je     c0024d25 <keyboard_interrupt+0x1a2>
c0024d0c:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024d0f:	3c 3f                	cmp    $0x3f,%al
c0024d11:	76 12                	jbe    c0024d25 <keyboard_interrupt+0x1a2>
c0024d13:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024d16:	3c 5f                	cmp    $0x5f,%al
c0024d18:	77 0b                	ja     c0024d25 <keyboard_interrupt+0x1a2>
              c -= 0x40; 
c0024d1a:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024d1d:	83 e8 40             	sub    $0x40,%eax
c0024d20:	88 45 eb             	mov    %al,-0x15(%ebp)
c0024d23:	eb 1f                	jmp    c0024d44 <keyboard_interrupt+0x1c1>
          else if (shift == caps_lock)
c0024d25:	a0 06 9d 03 c0       	mov    0xc0039d06,%al
c0024d2a:	38 45 ef             	cmp    %al,-0x11(%ebp)
c0024d2d:	75 15                	jne    c0024d44 <keyboard_interrupt+0x1c1>
            c = tolower (c);
c0024d2f:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024d32:	0f b6 c0             	movzbl %al,%eax
c0024d35:	83 ec 0c             	sub    $0xc,%esp
c0024d38:	50                   	push   %eax
c0024d39:	e8 c5 fd ff ff       	call   c0024b03 <tolower>
c0024d3e:	83 c4 10             	add    $0x10,%esp
c0024d41:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (alt)
c0024d44:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024d48:	74 09                	je     c0024d53 <keyboard_interrupt+0x1d0>
            c += 0x80;
c0024d4a:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024d4d:	83 c0 80             	add    $0xffffff80,%eax
c0024d50:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (!input_full ())
c0024d53:	e8 34 21 00 00       	call   c0026e8c <input_full>
c0024d58:	83 f0 01             	xor    $0x1,%eax
c0024d5b:	84 c0                	test   %al,%al
c0024d5d:	74 6e                	je     c0024dcd <keyboard_interrupt+0x24a>
              key_cnt++;
c0024d5f:	a1 08 9d 03 c0       	mov    0xc0039d08,%eax
c0024d64:	8b 15 0c 9d 03 c0    	mov    0xc0039d0c,%edx
c0024d6a:	83 c0 01             	add    $0x1,%eax
c0024d6d:	83 d2 00             	adc    $0x0,%edx
c0024d70:	a3 08 9d 03 c0       	mov    %eax,0xc0039d08
c0024d75:	89 15 0c 9d 03 c0    	mov    %edx,0xc0039d0c
              input_putc (c);
c0024d7b:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024d7e:	0f b6 c0             	movzbl %al,%eax
c0024d81:	83 ec 0c             	sub    $0xc,%esp
c0024d84:	50                   	push   %eax
c0024d85:	e8 44 20 00 00       	call   c0026dce <input_putc>
c0024d8a:	83 c4 10             	add    $0x10,%esp
      if (!release) 
c0024d8d:	eb 3e                	jmp    c0024dcd <keyboard_interrupt+0x24a>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024d8f:	c7 45 f0 e0 01 03 c0 	movl   $0xc00301e0,-0x10(%ebp)
c0024d96:	eb 2a                	jmp    c0024dc2 <keyboard_interrupt+0x23f>
        if (key->scancode == code)
c0024d98:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024d9b:	8b 00                	mov    (%eax),%eax
c0024d9d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0024da0:	75 1c                	jne    c0024dbe <keyboard_interrupt+0x23b>
            *key->state_var = !release;
c0024da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024da5:	8b 50 04             	mov    0x4(%eax),%edx
c0024da8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0024dac:	85 c0                	test   %eax,%eax
c0024dae:	0f 95 c0             	setne  %al
c0024db1:	83 f0 01             	xor    $0x1,%eax
c0024db4:	0f b6 c0             	movzbl %al,%eax
c0024db7:	83 e0 01             	and    $0x1,%eax
c0024dba:	88 02                	mov    %al,(%edx)
            break;
c0024dbc:	eb 10                	jmp    c0024dce <keyboard_interrupt+0x24b>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024dbe:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c0024dc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024dc5:	8b 00                	mov    (%eax),%eax
c0024dc7:	85 c0                	test   %eax,%eax
c0024dc9:	75 cd                	jne    c0024d98 <keyboard_interrupt+0x215>
}
c0024dcb:	eb 01                	jmp    c0024dce <keyboard_interrupt+0x24b>
      if (!release) 
c0024dcd:	90                   	nop
}
c0024dce:	90                   	nop
c0024dcf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024dd2:	c9                   	leave  
c0024dd3:	c3                   	ret    

c0024dd4 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0024dd4:	55                   	push   %ebp
c0024dd5:	89 e5                	mov    %esp,%ebp
c0024dd7:	53                   	push   %ebx
c0024dd8:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c0024ddb:	eb 56                	jmp    c0024e33 <map_key+0x5f>
    if (scancode >= k->first_scancode
c0024ddd:	8b 45 08             	mov    0x8(%ebp),%eax
c0024de0:	8a 00                	mov    (%eax),%al
c0024de2:	0f b6 c0             	movzbl %al,%eax
c0024de5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024de8:	77 45                	ja     c0024e2f <map_key+0x5b>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024dea:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ded:	8a 00                	mov    (%eax),%al
c0024def:	0f b6 d8             	movzbl %al,%ebx
c0024df2:	8b 45 08             	mov    0x8(%ebp),%eax
c0024df5:	8b 40 04             	mov    0x4(%eax),%eax
c0024df8:	83 ec 0c             	sub    $0xc,%esp
c0024dfb:	50                   	push   %eax
c0024dfc:	e8 82 45 00 00       	call   c0029383 <strlen>
c0024e01:	83 c4 10             	add    $0x10,%esp
c0024e04:	01 d8                	add    %ebx,%eax
c0024e06:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024e09:	76 24                	jbe    c0024e2f <map_key+0x5b>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024e0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e0e:	8b 50 04             	mov    0x4(%eax),%edx
c0024e11:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e14:	8a 00                	mov    (%eax),%al
c0024e16:	0f b6 c0             	movzbl %al,%eax
c0024e19:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0024e1c:	29 c1                	sub    %eax,%ecx
c0024e1e:	89 c8                	mov    %ecx,%eax
c0024e20:	01 d0                	add    %edx,%eax
c0024e22:	8a 00                	mov    (%eax),%al
c0024e24:	88 c2                	mov    %al,%dl
c0024e26:	8b 45 10             	mov    0x10(%ebp),%eax
c0024e29:	88 10                	mov    %dl,(%eax)
        return true; 
c0024e2b:	b0 01                	mov    $0x1,%al
c0024e2d:	eb 0f                	jmp    c0024e3e <map_key+0x6a>
  for (; k->first_scancode != 0; k++)
c0024e2f:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c0024e33:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e36:	8a 00                	mov    (%eax),%al
c0024e38:	84 c0                	test   %al,%al
c0024e3a:	75 a1                	jne    c0024ddd <map_key+0x9>
      }

  return false;
c0024e3c:	b0 00                	mov    $0x0,%al
}
c0024e3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024e41:	c9                   	leave  
c0024e42:	c3                   	ret    

c0024e43 <inb>:
{
c0024e43:	55                   	push   %ebp
c0024e44:	89 e5                	mov    %esp,%ebp
c0024e46:	83 ec 14             	sub    $0x14,%esp
c0024e49:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e4c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024e50:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024e53:	89 c2                	mov    %eax,%edx
c0024e55:	ec                   	in     (%dx),%al
c0024e56:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024e59:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024e5c:	c9                   	leave  
c0024e5d:	c3                   	ret    

c0024e5e <outb>:
{
c0024e5e:	55                   	push   %ebp
c0024e5f:	89 e5                	mov    %esp,%ebp
c0024e61:	83 ec 08             	sub    $0x8,%esp
c0024e64:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e67:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024e6a:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024e6e:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024e71:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024e74:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024e77:	ee                   	out    %al,(%dx)
}
c0024e78:	90                   	nop
c0024e79:	c9                   	leave  
c0024e7a:	c3                   	ret    

c0024e7b <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0024e7b:	55                   	push   %ebp
c0024e7c:	89 e5                	mov    %esp,%ebp
c0024e7e:	83 ec 08             	sub    $0x8,%esp
c0024e81:	8b 55 08             	mov    0x8(%ebp),%edx
c0024e84:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024e87:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024e8b:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024e8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0024e92:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024e95:	66 ef                	out    %ax,(%dx)
}
c0024e97:	90                   	nop
c0024e98:	c9                   	leave  
c0024e99:	c3                   	ret    

c0024e9a <ptov>:
{
c0024e9a:	55                   	push   %ebp
c0024e9b:	89 e5                	mov    %esp,%ebp
c0024e9d:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0024ea0:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ea3:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0024ea8:	76 1e                	jbe    c0024ec8 <ptov+0x2e>
c0024eaa:	83 ec 0c             	sub    $0xc,%esp
c0024ead:	68 18 02 03 c0       	push   $0xc0030218
c0024eb2:	68 33 02 03 c0       	push   $0xc0030233
c0024eb7:	68 7c 02 03 c0       	push   $0xc003027c
c0024ebc:	6a 4a                	push   $0x4a
c0024ebe:	68 4a 02 03 c0       	push   $0xc003024a
c0024ec3:	e8 5a 51 00 00       	call   c002a022 <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0024ec8:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ecb:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0024ed0:	c9                   	leave  
c0024ed1:	c3                   	ret    

c0024ed2 <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c0024ed2:	55                   	push   %ebp
c0024ed3:	89 e5                	mov    %esp,%ebp
c0024ed5:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0024ed8:	a0 1c 9d 03 c0       	mov    0xc0039d1c,%al
c0024edd:	83 f0 01             	xor    $0x1,%eax
c0024ee0:	84 c0                	test   %al,%al
c0024ee2:	74 31                	je     c0024f15 <init+0x43>
    {
      fb = ptov (0xb8000);
c0024ee4:	83 ec 0c             	sub    $0xc,%esp
c0024ee7:	68 00 80 0b 00       	push   $0xb8000
c0024eec:	e8 a9 ff ff ff       	call   c0024e9a <ptov>
c0024ef1:	83 c4 10             	add    $0x10,%esp
c0024ef4:	a3 18 9d 03 c0       	mov    %eax,0xc0039d18
      find_cursor (&cx, &cy);
c0024ef9:	83 ec 08             	sub    $0x8,%esp
c0024efc:	68 14 9d 03 c0       	push   $0xc0039d14
c0024f01:	68 10 9d 03 c0       	push   $0xc0039d10
c0024f06:	e8 8f 02 00 00       	call   c002519a <find_cursor>
c0024f0b:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0024f0e:	c6 05 1c 9d 03 c0 01 	movb   $0x1,0xc0039d1c
    }
}
c0024f15:	90                   	nop
c0024f16:	c9                   	leave  
c0024f17:	c3                   	ret    

c0024f18 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0024f18:	55                   	push   %ebp
c0024f19:	89 e5                	mov    %esp,%ebp
c0024f1b:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0024f1e:	e8 5a ca ff ff       	call   c002197d <intr_disable>
c0024f23:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c0024f26:	e8 a7 ff ff ff       	call   c0024ed2 <init>
  
  switch (c) 
c0024f2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f2e:	83 e8 07             	sub    $0x7,%eax
c0024f31:	83 f8 06             	cmp    $0x6,%eax
c0024f34:	0f 87 8b 00 00 00    	ja     c0024fc5 <vga_putc+0xad>
c0024f3a:	8b 04 85 60 02 03 c0 	mov    -0x3ffcfda0(,%eax,4),%eax
c0024f41:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c0024f43:	e8 95 01 00 00       	call   c00250dd <newline>
      break;
c0024f48:	e9 e2 00 00 00       	jmp    c002502f <vga_putc+0x117>

    case '\f':
      cls ();
c0024f4d:	e8 f3 00 00 00       	call   c0025045 <cls>
      break;
c0024f52:	e9 d8 00 00 00       	jmp    c002502f <vga_putc+0x117>

    case '\b':
      if (cx > 0)
c0024f57:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0024f5c:	85 c0                	test   %eax,%eax
c0024f5e:	0f 84 c4 00 00 00    	je     c0025028 <vga_putc+0x110>
        cx--;
c0024f64:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0024f69:	48                   	dec    %eax
c0024f6a:	a3 10 9d 03 c0       	mov    %eax,0xc0039d10
      break;
c0024f6f:	e9 b4 00 00 00       	jmp    c0025028 <vga_putc+0x110>
      
    case '\r':
      cx = 0;
c0024f74:	c7 05 10 9d 03 c0 00 	movl   $0x0,0xc0039d10
c0024f7b:	00 00 00 
      break;
c0024f7e:	e9 ac 00 00 00       	jmp    c002502f <vga_putc+0x117>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0024f83:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0024f88:	83 c0 08             	add    $0x8,%eax
c0024f8b:	83 e0 f8             	and    $0xfffffff8,%eax
c0024f8e:	a3 10 9d 03 c0       	mov    %eax,0xc0039d10
      if (cx >= COL_CNT)
c0024f93:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0024f98:	83 f8 4f             	cmp    $0x4f,%eax
c0024f9b:	0f 86 8a 00 00 00    	jbe    c002502b <vga_putc+0x113>
        newline ();
c0024fa1:	e8 37 01 00 00       	call   c00250dd <newline>
      break;
c0024fa6:	e9 80 00 00 00       	jmp    c002502b <vga_putc+0x113>

    case '\a':
      intr_set_level (old_level);
c0024fab:	83 ec 0c             	sub    $0xc,%esp
c0024fae:	ff 75 f4             	pushl  -0xc(%ebp)
c0024fb1:	e8 6f c9 ff ff       	call   c0021925 <intr_set_level>
c0024fb6:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c0024fb9:	e8 4c 28 00 00       	call   c002780a <speaker_beep>
      intr_disable ();
c0024fbe:	e8 ba c9 ff ff       	call   c002197d <intr_disable>
      break;
c0024fc3:	eb 6a                	jmp    c002502f <vga_putc+0x117>
      
    default:
      fb[cy][cx][0] = c;
c0024fc5:	8b 0d 18 9d 03 c0    	mov    0xc0039d18,%ecx
c0024fcb:	8b 15 14 9d 03 c0    	mov    0xc0039d14,%edx
c0024fd1:	89 d0                	mov    %edx,%eax
c0024fd3:	c1 e0 02             	shl    $0x2,%eax
c0024fd6:	01 d0                	add    %edx,%eax
c0024fd8:	c1 e0 05             	shl    $0x5,%eax
c0024fdb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024fde:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0024fe3:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024fe6:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024fe9:	8b 0d 18 9d 03 c0    	mov    0xc0039d18,%ecx
c0024fef:	8b 15 14 9d 03 c0    	mov    0xc0039d14,%edx
c0024ff5:	89 d0                	mov    %edx,%eax
c0024ff7:	c1 e0 02             	shl    $0x2,%eax
c0024ffa:	01 d0                	add    %edx,%eax
c0024ffc:	c1 e0 05             	shl    $0x5,%eax
c0024fff:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0025002:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0025007:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c002500c:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c0025011:	40                   	inc    %eax
c0025012:	a3 10 9d 03 c0       	mov    %eax,0xc0039d10
c0025017:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c002501c:	83 f8 4f             	cmp    $0x4f,%eax
c002501f:	76 0d                	jbe    c002502e <vga_putc+0x116>
        newline ();
c0025021:	e8 b7 00 00 00       	call   c00250dd <newline>
      break;
c0025026:	eb 06                	jmp    c002502e <vga_putc+0x116>
      break;
c0025028:	90                   	nop
c0025029:	eb 04                	jmp    c002502f <vga_putc+0x117>
      break;
c002502b:	90                   	nop
c002502c:	eb 01                	jmp    c002502f <vga_putc+0x117>
      break;
c002502e:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c002502f:	e8 0a 01 00 00       	call   c002513e <move_cursor>

  intr_set_level (old_level);
c0025034:	83 ec 0c             	sub    $0xc,%esp
c0025037:	ff 75 f4             	pushl  -0xc(%ebp)
c002503a:	e8 e6 c8 ff ff       	call   c0021925 <intr_set_level>
c002503f:	83 c4 10             	add    $0x10,%esp
}
c0025042:	90                   	nop
c0025043:	c9                   	leave  
c0025044:	c3                   	ret    

c0025045 <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c0025045:	55                   	push   %ebp
c0025046:	89 e5                	mov    %esp,%ebp
c0025048:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c002504b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025052:	eb 11                	jmp    c0025065 <cls+0x20>
    clear_row (y);
c0025054:	83 ec 0c             	sub    $0xc,%esp
c0025057:	ff 75 f4             	pushl  -0xc(%ebp)
c002505a:	e8 28 00 00 00       	call   c0025087 <clear_row>
c002505f:	83 c4 10             	add    $0x10,%esp
  for (y = 0; y < ROW_CNT; y++)
c0025062:	ff 45 f4             	incl   -0xc(%ebp)
c0025065:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0025069:	76 e9                	jbe    c0025054 <cls+0xf>

  cx = cy = 0;
c002506b:	c7 05 14 9d 03 c0 00 	movl   $0x0,0xc0039d14
c0025072:	00 00 00 
c0025075:	a1 14 9d 03 c0       	mov    0xc0039d14,%eax
c002507a:	a3 10 9d 03 c0       	mov    %eax,0xc0039d10
  move_cursor ();
c002507f:	e8 ba 00 00 00       	call   c002513e <move_cursor>
}
c0025084:	90                   	nop
c0025085:	c9                   	leave  
c0025086:	c3                   	ret    

c0025087 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0025087:	55                   	push   %ebp
c0025088:	89 e5                	mov    %esp,%ebp
c002508a:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c002508d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0025094:	eb 3e                	jmp    c00250d4 <clear_row+0x4d>
    {
      fb[y][x][0] = ' ';
c0025096:	8b 0d 18 9d 03 c0    	mov    0xc0039d18,%ecx
c002509c:	8b 55 08             	mov    0x8(%ebp),%edx
c002509f:	89 d0                	mov    %edx,%eax
c00250a1:	c1 e0 02             	shl    $0x2,%eax
c00250a4:	01 d0                	add    %edx,%eax
c00250a6:	c1 e0 05             	shl    $0x5,%eax
c00250a9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00250ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00250af:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c00250b3:	8b 0d 18 9d 03 c0    	mov    0xc0039d18,%ecx
c00250b9:	8b 55 08             	mov    0x8(%ebp),%edx
c00250bc:	89 d0                	mov    %edx,%eax
c00250be:	c1 e0 02             	shl    $0x2,%eax
c00250c1:	01 d0                	add    %edx,%eax
c00250c3:	c1 e0 05             	shl    $0x5,%eax
c00250c6:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00250c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00250cc:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
  for (x = 0; x < COL_CNT; x++)
c00250d1:	ff 45 fc             	incl   -0x4(%ebp)
c00250d4:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c00250d8:	76 bc                	jbe    c0025096 <clear_row+0xf>
    }
}
c00250da:	90                   	nop
c00250db:	c9                   	leave  
c00250dc:	c3                   	ret    

c00250dd <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c00250dd:	55                   	push   %ebp
c00250de:	89 e5                	mov    %esp,%ebp
c00250e0:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c00250e3:	c7 05 10 9d 03 c0 00 	movl   $0x0,0xc0039d10
c00250ea:	00 00 00 
  cy++;
c00250ed:	a1 14 9d 03 c0       	mov    0xc0039d14,%eax
c00250f2:	40                   	inc    %eax
c00250f3:	a3 14 9d 03 c0       	mov    %eax,0xc0039d14
  if (cy >= ROW_CNT)
c00250f8:	a1 14 9d 03 c0       	mov    0xc0039d14,%eax
c00250fd:	83 f8 18             	cmp    $0x18,%eax
c0025100:	76 39                	jbe    c002513b <newline+0x5e>
    {
      cy = ROW_CNT - 1;
c0025102:	c7 05 14 9d 03 c0 18 	movl   $0x18,0xc0039d14
c0025109:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c002510c:	a1 18 9d 03 c0       	mov    0xc0039d18,%eax
c0025111:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0025117:	a1 18 9d 03 c0       	mov    0xc0039d18,%eax
c002511c:	83 ec 04             	sub    $0x4,%esp
c002511f:	68 00 0f 00 00       	push   $0xf00
c0025124:	52                   	push   %edx
c0025125:	50                   	push   %eax
c0025126:	e8 b3 3c 00 00       	call   c0028dde <memmove>
c002512b:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c002512e:	83 ec 0c             	sub    $0xc,%esp
c0025131:	6a 18                	push   $0x18
c0025133:	e8 4f ff ff ff       	call   c0025087 <clear_row>
c0025138:	83 c4 10             	add    $0x10,%esp
    }
}
c002513b:	90                   	nop
c002513c:	c9                   	leave  
c002513d:	c3                   	ret    

c002513e <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c002513e:	55                   	push   %ebp
c002513f:	89 e5                	mov    %esp,%ebp
c0025141:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0025144:	a1 14 9d 03 c0       	mov    0xc0039d14,%eax
c0025149:	89 c2                	mov    %eax,%edx
c002514b:	89 d0                	mov    %edx,%eax
c002514d:	c1 e0 02             	shl    $0x2,%eax
c0025150:	01 d0                	add    %edx,%eax
c0025152:	c1 e0 04             	shl    $0x4,%eax
c0025155:	89 c2                	mov    %eax,%edx
c0025157:	a1 10 9d 03 c0       	mov    0xc0039d10,%eax
c002515c:	01 d0                	add    %edx,%eax
c002515e:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0025162:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0025166:	b0 00                	mov    $0x0,%al
c0025168:	83 c8 0e             	or     $0xe,%eax
c002516b:	0f b7 c0             	movzwl %ax,%eax
c002516e:	50                   	push   %eax
c002516f:	68 d4 03 00 00       	push   $0x3d4
c0025174:	e8 02 fd ff ff       	call   c0024e7b <outw>
c0025179:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c002517c:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0025180:	c1 e0 08             	shl    $0x8,%eax
c0025183:	83 c8 0f             	or     $0xf,%eax
c0025186:	0f b7 c0             	movzwl %ax,%eax
c0025189:	50                   	push   %eax
c002518a:	68 d4 03 00 00       	push   $0x3d4
c002518f:	e8 e7 fc ff ff       	call   c0024e7b <outw>
c0025194:	83 c4 08             	add    $0x8,%esp
}
c0025197:	90                   	nop
c0025198:	c9                   	leave  
c0025199:	c3                   	ret    

c002519a <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c002519a:	55                   	push   %ebp
c002519b:	89 e5                	mov    %esp,%ebp
c002519d:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c00251a0:	6a 0e                	push   $0xe
c00251a2:	68 d4 03 00 00       	push   $0x3d4
c00251a7:	e8 b2 fc ff ff       	call   c0024e5e <outb>
c00251ac:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c00251af:	68 d5 03 00 00       	push   $0x3d5
c00251b4:	e8 8a fc ff ff       	call   c0024e43 <inb>
c00251b9:	83 c4 04             	add    $0x4,%esp
c00251bc:	0f b6 c0             	movzbl %al,%eax
c00251bf:	c1 e0 08             	shl    $0x8,%eax
c00251c2:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c00251c6:	6a 0f                	push   $0xf
c00251c8:	68 d4 03 00 00       	push   $0x3d4
c00251cd:	e8 8c fc ff ff       	call   c0024e5e <outb>
c00251d2:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c00251d5:	68 d5 03 00 00       	push   $0x3d5
c00251da:	e8 64 fc ff ff       	call   c0024e43 <inb>
c00251df:	83 c4 04             	add    $0x4,%esp
c00251e2:	0f b6 c0             	movzbl %al,%eax
c00251e5:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c00251e9:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c00251ed:	b9 50 00 00 00       	mov    $0x50,%ecx
c00251f2:	ba 00 00 00 00       	mov    $0x0,%edx
c00251f7:	66 f7 f1             	div    %cx
c00251fa:	89 d0                	mov    %edx,%eax
c00251fc:	0f b7 d0             	movzwl %ax,%edx
c00251ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0025202:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0025204:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0025208:	0f b7 d0             	movzwl %ax,%edx
c002520b:	89 d0                	mov    %edx,%eax
c002520d:	c1 e0 02             	shl    $0x2,%eax
c0025210:	01 d0                	add    %edx,%eax
c0025212:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0025219:	01 c8                	add    %ecx,%eax
c002521b:	01 c0                	add    %eax,%eax
c002521d:	01 d0                	add    %edx,%eax
c002521f:	89 c1                	mov    %eax,%ecx
c0025221:	c1 e1 08             	shl    $0x8,%ecx
c0025224:	01 c8                	add    %ecx,%eax
c0025226:	c1 e0 02             	shl    $0x2,%eax
c0025229:	01 d0                	add    %edx,%eax
c002522b:	c1 e8 10             	shr    $0x10,%eax
c002522e:	66 c1 e8 06          	shr    $0x6,%ax
c0025232:	0f b7 d0             	movzwl %ax,%edx
c0025235:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025238:	89 10                	mov    %edx,(%eax)
}
c002523a:	90                   	nop
c002523b:	c9                   	leave  
c002523c:	c3                   	ret    

c002523d <inb>:
{
c002523d:	55                   	push   %ebp
c002523e:	89 e5                	mov    %esp,%ebp
c0025240:	83 ec 14             	sub    $0x14,%esp
c0025243:	8b 45 08             	mov    0x8(%ebp),%eax
c0025246:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002524a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002524d:	89 c2                	mov    %eax,%edx
c002524f:	ec                   	in     (%dx),%al
c0025250:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0025253:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0025256:	c9                   	leave  
c0025257:	c3                   	ret    

c0025258 <outb>:
{
c0025258:	55                   	push   %ebp
c0025259:	89 e5                	mov    %esp,%ebp
c002525b:	83 ec 08             	sub    $0x8,%esp
c002525e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025261:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025264:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0025268:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002526b:	8a 45 f8             	mov    -0x8(%ebp),%al
c002526e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025271:	ee                   	out    %al,(%dx)
}
c0025272:	90                   	nop
c0025273:	c9                   	leave  
c0025274:	c3                   	ret    

c0025275 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0025275:	55                   	push   %ebp
c0025276:	89 e5                	mov    %esp,%ebp
c0025278:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c002527b:	a1 20 9d 03 c0       	mov    0xc0039d20,%eax
c0025280:	85 c0                	test   %eax,%eax
c0025282:	74 1e                	je     c00252a2 <init_poll+0x2d>
c0025284:	83 ec 0c             	sub    $0xc,%esp
c0025287:	68 84 02 03 c0       	push   $0xc0030284
c002528c:	68 93 02 03 c0       	push   $0xc0030293
c0025291:	68 10 03 03 c0       	push   $0xc0030310
c0025296:	6a 45                	push   $0x45
c0025298:	68 aa 02 03 c0       	push   $0xc00302aa
c002529d:	e8 80 4d 00 00       	call   c002a022 <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c00252a2:	83 ec 08             	sub    $0x8,%esp
c00252a5:	6a 00                	push   $0x0
c00252a7:	68 f9 03 00 00       	push   $0x3f9
c00252ac:	e8 a7 ff ff ff       	call   c0025258 <outb>
c00252b1:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c00252b4:	83 ec 08             	sub    $0x8,%esp
c00252b7:	6a 00                	push   $0x0
c00252b9:	68 fa 03 00 00       	push   $0x3fa
c00252be:	e8 95 ff ff ff       	call   c0025258 <outb>
c00252c3:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c00252c6:	83 ec 0c             	sub    $0xc,%esp
c00252c9:	68 80 25 00 00       	push   $0x2580
c00252ce:	e8 e8 01 00 00       	call   c00254bb <set_serial>
c00252d3:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c00252d6:	83 ec 08             	sub    $0x8,%esp
c00252d9:	6a 08                	push   $0x8
c00252db:	68 fc 03 00 00       	push   $0x3fc
c00252e0:	e8 73 ff ff ff       	call   c0025258 <outb>
c00252e5:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c00252e8:	83 ec 0c             	sub    $0xc,%esp
c00252eb:	68 40 9d 03 c0       	push   $0xc0039d40
c00252f0:	e8 d6 1b 00 00       	call   c0026ecb <intq_init>
c00252f5:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c00252f8:	c7 05 20 9d 03 c0 01 	movl   $0x1,0xc0039d20
c00252ff:	00 00 00 
} 
c0025302:	90                   	nop
c0025303:	c9                   	leave  
c0025304:	c3                   	ret    

c0025305 <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0025305:	55                   	push   %ebp
c0025306:	89 e5                	mov    %esp,%ebp
c0025308:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c002530b:	a1 20 9d 03 c0       	mov    0xc0039d20,%eax
c0025310:	85 c0                	test   %eax,%eax
c0025312:	75 05                	jne    c0025319 <serial_init_queue+0x14>
    init_poll ();
c0025314:	e8 5c ff ff ff       	call   c0025275 <init_poll>
  ASSERT (mode == POLL);
c0025319:	a1 20 9d 03 c0       	mov    0xc0039d20,%eax
c002531e:	83 f8 01             	cmp    $0x1,%eax
c0025321:	74 1e                	je     c0025341 <serial_init_queue+0x3c>
c0025323:	83 ec 0c             	sub    $0xc,%esp
c0025326:	68 c1 02 03 c0       	push   $0xc00302c1
c002532b:	68 93 02 03 c0       	push   $0xc0030293
c0025330:	68 1c 03 03 c0       	push   $0xc003031c
c0025335:	6a 58                	push   $0x58
c0025337:	68 aa 02 03 c0       	push   $0xc00302aa
c002533c:	e8 e1 4c 00 00       	call   c002a022 <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0025341:	83 ec 04             	sub    $0x4,%esp
c0025344:	68 ce 02 03 c0       	push   $0xc00302ce
c0025349:	68 44 56 02 c0       	push   $0xc0025644
c002534e:	6a 24                	push   $0x24
c0025350:	e8 47 c8 ff ff       	call   c0021b9c <intr_register_ext>
c0025355:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0025358:	c7 05 20 9d 03 c0 02 	movl   $0x2,0xc0039d20
c002535f:	00 00 00 
  old_level = intr_disable ();
c0025362:	e8 16 c6 ff ff       	call   c002197d <intr_disable>
c0025367:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c002536a:	e8 f5 01 00 00       	call   c0025564 <write_ier>
  intr_set_level (old_level);
c002536f:	83 ec 0c             	sub    $0xc,%esp
c0025372:	ff 75 f4             	pushl  -0xc(%ebp)
c0025375:	e8 ab c5 ff ff       	call   c0021925 <intr_set_level>
c002537a:	83 c4 10             	add    $0x10,%esp
}
c002537d:	90                   	nop
c002537e:	c9                   	leave  
c002537f:	c3                   	ret    

c0025380 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0025380:	55                   	push   %ebp
c0025381:	89 e5                	mov    %esp,%ebp
c0025383:	83 ec 28             	sub    $0x28,%esp
c0025386:	8b 45 08             	mov    0x8(%ebp),%eax
c0025389:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c002538c:	e8 ec c5 ff ff       	call   c002197d <intr_disable>
c0025391:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c0025394:	a1 20 9d 03 c0       	mov    0xc0039d20,%eax
c0025399:	83 f8 02             	cmp    $0x2,%eax
c002539c:	74 20                	je     c00253be <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c002539e:	a1 20 9d 03 c0       	mov    0xc0039d20,%eax
c00253a3:	85 c0                	test   %eax,%eax
c00253a5:	75 05                	jne    c00253ac <serial_putc+0x2c>
        init_poll ();
c00253a7:	e8 c9 fe ff ff       	call   c0025275 <init_poll>
      putc_poll (byte); 
c00253ac:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00253b0:	83 ec 0c             	sub    $0xc,%esp
c00253b3:	50                   	push   %eax
c00253b4:	e8 22 02 00 00       	call   c00255db <putc_poll>
c00253b9:	83 c4 10             	add    $0x10,%esp
c00253bc:	eb 53                	jmp    c0025411 <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c00253be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00253c2:	75 33                	jne    c00253f7 <serial_putc+0x77>
c00253c4:	83 ec 0c             	sub    $0xc,%esp
c00253c7:	68 40 9d 03 c0       	push   $0xc0039d40
c00253cc:	e8 7e 1b 00 00       	call   c0026f4f <intq_full>
c00253d1:	83 c4 10             	add    $0x10,%esp
c00253d4:	84 c0                	test   %al,%al
c00253d6:	74 1f                	je     c00253f7 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c00253d8:	83 ec 0c             	sub    $0xc,%esp
c00253db:	68 40 9d 03 c0       	push   $0xc0039d40
c00253e0:	e8 b8 1b 00 00       	call   c0026f9d <intq_getc>
c00253e5:	83 c4 10             	add    $0x10,%esp
c00253e8:	0f b6 c0             	movzbl %al,%eax
c00253eb:	83 ec 0c             	sub    $0xc,%esp
c00253ee:	50                   	push   %eax
c00253ef:	e8 e7 01 00 00       	call   c00255db <putc_poll>
c00253f4:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c00253f7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00253fb:	83 ec 08             	sub    $0x8,%esp
c00253fe:	50                   	push   %eax
c00253ff:	68 40 9d 03 c0       	push   $0xc0039d40
c0025404:	e8 74 1c 00 00       	call   c002707d <intq_putc>
c0025409:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c002540c:	e8 53 01 00 00       	call   c0025564 <write_ier>
    }
  
  intr_set_level (old_level);
c0025411:	83 ec 0c             	sub    $0xc,%esp
c0025414:	ff 75 f4             	pushl  -0xc(%ebp)
c0025417:	e8 09 c5 ff ff       	call   c0021925 <intr_set_level>
c002541c:	83 c4 10             	add    $0x10,%esp
}
c002541f:	90                   	nop
c0025420:	c9                   	leave  
c0025421:	c3                   	ret    

c0025422 <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0025422:	55                   	push   %ebp
c0025423:	89 e5                	mov    %esp,%ebp
c0025425:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0025428:	e8 50 c5 ff ff       	call   c002197d <intr_disable>
c002542d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0025430:	eb 1f                	jmp    c0025451 <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c0025432:	83 ec 0c             	sub    $0xc,%esp
c0025435:	68 40 9d 03 c0       	push   $0xc0039d40
c002543a:	e8 5e 1b 00 00       	call   c0026f9d <intq_getc>
c002543f:	83 c4 10             	add    $0x10,%esp
c0025442:	0f b6 c0             	movzbl %al,%eax
c0025445:	83 ec 0c             	sub    $0xc,%esp
c0025448:	50                   	push   %eax
c0025449:	e8 8d 01 00 00       	call   c00255db <putc_poll>
c002544e:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0025451:	83 ec 0c             	sub    $0xc,%esp
c0025454:	68 40 9d 03 c0       	push   $0xc0039d40
c0025459:	e8 b1 1a 00 00       	call   c0026f0f <intq_empty>
c002545e:	83 c4 10             	add    $0x10,%esp
c0025461:	83 f0 01             	xor    $0x1,%eax
c0025464:	84 c0                	test   %al,%al
c0025466:	75 ca                	jne    c0025432 <serial_flush+0x10>
  intr_set_level (old_level);
c0025468:	83 ec 0c             	sub    $0xc,%esp
c002546b:	ff 75 f4             	pushl  -0xc(%ebp)
c002546e:	e8 b2 c4 ff ff       	call   c0021925 <intr_set_level>
c0025473:	83 c4 10             	add    $0x10,%esp
}
c0025476:	90                   	nop
c0025477:	c9                   	leave  
c0025478:	c3                   	ret    

c0025479 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c0025479:	55                   	push   %ebp
c002547a:	89 e5                	mov    %esp,%ebp
c002547c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c002547f:	e8 84 c4 ff ff       	call   c0021908 <intr_get_level>
c0025484:	85 c0                	test   %eax,%eax
c0025486:	74 21                	je     c00254a9 <serial_notify+0x30>
c0025488:	83 ec 0c             	sub    $0xc,%esp
c002548b:	68 d5 02 03 c0       	push   $0xc00302d5
c0025490:	68 93 02 03 c0       	push   $0xc0030293
c0025495:	68 30 03 03 c0       	push   $0xc0030330
c002549a:	68 96 00 00 00       	push   $0x96
c002549f:	68 aa 02 03 c0       	push   $0xc00302aa
c00254a4:	e8 79 4b 00 00       	call   c002a022 <debug_panic>
  if (mode == QUEUE)
c00254a9:	a1 20 9d 03 c0       	mov    0xc0039d20,%eax
c00254ae:	83 f8 02             	cmp    $0x2,%eax
c00254b1:	75 05                	jne    c00254b8 <serial_notify+0x3f>
    write_ier ();
c00254b3:	e8 ac 00 00 00       	call   c0025564 <write_ier>
}
c00254b8:	90                   	nop
c00254b9:	c9                   	leave  
c00254ba:	c3                   	ret    

c00254bb <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c00254bb:	55                   	push   %ebp
c00254bc:	89 e5                	mov    %esp,%ebp
c00254be:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c00254c1:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c00254c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00254cb:	99                   	cltd   
c00254cc:	f7 7d 08             	idivl  0x8(%ebp)
c00254cf:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c00254d3:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c00254da:	7e 09                	jle    c00254e5 <set_serial+0x2a>
c00254dc:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c00254e3:	7e 21                	jle    c0025506 <set_serial+0x4b>
c00254e5:	83 ec 0c             	sub    $0xc,%esp
c00254e8:	68 f3 02 03 c0       	push   $0xc00302f3
c00254ed:	68 93 02 03 c0       	push   $0xc0030293
c00254f2:	68 40 03 03 c0       	push   $0xc0030340
c00254f7:	68 a2 00 00 00       	push   $0xa2
c00254fc:	68 aa 02 03 c0       	push   $0xc00302aa
c0025501:	e8 1c 4b 00 00       	call   c002a022 <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0025506:	83 ec 08             	sub    $0x8,%esp
c0025509:	68 83 00 00 00       	push   $0x83
c002550e:	68 fb 03 00 00       	push   $0x3fb
c0025513:	e8 40 fd ff ff       	call   c0025258 <outb>
c0025518:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c002551b:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c002551f:	0f b6 c0             	movzbl %al,%eax
c0025522:	83 ec 08             	sub    $0x8,%esp
c0025525:	50                   	push   %eax
c0025526:	68 f8 03 00 00       	push   $0x3f8
c002552b:	e8 28 fd ff ff       	call   c0025258 <outb>
c0025530:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c0025533:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0025537:	66 c1 e8 08          	shr    $0x8,%ax
c002553b:	0f b6 c0             	movzbl %al,%eax
c002553e:	83 ec 08             	sub    $0x8,%esp
c0025541:	50                   	push   %eax
c0025542:	68 f9 03 00 00       	push   $0x3f9
c0025547:	e8 0c fd ff ff       	call   c0025258 <outb>
c002554c:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c002554f:	83 ec 08             	sub    $0x8,%esp
c0025552:	6a 03                	push   $0x3
c0025554:	68 fb 03 00 00       	push   $0x3fb
c0025559:	e8 fa fc ff ff       	call   c0025258 <outb>
c002555e:	83 c4 10             	add    $0x10,%esp
}
c0025561:	90                   	nop
c0025562:	c9                   	leave  
c0025563:	c3                   	ret    

c0025564 <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0025564:	55                   	push   %ebp
c0025565:	89 e5                	mov    %esp,%ebp
c0025567:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c002556a:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c002556e:	e8 95 c3 ff ff       	call   c0021908 <intr_get_level>
c0025573:	85 c0                	test   %eax,%eax
c0025575:	74 21                	je     c0025598 <write_ier+0x34>
c0025577:	83 ec 0c             	sub    $0xc,%esp
c002557a:	68 d5 02 03 c0       	push   $0xc00302d5
c002557f:	68 93 02 03 c0       	push   $0xc0030293
c0025584:	68 4c 03 03 c0       	push   $0xc003034c
c0025589:	68 b5 00 00 00       	push   $0xb5
c002558e:	68 aa 02 03 c0       	push   $0xc00302aa
c0025593:	e8 8a 4a 00 00       	call   c002a022 <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0025598:	83 ec 0c             	sub    $0xc,%esp
c002559b:	68 40 9d 03 c0       	push   $0xc0039d40
c00255a0:	e8 6a 19 00 00       	call   c0026f0f <intq_empty>
c00255a5:	83 c4 10             	add    $0x10,%esp
c00255a8:	83 f0 01             	xor    $0x1,%eax
c00255ab:	84 c0                	test   %al,%al
c00255ad:	74 04                	je     c00255b3 <write_ier+0x4f>
    ier |= IER_XMIT;
c00255af:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c00255b3:	e8 d4 18 00 00       	call   c0026e8c <input_full>
c00255b8:	83 f0 01             	xor    $0x1,%eax
c00255bb:	84 c0                	test   %al,%al
c00255bd:	74 04                	je     c00255c3 <write_ier+0x5f>
    ier |= IER_RECV;
c00255bf:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c00255c3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00255c7:	83 ec 08             	sub    $0x8,%esp
c00255ca:	50                   	push   %eax
c00255cb:	68 f9 03 00 00       	push   $0x3f9
c00255d0:	e8 83 fc ff ff       	call   c0025258 <outb>
c00255d5:	83 c4 10             	add    $0x10,%esp
}
c00255d8:	90                   	nop
c00255d9:	c9                   	leave  
c00255da:	c3                   	ret    

c00255db <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c00255db:	55                   	push   %ebp
c00255dc:	89 e5                	mov    %esp,%ebp
c00255de:	83 ec 18             	sub    $0x18,%esp
c00255e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00255e4:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00255e7:	e8 1c c3 ff ff       	call   c0021908 <intr_get_level>
c00255ec:	85 c0                	test   %eax,%eax
c00255ee:	74 22                	je     c0025612 <putc_poll+0x37>
c00255f0:	83 ec 0c             	sub    $0xc,%esp
c00255f3:	68 d5 02 03 c0       	push   $0xc00302d5
c00255f8:	68 93 02 03 c0       	push   $0xc0030293
c00255fd:	68 58 03 03 c0       	push   $0xc0030358
c0025602:	68 c9 00 00 00       	push   $0xc9
c0025607:	68 aa 02 03 c0       	push   $0xc00302aa
c002560c:	e8 11 4a 00 00       	call   c002a022 <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c0025611:	90                   	nop
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0025612:	83 ec 0c             	sub    $0xc,%esp
c0025615:	68 fd 03 00 00       	push   $0x3fd
c002561a:	e8 1e fc ff ff       	call   c002523d <inb>
c002561f:	83 c4 10             	add    $0x10,%esp
c0025622:	0f b6 c0             	movzbl %al,%eax
c0025625:	83 e0 20             	and    $0x20,%eax
c0025628:	85 c0                	test   %eax,%eax
c002562a:	74 e5                	je     c0025611 <putc_poll+0x36>
  outb (THR_REG, byte);
c002562c:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0025630:	83 ec 08             	sub    $0x8,%esp
c0025633:	50                   	push   %eax
c0025634:	68 f8 03 00 00       	push   $0x3f8
c0025639:	e8 1a fc ff ff       	call   c0025258 <outb>
c002563e:	83 c4 10             	add    $0x10,%esp
}
c0025641:	90                   	nop
c0025642:	c9                   	leave  
c0025643:	c3                   	ret    

c0025644 <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0025644:	55                   	push   %ebp
c0025645:	89 e5                	mov    %esp,%ebp
c0025647:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c002564a:	68 fa 03 00 00       	push   $0x3fa
c002564f:	e8 e9 fb ff ff       	call   c002523d <inb>
c0025654:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0025657:	eb 1c                	jmp    c0025675 <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c0025659:	68 f8 03 00 00       	push   $0x3f8
c002565e:	e8 da fb ff ff       	call   c002523d <inb>
c0025663:	83 c4 04             	add    $0x4,%esp
c0025666:	0f b6 c0             	movzbl %al,%eax
c0025669:	83 ec 0c             	sub    $0xc,%esp
c002566c:	50                   	push   %eax
c002566d:	e8 5c 17 00 00       	call   c0026dce <input_putc>
c0025672:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0025675:	e8 12 18 00 00       	call   c0026e8c <input_full>
c002567a:	83 f0 01             	xor    $0x1,%eax
c002567d:	84 c0                	test   %al,%al
c002567f:	74 40                	je     c00256c1 <serial_interrupt+0x7d>
c0025681:	83 ec 0c             	sub    $0xc,%esp
c0025684:	68 fd 03 00 00       	push   $0x3fd
c0025689:	e8 af fb ff ff       	call   c002523d <inb>
c002568e:	83 c4 10             	add    $0x10,%esp
c0025691:	0f b6 c0             	movzbl %al,%eax
c0025694:	83 e0 01             	and    $0x1,%eax
c0025697:	85 c0                	test   %eax,%eax
c0025699:	75 be                	jne    c0025659 <serial_interrupt+0x15>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c002569b:	eb 24                	jmp    c00256c1 <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c002569d:	83 ec 0c             	sub    $0xc,%esp
c00256a0:	68 40 9d 03 c0       	push   $0xc0039d40
c00256a5:	e8 f3 18 00 00       	call   c0026f9d <intq_getc>
c00256aa:	83 c4 10             	add    $0x10,%esp
c00256ad:	0f b6 c0             	movzbl %al,%eax
c00256b0:	83 ec 08             	sub    $0x8,%esp
c00256b3:	50                   	push   %eax
c00256b4:	68 f8 03 00 00       	push   $0x3f8
c00256b9:	e8 9a fb ff ff       	call   c0025258 <outb>
c00256be:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c00256c1:	83 ec 0c             	sub    $0xc,%esp
c00256c4:	68 40 9d 03 c0       	push   $0xc0039d40
c00256c9:	e8 41 18 00 00       	call   c0026f0f <intq_empty>
c00256ce:	83 c4 10             	add    $0x10,%esp
c00256d1:	83 f0 01             	xor    $0x1,%eax
c00256d4:	84 c0                	test   %al,%al
c00256d6:	74 1a                	je     c00256f2 <serial_interrupt+0xae>
c00256d8:	83 ec 0c             	sub    $0xc,%esp
c00256db:	68 fd 03 00 00       	push   $0x3fd
c00256e0:	e8 58 fb ff ff       	call   c002523d <inb>
c00256e5:	83 c4 10             	add    $0x10,%esp
c00256e8:	0f b6 c0             	movzbl %al,%eax
c00256eb:	83 e0 20             	and    $0x20,%eax
c00256ee:	85 c0                	test   %eax,%eax
c00256f0:	75 ab                	jne    c002569d <serial_interrupt+0x59>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c00256f2:	e8 6d fe ff ff       	call   c0025564 <write_ier>
}
c00256f7:	90                   	nop
c00256f8:	c9                   	leave  
c00256f9:	c3                   	ret    

c00256fa <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c00256fa:	55                   	push   %ebp
c00256fb:	89 e5                	mov    %esp,%ebp
c00256fd:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0025700:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c0025704:	76 1e                	jbe    c0025724 <block_type_name+0x2a>
c0025706:	83 ec 0c             	sub    $0xc,%esp
c0025709:	68 64 03 03 c0       	push   $0xc0030364
c002570e:	68 75 03 03 c0       	push   $0xc0030375
c0025713:	68 7c 04 03 c0       	push   $0xc003047c
c0025718:	6a 2f                	push   $0x2f
c002571a:	68 8c 03 03 c0       	push   $0xc003038c
c002571f:	e8 fe 48 00 00       	call   c002a022 <debug_panic>
  return block_type_names[type];
c0025724:	8b 45 08             	mov    0x8(%ebp),%eax
c0025727:	8b 04 85 9c 7f 03 c0 	mov    -0x3ffc8064(,%eax,4),%eax
}
c002572e:	c9                   	leave  
c002572f:	c3                   	ret    

c0025730 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0025730:	55                   	push   %ebp
c0025731:	89 e5                	mov    %esp,%ebp
c0025733:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0025736:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c002573a:	76 1e                	jbe    c002575a <block_get_role+0x2a>
c002573c:	83 ec 0c             	sub    $0xc,%esp
c002573f:	68 a2 03 03 c0       	push   $0xc00303a2
c0025744:	68 75 03 03 c0       	push   $0xc0030375
c0025749:	68 b4 04 03 c0       	push   $0xc00304b4
c002574e:	6a 38                	push   $0x38
c0025750:	68 8c 03 03 c0       	push   $0xc003038c
c0025755:	e8 c8 48 00 00       	call   c002a022 <debug_panic>
  return block_by_role[role];
c002575a:	8b 45 08             	mov    0x8(%ebp),%eax
c002575d:	8b 04 85 b4 9d 03 c0 	mov    -0x3ffc624c(,%eax,4),%eax
}
c0025764:	c9                   	leave  
c0025765:	c3                   	ret    

c0025766 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0025766:	55                   	push   %ebp
c0025767:	89 e5                	mov    %esp,%ebp
c0025769:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c002576c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0025770:	76 1e                	jbe    c0025790 <block_set_role+0x2a>
c0025772:	83 ec 0c             	sub    $0xc,%esp
c0025775:	68 a2 03 03 c0       	push   $0xc00303a2
c002577a:	68 75 03 03 c0       	push   $0xc0030375
c002577f:	68 c4 04 03 c0       	push   $0xc00304c4
c0025784:	6a 40                	push   $0x40
c0025786:	68 8c 03 03 c0       	push   $0xc003038c
c002578b:	e8 92 48 00 00       	call   c002a022 <debug_panic>
  block_by_role[role] = block;
c0025790:	8b 45 08             	mov    0x8(%ebp),%eax
c0025793:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025796:	89 14 85 b4 9d 03 c0 	mov    %edx,-0x3ffc624c(,%eax,4)
}
c002579d:	90                   	nop
c002579e:	c9                   	leave  
c002579f:	c3                   	ret    

c00257a0 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c00257a0:	55                   	push   %ebp
c00257a1:	89 e5                	mov    %esp,%ebp
c00257a3:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c00257a6:	83 ec 0c             	sub    $0xc,%esp
c00257a9:	68 8c 7f 03 c0       	push   $0xc0037f8c
c00257ae:	e8 35 4b 00 00       	call   c002a2e8 <list_begin>
c00257b3:	83 c4 10             	add    $0x10,%esp
c00257b6:	83 ec 0c             	sub    $0xc,%esp
c00257b9:	50                   	push   %eax
c00257ba:	e8 6a 03 00 00       	call   c0025b29 <list_elem_to_block>
c00257bf:	83 c4 10             	add    $0x10,%esp
}
c00257c2:	c9                   	leave  
c00257c3:	c3                   	ret    

c00257c4 <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c00257c4:	55                   	push   %ebp
c00257c5:	89 e5                	mov    %esp,%ebp
c00257c7:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c00257ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00257cd:	83 ec 0c             	sub    $0xc,%esp
c00257d0:	50                   	push   %eax
c00257d1:	e8 44 4b 00 00       	call   c002a31a <list_next>
c00257d6:	83 c4 10             	add    $0x10,%esp
c00257d9:	83 ec 0c             	sub    $0xc,%esp
c00257dc:	50                   	push   %eax
c00257dd:	e8 47 03 00 00       	call   c0025b29 <list_elem_to_block>
c00257e2:	83 c4 10             	add    $0x10,%esp
}
c00257e5:	c9                   	leave  
c00257e6:	c3                   	ret    

c00257e7 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c00257e7:	55                   	push   %ebp
c00257e8:	89 e5                	mov    %esp,%ebp
c00257ea:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c00257ed:	83 ec 0c             	sub    $0xc,%esp
c00257f0:	68 8c 7f 03 c0       	push   $0xc0037f8c
c00257f5:	e8 ee 4a 00 00       	call   c002a2e8 <list_begin>
c00257fa:	83 c4 10             	add    $0x10,%esp
c00257fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0025800:	eb 3b                	jmp    c002583d <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c0025802:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025805:	83 c0 04             	add    $0x4,%eax
c0025808:	83 e8 04             	sub    $0x4,%eax
c002580b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c002580e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025811:	83 c0 08             	add    $0x8,%eax
c0025814:	83 ec 08             	sub    $0x8,%esp
c0025817:	50                   	push   %eax
c0025818:	ff 75 08             	pushl  0x8(%ebp)
c002581b:	e8 2d 37 00 00       	call   c0028f4d <strcmp>
c0025820:	83 c4 10             	add    $0x10,%esp
c0025823:	85 c0                	test   %eax,%eax
c0025825:	75 05                	jne    c002582c <block_get_by_name+0x45>
        return block;
c0025827:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002582a:	eb 2b                	jmp    c0025857 <block_get_by_name+0x70>
       e = list_next (e))
c002582c:	83 ec 0c             	sub    $0xc,%esp
c002582f:	ff 75 f4             	pushl  -0xc(%ebp)
c0025832:	e8 e3 4a 00 00       	call   c002a31a <list_next>
c0025837:	83 c4 10             	add    $0x10,%esp
c002583a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c002583d:	83 ec 0c             	sub    $0xc,%esp
c0025840:	68 8c 7f 03 c0       	push   $0xc0037f8c
c0025845:	e8 1a 4b 00 00       	call   c002a364 <list_end>
c002584a:	83 c4 10             	add    $0x10,%esp
c002584d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0025850:	75 b0                	jne    c0025802 <block_get_by_name+0x1b>
    }

  return NULL;
c0025852:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025857:	c9                   	leave  
c0025858:	c3                   	ret    

c0025859 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c0025859:	55                   	push   %ebp
c002585a:	89 e5                	mov    %esp,%ebp
c002585c:	53                   	push   %ebx
c002585d:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c0025860:	8b 45 08             	mov    0x8(%ebp),%eax
c0025863:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025866:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025869:	77 32                	ja     c002589d <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c002586b:	8b 45 08             	mov    0x8(%ebp),%eax
c002586e:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0025871:	83 ec 0c             	sub    $0xc,%esp
c0025874:	ff 75 08             	pushl  0x8(%ebp)
c0025877:	e8 fd 00 00 00       	call   c0025979 <block_name>
c002587c:	83 c4 10             	add    $0x10,%esp
c002587f:	83 ec 04             	sub    $0x4,%esp
c0025882:	53                   	push   %ebx
c0025883:	ff 75 0c             	pushl  0xc(%ebp)
c0025886:	50                   	push   %eax
c0025887:	68 b8 03 03 c0       	push   $0xc00303b8
c002588c:	68 d4 04 03 c0       	push   $0xc00304d4
c0025891:	6a 70                	push   $0x70
c0025893:	68 8c 03 03 c0       	push   $0xc003038c
c0025898:	e8 85 47 00 00       	call   c002a022 <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c002589d:	90                   	nop
c002589e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00258a1:	c9                   	leave  
c00258a2:	c3                   	ret    

c00258a3 <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c00258a3:	55                   	push   %ebp
c00258a4:	89 e5                	mov    %esp,%ebp
c00258a6:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c00258a9:	83 ec 08             	sub    $0x8,%esp
c00258ac:	ff 75 0c             	pushl  0xc(%ebp)
c00258af:	ff 75 08             	pushl  0x8(%ebp)
c00258b2:	e8 a2 ff ff ff       	call   c0025859 <check_sector>
c00258b7:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c00258ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00258bd:	8b 40 20             	mov    0x20(%eax),%eax
c00258c0:	8b 00                	mov    (%eax),%eax
c00258c2:	8b 55 08             	mov    0x8(%ebp),%edx
c00258c5:	8b 52 24             	mov    0x24(%edx),%edx
c00258c8:	83 ec 04             	sub    $0x4,%esp
c00258cb:	ff 75 10             	pushl  0x10(%ebp)
c00258ce:	ff 75 0c             	pushl  0xc(%ebp)
c00258d1:	52                   	push   %edx
c00258d2:	ff d0                	call   *%eax
c00258d4:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c00258d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00258da:	8b 50 2c             	mov    0x2c(%eax),%edx
c00258dd:	8b 40 28             	mov    0x28(%eax),%eax
c00258e0:	83 c0 01             	add    $0x1,%eax
c00258e3:	83 d2 00             	adc    $0x0,%edx
c00258e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00258e9:	89 41 28             	mov    %eax,0x28(%ecx)
c00258ec:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c00258ef:	90                   	nop
c00258f0:	c9                   	leave  
c00258f1:	c3                   	ret    

c00258f2 <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c00258f2:	55                   	push   %ebp
c00258f3:	89 e5                	mov    %esp,%ebp
c00258f5:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c00258f8:	83 ec 08             	sub    $0x8,%esp
c00258fb:	ff 75 0c             	pushl  0xc(%ebp)
c00258fe:	ff 75 08             	pushl  0x8(%ebp)
c0025901:	e8 53 ff ff ff       	call   c0025859 <check_sector>
c0025906:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0025909:	8b 45 08             	mov    0x8(%ebp),%eax
c002590c:	8b 40 18             	mov    0x18(%eax),%eax
c002590f:	83 f8 05             	cmp    $0x5,%eax
c0025912:	75 21                	jne    c0025935 <block_write+0x43>
c0025914:	83 ec 0c             	sub    $0xc,%esp
c0025917:	68 eb 03 03 c0       	push   $0xc00303eb
c002591c:	68 75 03 03 c0       	push   $0xc0030375
c0025921:	68 e4 04 03 c0       	push   $0xc00304e4
c0025926:	68 89 00 00 00       	push   $0x89
c002592b:	68 8c 03 03 c0       	push   $0xc003038c
c0025930:	e8 ed 46 00 00       	call   c002a022 <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c0025935:	8b 45 08             	mov    0x8(%ebp),%eax
c0025938:	8b 40 20             	mov    0x20(%eax),%eax
c002593b:	8b 40 04             	mov    0x4(%eax),%eax
c002593e:	8b 55 08             	mov    0x8(%ebp),%edx
c0025941:	8b 52 24             	mov    0x24(%edx),%edx
c0025944:	83 ec 04             	sub    $0x4,%esp
c0025947:	ff 75 10             	pushl  0x10(%ebp)
c002594a:	ff 75 0c             	pushl  0xc(%ebp)
c002594d:	52                   	push   %edx
c002594e:	ff d0                	call   *%eax
c0025950:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c0025953:	8b 45 08             	mov    0x8(%ebp),%eax
c0025956:	8b 50 34             	mov    0x34(%eax),%edx
c0025959:	8b 40 30             	mov    0x30(%eax),%eax
c002595c:	83 c0 01             	add    $0x1,%eax
c002595f:	83 d2 00             	adc    $0x0,%edx
c0025962:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025965:	89 41 30             	mov    %eax,0x30(%ecx)
c0025968:	89 51 34             	mov    %edx,0x34(%ecx)
}
c002596b:	90                   	nop
c002596c:	c9                   	leave  
c002596d:	c3                   	ret    

c002596e <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c002596e:	55                   	push   %ebp
c002596f:	89 e5                	mov    %esp,%ebp
  return block->size;
c0025971:	8b 45 08             	mov    0x8(%ebp),%eax
c0025974:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0025977:	5d                   	pop    %ebp
c0025978:	c3                   	ret    

c0025979 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c0025979:	55                   	push   %ebp
c002597a:	89 e5                	mov    %esp,%ebp
  return block->name;
c002597c:	8b 45 08             	mov    0x8(%ebp),%eax
c002597f:	83 c0 08             	add    $0x8,%eax
}
c0025982:	5d                   	pop    %ebp
c0025983:	c3                   	ret    

c0025984 <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c0025984:	55                   	push   %ebp
c0025985:	89 e5                	mov    %esp,%ebp
  return block->type;
c0025987:	8b 45 08             	mov    0x8(%ebp),%eax
c002598a:	8b 40 18             	mov    0x18(%eax),%eax
}
c002598d:	5d                   	pop    %ebp
c002598e:	c3                   	ret    

c002598f <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c002598f:	55                   	push   %ebp
c0025990:	89 e5                	mov    %esp,%ebp
c0025992:	56                   	push   %esi
c0025993:	53                   	push   %ebx
c0025994:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025997:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002599e:	eb 60                	jmp    c0025a00 <block_print_stats+0x71>
    {
      struct block *block = block_by_role[i];
c00259a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00259a3:	8b 04 85 b4 9d 03 c0 	mov    -0x3ffc624c(,%eax,4),%eax
c00259aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c00259ad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00259b1:	74 4a                	je     c00259fd <block_print_stats+0x6e>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c00259b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00259b6:	8b 50 34             	mov    0x34(%eax),%edx
c00259b9:	8b 40 30             	mov    0x30(%eax),%eax
c00259bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00259bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00259c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00259c5:	8b 58 28             	mov    0x28(%eax),%ebx
c00259c8:	8b 70 2c             	mov    0x2c(%eax),%esi
c00259cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00259ce:	8b 40 18             	mov    0x18(%eax),%eax
c00259d1:	83 ec 0c             	sub    $0xc,%esp
c00259d4:	50                   	push   %eax
c00259d5:	e8 20 fd ff ff       	call   c00256fa <block_type_name>
c00259da:	83 c4 10             	add    $0x10,%esp
                  block->name, block_type_name (block->type),
c00259dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00259e0:	83 c2 08             	add    $0x8,%edx
          printf ("%s (%s): %llu reads, %llu writes\n",
c00259e3:	83 ec 04             	sub    $0x4,%esp
c00259e6:	ff 75 e4             	pushl  -0x1c(%ebp)
c00259e9:	ff 75 e0             	pushl  -0x20(%ebp)
c00259ec:	56                   	push   %esi
c00259ed:	53                   	push   %ebx
c00259ee:	50                   	push   %eax
c00259ef:	52                   	push   %edx
c00259f0:	68 08 04 03 c0       	push   $0xc0030408
c00259f5:	e8 57 21 00 00       	call   c0027b51 <printf>
c00259fa:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c00259fd:	ff 45 f4             	incl   -0xc(%ebp)
c0025a00:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025a04:	7e 9a                	jle    c00259a0 <block_print_stats+0x11>
                  block->read_cnt, block->write_cnt);
        }
    }
}
c0025a06:	90                   	nop
c0025a07:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025a0a:	5b                   	pop    %ebx
c0025a0b:	5e                   	pop    %esi
c0025a0c:	5d                   	pop    %ebp
c0025a0d:	c3                   	ret    

c0025a0e <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0025a0e:	55                   	push   %ebp
c0025a0f:	89 e5                	mov    %esp,%ebp
c0025a11:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c0025a14:	83 ec 0c             	sub    $0xc,%esp
c0025a17:	6a 38                	push   $0x38
c0025a19:	e8 a7 e2 ff ff       	call   c0023cc5 <malloc>
c0025a1e:	83 c4 10             	add    $0x10,%esp
c0025a21:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c0025a24:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0025a28:	75 19                	jne    c0025a43 <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c0025a2a:	68 2c 04 03 c0       	push   $0xc003042c
c0025a2f:	68 f0 04 03 c0       	push   $0xc00304f0
c0025a34:	68 c1 00 00 00       	push   $0xc1
c0025a39:	68 8c 03 03 c0       	push   $0xc003038c
c0025a3e:	e8 df 45 00 00       	call   c002a022 <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c0025a43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a46:	83 ec 08             	sub    $0x8,%esp
c0025a49:	50                   	push   %eax
c0025a4a:	68 8c 7f 03 c0       	push   $0xc0037f8c
c0025a4f:	e8 1f 4c 00 00       	call   c002a673 <list_push_back>
c0025a54:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c0025a57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a5a:	83 c0 08             	add    $0x8,%eax
c0025a5d:	83 ec 04             	sub    $0x4,%esp
c0025a60:	6a 10                	push   $0x10
c0025a62:	ff 75 08             	pushl  0x8(%ebp)
c0025a65:	50                   	push   %eax
c0025a66:	e8 92 39 00 00       	call   c00293fd <strlcpy>
c0025a6b:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c0025a6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a71:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025a74:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c0025a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a7a:	8b 55 14             	mov    0x14(%ebp),%edx
c0025a7d:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c0025a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a83:	8b 55 18             	mov    0x18(%ebp),%edx
c0025a86:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c0025a89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a8c:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0025a8f:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c0025a92:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a95:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0025a9c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c0025aa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025aa6:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c0025aad:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0025ab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ab7:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025aba:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025abd:	83 c2 08             	add    $0x8,%edx
c0025ac0:	83 ec 04             	sub    $0x4,%esp
c0025ac3:	50                   	push   %eax
c0025ac4:	52                   	push   %edx
c0025ac5:	68 62 04 03 c0       	push   $0xc0030462
c0025aca:	e8 82 20 00 00       	call   c0027b51 <printf>
c0025acf:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c0025ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ad5:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025ad8:	ba 00 00 00 00       	mov    $0x0,%edx
c0025add:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0025ae1:	c1 e0 09             	shl    $0x9,%eax
c0025ae4:	83 ec 08             	sub    $0x8,%esp
c0025ae7:	52                   	push   %edx
c0025ae8:	50                   	push   %eax
c0025ae9:	e8 79 2d 00 00       	call   c0028867 <print_human_readable_size>
c0025aee:	83 c4 10             	add    $0x10,%esp
  printf (")");
c0025af1:	83 ec 0c             	sub    $0xc,%esp
c0025af4:	6a 29                	push   $0x29
c0025af6:	e8 6d 67 00 00       	call   c002c268 <putchar>
c0025afb:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c0025afe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025b02:	74 13                	je     c0025b17 <block_register+0x109>
    printf (", %s", extra_info);
c0025b04:	83 ec 08             	sub    $0x8,%esp
c0025b07:	ff 75 10             	pushl  0x10(%ebp)
c0025b0a:	68 74 04 03 c0       	push   $0xc0030474
c0025b0f:	e8 3d 20 00 00       	call   c0027b51 <printf>
c0025b14:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025b17:	83 ec 0c             	sub    $0xc,%esp
c0025b1a:	6a 0a                	push   $0xa
c0025b1c:	e8 47 67 00 00       	call   c002c268 <putchar>
c0025b21:	83 c4 10             	add    $0x10,%esp

  return block;
c0025b24:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0025b27:	c9                   	leave  
c0025b28:	c3                   	ret    

c0025b29 <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c0025b29:	55                   	push   %ebp
c0025b2a:	89 e5                	mov    %esp,%ebp
c0025b2c:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c0025b2f:	83 ec 0c             	sub    $0xc,%esp
c0025b32:	68 8c 7f 03 c0       	push   $0xc0037f8c
c0025b37:	e8 28 48 00 00       	call   c002a364 <list_end>
c0025b3c:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025b3f:	3b 45 08             	cmp    0x8(%ebp),%eax
c0025b42:	74 0b                	je     c0025b4f <list_elem_to_block+0x26>
          ? list_entry (list_elem, struct block, list_elem)
c0025b44:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b47:	83 c0 04             	add    $0x4,%eax
          : NULL);
c0025b4a:	83 e8 04             	sub    $0x4,%eax
c0025b4d:	eb 05                	jmp    c0025b54 <list_elem_to_block+0x2b>
c0025b4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025b54:	c9                   	leave  
c0025b55:	c3                   	ret    

c0025b56 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c0025b56:	55                   	push   %ebp
c0025b57:	89 e5                	mov    %esp,%ebp
c0025b59:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c0025b5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c0025b63:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0025b66:	50                   	push   %eax
c0025b67:	6a 00                	push   $0x0
c0025b69:	6a 00                	push   $0x0
c0025b6b:	ff 75 08             	pushl  0x8(%ebp)
c0025b6e:	e8 2c 00 00 00       	call   c0025b9f <read_partition_table>
c0025b73:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c0025b76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025b79:	85 c0                	test   %eax,%eax
c0025b7b:	75 1f                	jne    c0025b9c <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c0025b7d:	83 ec 0c             	sub    $0xc,%esp
c0025b80:	ff 75 08             	pushl  0x8(%ebp)
c0025b83:	e8 f1 fd ff ff       	call   c0025979 <block_name>
c0025b88:	83 c4 10             	add    $0x10,%esp
c0025b8b:	83 ec 08             	sub    $0x8,%esp
c0025b8e:	50                   	push   %eax
c0025b8f:	68 00 05 03 c0       	push   $0xc0030500
c0025b94:	e8 b8 1f 00 00       	call   c0027b51 <printf>
c0025b99:	83 c4 10             	add    $0x10,%esp
}
c0025b9c:	90                   	nop
c0025b9d:	c9                   	leave  
c0025b9e:	c3                   	ret    

c0025b9f <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c0025b9f:	55                   	push   %ebp
c0025ba0:	89 e5                	mov    %esp,%ebp
c0025ba2:	53                   	push   %ebx
c0025ba3:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c0025ba6:	83 ec 0c             	sub    $0xc,%esp
c0025ba9:	ff 75 08             	pushl  0x8(%ebp)
c0025bac:	e8 bd fd ff ff       	call   c002596e <block_size>
c0025bb1:	83 c4 10             	add    $0x10,%esp
c0025bb4:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025bb7:	77 27                	ja     c0025be0 <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025bb9:	83 ec 0c             	sub    $0xc,%esp
c0025bbc:	ff 75 08             	pushl  0x8(%ebp)
c0025bbf:	e8 b5 fd ff ff       	call   c0025979 <block_name>
c0025bc4:	83 c4 10             	add    $0x10,%esp
c0025bc7:	83 ec 04             	sub    $0x4,%esp
c0025bca:	ff 75 0c             	pushl  0xc(%ebp)
c0025bcd:	50                   	push   %eax
c0025bce:	68 24 05 03 c0       	push   $0xc0030524
c0025bd3:	e8 79 1f 00 00       	call   c0027b51 <printf>
c0025bd8:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c0025bdb:	e9 d2 01 00 00       	jmp    c0025db2 <read_partition_table+0x213>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c0025be0:	83 ec 0c             	sub    $0xc,%esp
c0025be3:	68 00 02 00 00       	push   $0x200
c0025be8:	e8 d8 e0 ff ff       	call   c0023cc5 <malloc>
c0025bed:	83 c4 10             	add    $0x10,%esp
c0025bf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c0025bf3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025bf7:	75 16                	jne    c0025c0f <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c0025bf9:	68 5c 05 03 c0       	push   $0xc003055c
c0025bfe:	68 e4 06 03 c0       	push   $0xc00306e4
c0025c03:	6a 5a                	push   $0x5a
c0025c05:	68 8b 05 03 c0       	push   $0xc003058b
c0025c0a:	e8 13 44 00 00       	call   c002a022 <debug_panic>
  block_read (block, 0, pt);
c0025c0f:	83 ec 04             	sub    $0x4,%esp
c0025c12:	ff 75 f0             	pushl  -0x10(%ebp)
c0025c15:	6a 00                	push   $0x0
c0025c17:	ff 75 08             	pushl  0x8(%ebp)
c0025c1a:	e8 84 fc ff ff       	call   c00258a3 <block_read>
c0025c1f:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c0025c22:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025c25:	66 8b 80 fe 01 00 00 	mov    0x1fe(%eax),%ax
c0025c2c:	66 3d 55 aa          	cmp    $0xaa55,%ax
c0025c30:	74 5c                	je     c0025c8e <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c0025c32:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025c36:	75 21                	jne    c0025c59 <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0025c38:	83 ec 0c             	sub    $0xc,%esp
c0025c3b:	ff 75 08             	pushl  0x8(%ebp)
c0025c3e:	e8 36 fd ff ff       	call   c0025979 <block_name>
c0025c43:	83 c4 10             	add    $0x10,%esp
c0025c46:	83 ec 08             	sub    $0x8,%esp
c0025c49:	50                   	push   %eax
c0025c4a:	68 a8 05 03 c0       	push   $0xc00305a8
c0025c4f:	e8 fd 1e 00 00       	call   c0027b51 <printf>
c0025c54:	83 c4 10             	add    $0x10,%esp
c0025c57:	eb 22                	jmp    c0025c7b <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0025c59:	83 ec 0c             	sub    $0xc,%esp
c0025c5c:	ff 75 08             	pushl  0x8(%ebp)
c0025c5f:	e8 15 fd ff ff       	call   c0025979 <block_name>
c0025c64:	83 c4 10             	add    $0x10,%esp
c0025c67:	83 ec 04             	sub    $0x4,%esp
c0025c6a:	ff 75 0c             	pushl  0xc(%ebp)
c0025c6d:	50                   	push   %eax
c0025c6e:	68 d0 05 03 c0       	push   $0xc00305d0
c0025c73:	e8 d9 1e 00 00       	call   c0027b51 <printf>
c0025c78:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c0025c7b:	83 ec 0c             	sub    $0xc,%esp
c0025c7e:	ff 75 f0             	pushl  -0x10(%ebp)
c0025c81:	e8 4b e3 ff ff       	call   c0023fd1 <free>
c0025c86:	83 c4 10             	add    $0x10,%esp
      return;
c0025c89:	e9 24 01 00 00       	jmp    c0025db2 <read_partition_table+0x213>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025c8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025c95:	e9 00 01 00 00       	jmp    c0025d9a <read_partition_table+0x1fb>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c0025c9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c9d:	83 c0 1b             	add    $0x1b,%eax
c0025ca0:	c1 e0 04             	shl    $0x4,%eax
c0025ca3:	89 c2                	mov    %eax,%edx
c0025ca5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025ca8:	01 d0                	add    %edx,%eax
c0025caa:	83 c0 0e             	add    $0xe,%eax
c0025cad:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c0025cb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025cb3:	8b 40 0c             	mov    0xc(%eax),%eax
c0025cb6:	85 c0                	test   %eax,%eax
c0025cb8:	0f 84 d9 00 00 00    	je     c0025d97 <read_partition_table+0x1f8>
c0025cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025cc1:	8a 40 04             	mov    0x4(%eax),%al
c0025cc4:	84 c0                	test   %al,%al
c0025cc6:	0f 84 cb 00 00 00    	je     c0025d97 <read_partition_table+0x1f8>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c0025ccc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025ccf:	8a 40 04             	mov    0x4(%eax),%al
c0025cd2:	3c 05                	cmp    $0x5,%al
c0025cd4:	74 1e                	je     c0025cf4 <read_partition_table+0x155>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0025cd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025cd9:	8a 40 04             	mov    0x4(%eax),%al
c0025cdc:	3c 0f                	cmp    $0xf,%al
c0025cde:	74 14                	je     c0025cf4 <read_partition_table+0x155>
               || e->type == 0x85    /* Linux extended partition. */
c0025ce0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025ce3:	8a 40 04             	mov    0x4(%eax),%al
c0025ce6:	3c 85                	cmp    $0x85,%al
c0025ce8:	74 0a                	je     c0025cf4 <read_partition_table+0x155>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025cea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025ced:	8a 40 04             	mov    0x4(%eax),%al
c0025cf0:	3c c5                	cmp    $0xc5,%al
c0025cf2:	75 65                	jne    c0025d59 <read_partition_table+0x1ba>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025cf4:	83 ec 0c             	sub    $0xc,%esp
c0025cf7:	ff 75 08             	pushl  0x8(%ebp)
c0025cfa:	e8 7a fc ff ff       	call   c0025979 <block_name>
c0025cff:	83 c4 10             	add    $0x10,%esp
c0025d02:	83 ec 04             	sub    $0x4,%esp
c0025d05:	ff 75 0c             	pushl  0xc(%ebp)
c0025d08:	50                   	push   %eax
c0025d09:	68 04 06 03 c0       	push   $0xc0030604
c0025d0e:	e8 3e 1e 00 00       	call   c0027b51 <printf>
c0025d13:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0025d16:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0025d1a:	75 1e                	jne    c0025d3a <read_partition_table+0x19b>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0025d1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d1f:	8b 50 08             	mov    0x8(%eax),%edx
c0025d22:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d25:	8b 40 08             	mov    0x8(%eax),%eax
c0025d28:	ff 75 14             	pushl  0x14(%ebp)
c0025d2b:	52                   	push   %edx
c0025d2c:	50                   	push   %eax
c0025d2d:	ff 75 08             	pushl  0x8(%ebp)
c0025d30:	e8 6a fe ff ff       	call   c0025b9f <read_partition_table>
c0025d35:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0025d38:	eb 5d                	jmp    c0025d97 <read_partition_table+0x1f8>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c0025d3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d3d:	8b 50 08             	mov    0x8(%eax),%edx
c0025d40:	8b 45 10             	mov    0x10(%ebp),%eax
c0025d43:	01 d0                	add    %edx,%eax
c0025d45:	ff 75 14             	pushl  0x14(%ebp)
c0025d48:	ff 75 10             	pushl  0x10(%ebp)
c0025d4b:	50                   	push   %eax
c0025d4c:	ff 75 08             	pushl  0x8(%ebp)
c0025d4f:	e8 4b fe ff ff       	call   c0025b9f <read_partition_table>
c0025d54:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0025d57:	eb 3e                	jmp    c0025d97 <read_partition_table+0x1f8>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c0025d59:	8b 45 14             	mov    0x14(%ebp),%eax
c0025d5c:	8b 00                	mov    (%eax),%eax
c0025d5e:	8d 50 01             	lea    0x1(%eax),%edx
c0025d61:	8b 45 14             	mov    0x14(%ebp),%eax
c0025d64:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c0025d66:	8b 45 14             	mov    0x14(%ebp),%eax
c0025d69:	8b 08                	mov    (%eax),%ecx
c0025d6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d6e:	8b 50 0c             	mov    0xc(%eax),%edx
c0025d71:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d74:	8b 58 08             	mov    0x8(%eax),%ebx
c0025d77:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025d7a:	01 c3                	add    %eax,%ebx
c0025d7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d7f:	8a 40 04             	mov    0x4(%eax),%al
c0025d82:	0f b6 c0             	movzbl %al,%eax
c0025d85:	83 ec 0c             	sub    $0xc,%esp
c0025d88:	51                   	push   %ecx
c0025d89:	52                   	push   %edx
c0025d8a:	53                   	push   %ebx
c0025d8b:	50                   	push   %eax
c0025d8c:	ff 75 08             	pushl  0x8(%ebp)
c0025d8f:	e8 23 00 00 00       	call   c0025db7 <found_partition>
c0025d94:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025d97:	ff 45 f4             	incl   -0xc(%ebp)
c0025d9a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025d9e:	0f 86 f6 fe ff ff    	jbe    c0025c9a <read_partition_table+0xfb>
                           e->size, *part_nr);
        }
    }

  free (pt);
c0025da4:	83 ec 0c             	sub    $0xc,%esp
c0025da7:	ff 75 f0             	pushl  -0x10(%ebp)
c0025daa:	e8 22 e2 ff ff       	call   c0023fd1 <free>
c0025daf:	83 c4 10             	add    $0x10,%esp
}
c0025db2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025db5:	c9                   	leave  
c0025db6:	c3                   	ret    

c0025db7 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0025db7:	55                   	push   %ebp
c0025db8:	89 e5                	mov    %esp,%ebp
c0025dba:	56                   	push   %esi
c0025dbb:	53                   	push   %ebx
c0025dbc:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c0025dc2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025dc5:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c0025dcb:	83 ec 0c             	sub    $0xc,%esp
c0025dce:	ff 75 08             	pushl  0x8(%ebp)
c0025dd1:	e8 98 fb ff ff       	call   c002596e <block_size>
c0025dd6:	83 c4 10             	add    $0x10,%esp
c0025dd9:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025ddc:	77 27                	ja     c0025e05 <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025dde:	83 ec 0c             	sub    $0xc,%esp
c0025de1:	ff 75 08             	pushl  0x8(%ebp)
c0025de4:	e8 90 fb ff ff       	call   c0025979 <block_name>
c0025de9:	83 c4 10             	add    $0x10,%esp
c0025dec:	ff 75 10             	pushl  0x10(%ebp)
c0025def:	ff 75 18             	pushl  0x18(%ebp)
c0025df2:	50                   	push   %eax
c0025df3:	68 2c 06 03 c0       	push   $0xc003062c
c0025df8:	e8 54 1d 00 00       	call   c0027b51 <printf>
c0025dfd:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025e00:	e9 76 01 00 00       	jmp    c0025f7b <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
c0025e05:	8b 55 10             	mov    0x10(%ebp),%edx
c0025e08:	8b 45 14             	mov    0x14(%ebp),%eax
c0025e0b:	01 d0                	add    %edx,%eax
c0025e0d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025e10:	72 1b                	jb     c0025e2d <found_partition+0x76>
c0025e12:	8b 55 10             	mov    0x10(%ebp),%edx
c0025e15:	8b 45 14             	mov    0x14(%ebp),%eax
c0025e18:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0025e1b:	83 ec 0c             	sub    $0xc,%esp
c0025e1e:	ff 75 08             	pushl  0x8(%ebp)
c0025e21:	e8 48 fb ff ff       	call   c002596e <block_size>
c0025e26:	83 c4 10             	add    $0x10,%esp
c0025e29:	39 c3                	cmp    %eax,%ebx
c0025e2b:	76 42                	jbe    c0025e6f <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025e2d:	83 ec 0c             	sub    $0xc,%esp
c0025e30:	ff 75 08             	pushl  0x8(%ebp)
c0025e33:	e8 36 fb ff ff       	call   c002596e <block_size>
c0025e38:	83 c4 10             	add    $0x10,%esp
c0025e3b:	89 c3                	mov    %eax,%ebx
c0025e3d:	8b 55 10             	mov    0x10(%ebp),%edx
c0025e40:	8b 45 14             	mov    0x14(%ebp),%eax
c0025e43:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0025e46:	83 ec 0c             	sub    $0xc,%esp
c0025e49:	ff 75 08             	pushl  0x8(%ebp)
c0025e4c:	e8 28 fb ff ff       	call   c0025979 <block_name>
c0025e51:	83 c4 10             	add    $0x10,%esp
c0025e54:	83 ec 0c             	sub    $0xc,%esp
c0025e57:	53                   	push   %ebx
c0025e58:	56                   	push   %esi
c0025e59:	ff 75 18             	pushl  0x18(%ebp)
c0025e5c:	50                   	push   %eax
c0025e5d:	68 64 06 03 c0       	push   $0xc0030664
c0025e62:	e8 ea 1c 00 00       	call   c0027b51 <printf>
c0025e67:	83 c4 20             	add    $0x20,%esp
}
c0025e6a:	e9 0c 01 00 00       	jmp    c0025f7b <found_partition+0x1c4>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025e6f:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025e76:	74 37                	je     c0025eaf <found_partition+0xf8>
c0025e78:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c0025e7f:	74 27                	je     c0025ea8 <found_partition+0xf1>
c0025e81:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c0025e88:	74 17                	je     c0025ea1 <found_partition+0xea>
c0025e8a:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c0025e91:	75 07                	jne    c0025e9a <found_partition+0xe3>
c0025e93:	b8 03 00 00 00       	mov    $0x3,%eax
c0025e98:	eb 1a                	jmp    c0025eb4 <found_partition+0xfd>
c0025e9a:	b8 05 00 00 00       	mov    $0x5,%eax
c0025e9f:	eb 13                	jmp    c0025eb4 <found_partition+0xfd>
c0025ea1:	b8 02 00 00 00       	mov    $0x2,%eax
c0025ea6:	eb 0c                	jmp    c0025eb4 <found_partition+0xfd>
c0025ea8:	b8 01 00 00 00       	mov    $0x1,%eax
c0025ead:	eb 05                	jmp    c0025eb4 <found_partition+0xfd>
c0025eaf:	b8 00 00 00 00       	mov    $0x0,%eax
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c0025eb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
      p = malloc (sizeof *p);
c0025eb7:	83 ec 0c             	sub    $0xc,%esp
c0025eba:	6a 08                	push   $0x8
c0025ebc:	e8 04 de ff ff       	call   c0023cc5 <malloc>
c0025ec1:	83 c4 10             	add    $0x10,%esp
c0025ec4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c0025ec7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025ecb:	75 19                	jne    c0025ee6 <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c0025ecd:	68 98 06 03 c0       	push   $0xc0030698
c0025ed2:	68 fc 06 03 c0       	push   $0xc00306fc
c0025ed7:	68 b1 00 00 00       	push   $0xb1
c0025edc:	68 8b 05 03 c0       	push   $0xc003058b
c0025ee1:	e8 3c 41 00 00       	call   c002a022 <debug_panic>
      p->block = block;
c0025ee6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025ee9:	8b 55 08             	mov    0x8(%ebp),%edx
c0025eec:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025eee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025ef1:	8b 55 10             	mov    0x10(%ebp),%edx
c0025ef4:	89 50 04             	mov    %edx,0x4(%eax)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025ef7:	83 ec 0c             	sub    $0xc,%esp
c0025efa:	ff 75 08             	pushl  0x8(%ebp)
c0025efd:	e8 77 fa ff ff       	call   c0025979 <block_name>
c0025f02:	83 c4 10             	add    $0x10,%esp
c0025f05:	83 ec 0c             	sub    $0xc,%esp
c0025f08:	ff 75 18             	pushl  0x18(%ebp)
c0025f0b:	50                   	push   %eax
c0025f0c:	68 cb 06 03 c0       	push   $0xc00306cb
c0025f11:	6a 10                	push   $0x10
c0025f13:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025f16:	50                   	push   %eax
c0025f17:	e8 0c 1c 00 00       	call   c0027b28 <snprintf>
c0025f1c:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025f1f:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c0025f26:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c0025f2d:	83 ec 0c             	sub    $0xc,%esp
c0025f30:	50                   	push   %eax
c0025f31:	e8 4d 00 00 00       	call   c0025f83 <partition_type_name>
c0025f36:	83 c4 10             	add    $0x10,%esp
c0025f39:	83 ec 0c             	sub    $0xc,%esp
c0025f3c:	53                   	push   %ebx
c0025f3d:	50                   	push   %eax
c0025f3e:	68 d0 06 03 c0       	push   $0xc00306d0
c0025f43:	68 80 00 00 00       	push   $0x80
c0025f48:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025f4e:	50                   	push   %eax
c0025f4f:	e8 d4 1b 00 00       	call   c0027b28 <snprintf>
c0025f54:	83 c4 20             	add    $0x20,%esp
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025f57:	83 ec 08             	sub    $0x8,%esp
c0025f5a:	ff 75 f0             	pushl  -0x10(%ebp)
c0025f5d:	68 c0 7f 03 c0       	push   $0xc0037fc0
c0025f62:	ff 75 14             	pushl  0x14(%ebp)
c0025f65:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025f6b:	50                   	push   %eax
c0025f6c:	ff 75 f4             	pushl  -0xc(%ebp)
c0025f6f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025f72:	50                   	push   %eax
c0025f73:	e8 96 fa ff ff       	call   c0025a0e <block_register>
c0025f78:	83 c4 20             	add    $0x20,%esp
}
c0025f7b:	90                   	nop
c0025f7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025f7f:	5b                   	pop    %ebx
c0025f80:	5e                   	pop    %esi
c0025f81:	5d                   	pop    %ebp
c0025f82:	c3                   	ret    

c0025f83 <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c0025f83:	55                   	push   %ebp
c0025f84:	89 e5                	mov    %esp,%ebp
c0025f86:	83 ec 04             	sub    $0x4,%esp
c0025f89:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f8c:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025f8f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025f93:	8b 04 85 e0 7f 03 c0 	mov    -0x3ffc8020(,%eax,4),%eax
c0025f9a:	85 c0                	test   %eax,%eax
c0025f9c:	74 0d                	je     c0025fab <partition_type_name+0x28>
c0025f9e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025fa2:	8b 04 85 e0 7f 03 c0 	mov    -0x3ffc8020(,%eax,4),%eax
c0025fa9:	eb 05                	jmp    c0025fb0 <partition_type_name+0x2d>
c0025fab:	b8 da 06 03 c0       	mov    $0xc00306da,%eax
}
c0025fb0:	c9                   	leave  
c0025fb1:	c3                   	ret    

c0025fb2 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0025fb2:	55                   	push   %ebp
c0025fb3:	89 e5                	mov    %esp,%ebp
c0025fb5:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025fb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c0025fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025fc1:	8b 50 04             	mov    0x4(%eax),%edx
c0025fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025fc7:	01 c2                	add    %eax,%edx
c0025fc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025fcc:	8b 00                	mov    (%eax),%eax
c0025fce:	83 ec 04             	sub    $0x4,%esp
c0025fd1:	ff 75 10             	pushl  0x10(%ebp)
c0025fd4:	52                   	push   %edx
c0025fd5:	50                   	push   %eax
c0025fd6:	e8 c8 f8 ff ff       	call   c00258a3 <block_read>
c0025fdb:	83 c4 10             	add    $0x10,%esp
}
c0025fde:	90                   	nop
c0025fdf:	c9                   	leave  
c0025fe0:	c3                   	ret    

c0025fe1 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0025fe1:	55                   	push   %ebp
c0025fe2:	89 e5                	mov    %esp,%ebp
c0025fe4:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025fe7:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c0025fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ff0:	8b 50 04             	mov    0x4(%eax),%edx
c0025ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025ff6:	01 c2                	add    %eax,%edx
c0025ff8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ffb:	8b 00                	mov    (%eax),%eax
c0025ffd:	83 ec 04             	sub    $0x4,%esp
c0026000:	ff 75 10             	pushl  0x10(%ebp)
c0026003:	52                   	push   %edx
c0026004:	50                   	push   %eax
c0026005:	e8 e8 f8 ff ff       	call   c00258f2 <block_write>
c002600a:	83 c4 10             	add    $0x10,%esp
}
c002600d:	90                   	nop
c002600e:	c9                   	leave  
c002600f:	c3                   	ret    

c0026010 <isspace>:
static inline int isspace (int c) {
c0026010:	55                   	push   %ebp
c0026011:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c0026013:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0026017:	74 1e                	je     c0026037 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0026019:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c002601d:	74 18                	je     c0026037 <isspace+0x27>
c002601f:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0026023:	74 12                	je     c0026037 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0026025:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0026029:	74 0c                	je     c0026037 <isspace+0x27>
c002602b:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c002602f:	74 06                	je     c0026037 <isspace+0x27>
c0026031:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0026035:	75 07                	jne    c002603e <isspace+0x2e>
c0026037:	b8 01 00 00 00       	mov    $0x1,%eax
c002603c:	eb 05                	jmp    c0026043 <isspace+0x33>
c002603e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0026043:	5d                   	pop    %ebp
c0026044:	c3                   	ret    

c0026045 <inb>:
{
c0026045:	55                   	push   %ebp
c0026046:	89 e5                	mov    %esp,%ebp
c0026048:	83 ec 14             	sub    $0x14,%esp
c002604b:	8b 45 08             	mov    0x8(%ebp),%eax
c002604e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026052:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026055:	89 c2                	mov    %eax,%edx
c0026057:	ec                   	in     (%dx),%al
c0026058:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002605b:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c002605e:	c9                   	leave  
c002605f:	c3                   	ret    

c0026060 <insw>:
{
c0026060:	55                   	push   %ebp
c0026061:	89 e5                	mov    %esp,%ebp
c0026063:	57                   	push   %edi
c0026064:	53                   	push   %ebx
c0026065:	83 ec 04             	sub    $0x4,%esp
c0026068:	8b 45 08             	mov    0x8(%ebp),%eax
c002606b:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c002606f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026072:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0026075:	8b 45 10             	mov    0x10(%ebp),%eax
c0026078:	89 cb                	mov    %ecx,%ebx
c002607a:	89 df                	mov    %ebx,%edi
c002607c:	89 c1                	mov    %eax,%ecx
c002607e:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c0026081:	89 c8                	mov    %ecx,%eax
c0026083:	89 fb                	mov    %edi,%ebx
c0026085:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0026088:	89 45 10             	mov    %eax,0x10(%ebp)
}
c002608b:	90                   	nop
c002608c:	83 c4 04             	add    $0x4,%esp
c002608f:	5b                   	pop    %ebx
c0026090:	5f                   	pop    %edi
c0026091:	5d                   	pop    %ebp
c0026092:	c3                   	ret    

c0026093 <outb>:
{
c0026093:	55                   	push   %ebp
c0026094:	89 e5                	mov    %esp,%ebp
c0026096:	83 ec 08             	sub    $0x8,%esp
c0026099:	8b 45 08             	mov    0x8(%ebp),%eax
c002609c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002609f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00260a3:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00260a6:	8a 45 f8             	mov    -0x8(%ebp),%al
c00260a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00260ac:	ee                   	out    %al,(%dx)
}
c00260ad:	90                   	nop
c00260ae:	c9                   	leave  
c00260af:	c3                   	ret    

c00260b0 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c00260b0:	55                   	push   %ebp
c00260b1:	89 e5                	mov    %esp,%ebp
c00260b3:	56                   	push   %esi
c00260b4:	53                   	push   %ebx
c00260b5:	83 ec 04             	sub    $0x4,%esp
c00260b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00260bb:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c00260bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00260c2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00260c5:	8b 45 10             	mov    0x10(%ebp),%eax
c00260c8:	89 cb                	mov    %ecx,%ebx
c00260ca:	89 de                	mov    %ebx,%esi
c00260cc:	89 c1                	mov    %eax,%ecx
c00260ce:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c00260d1:	89 c8                	mov    %ecx,%eax
c00260d3:	89 f3                	mov    %esi,%ebx
c00260d5:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00260d8:	89 45 10             	mov    %eax,0x10(%ebp)
}
c00260db:	90                   	nop
c00260dc:	83 c4 04             	add    $0x4,%esp
c00260df:	5b                   	pop    %ebx
c00260e0:	5e                   	pop    %esi
c00260e1:	5d                   	pop    %ebp
c00260e2:	c3                   	ret    

c00260e3 <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c00260e3:	55                   	push   %ebp
c00260e4:	89 e5                	mov    %esp,%ebp
c00260e6:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00260e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00260f0:	e9 b4 01 00 00       	jmp    c00262a9 <ide_init+0x1c6>
    {
      struct channel *c = &channels[chan_no];
c00260f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00260f8:	89 d0                	mov    %edx,%eax
c00260fa:	01 c0                	add    %eax,%eax
c00260fc:	01 d0                	add    %edx,%eax
c00260fe:	01 c0                	add    %eax,%eax
c0026100:	01 d0                	add    %edx,%eax
c0026102:	c1 e0 04             	shl    $0x4,%eax
c0026105:	05 e0 9d 03 c0       	add    $0xc0039de0,%eax
c002610a:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c002610d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026110:	ff 75 f4             	pushl  -0xc(%ebp)
c0026113:	68 d0 0b 03 c0       	push   $0xc0030bd0
c0026118:	6a 08                	push   $0x8
c002611a:	50                   	push   %eax
c002611b:	e8 08 1a 00 00       	call   c0027b28 <snprintf>
c0026120:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c0026123:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026126:	85 c0                	test   %eax,%eax
c0026128:	74 07                	je     c0026131 <ide_init+0x4e>
c002612a:	83 f8 01             	cmp    $0x1,%eax
c002612d:	74 14                	je     c0026143 <ide_init+0x60>
c002612f:	eb 24                	jmp    c0026155 <ide_init+0x72>
        {
        case 0:
          c->reg_base = 0x1f0;
c0026131:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026134:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c002613a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002613d:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c0026141:	eb 28                	jmp    c002616b <ide_init+0x88>
        case 1:
          c->reg_base = 0x170;
c0026143:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026146:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c002614c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002614f:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c0026153:	eb 16                	jmp    c002616b <ide_init+0x88>
        default:
          NOT_REACHED ();
c0026155:	68 d8 0b 03 c0       	push   $0xc0030bd8
c002615a:	68 2c 0d 03 c0       	push   $0xc0030d2c
c002615f:	6a 7c                	push   $0x7c
c0026161:	68 fa 0b 03 c0       	push   $0xc0030bfa
c0026166:	e8 b7 3e 00 00       	call   c002a022 <debug_panic>
        }
      lock_init (&c->lock);
c002616b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002616e:	83 c0 0c             	add    $0xc,%eax
c0026171:	83 ec 0c             	sub    $0xc,%esp
c0026174:	50                   	push   %eax
c0026175:	e8 e8 ce ff ff       	call   c0023062 <lock_init>
c002617a:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c002617d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026180:	c6 40 30 00          	movb   $0x0,0x30(%eax)
      sema_init (&c->completion_wait, 0);
c0026184:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026187:	83 c0 34             	add    $0x34,%eax
c002618a:	83 ec 08             	sub    $0x8,%esp
c002618d:	6a 00                	push   $0x0
c002618f:	50                   	push   %eax
c0026190:	e8 e7 cb ff ff       	call   c0022d7c <sema_init>
c0026195:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0026198:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002619f:	eb 5a                	jmp    c00261fb <ide_init+0x118>
        {
          struct ata_disk *d = &c->devices[dev_no];
c00261a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00261a4:	89 d0                	mov    %edx,%eax
c00261a6:	c1 e0 02             	shl    $0x2,%eax
c00261a9:	01 d0                	add    %edx,%eax
c00261ab:	c1 e0 02             	shl    $0x2,%eax
c00261ae:	8d 50 40             	lea    0x40(%eax),%edx
c00261b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00261b4:	01 d0                	add    %edx,%eax
c00261b6:	83 c0 08             	add    $0x8,%eax
c00261b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c00261bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261bf:	01 c0                	add    %eax,%eax
c00261c1:	89 c2                	mov    %eax,%edx
c00261c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00261c6:	01 d0                	add    %edx,%eax
          snprintf (d->name, sizeof d->name,
c00261c8:	8d 50 61             	lea    0x61(%eax),%edx
c00261cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00261ce:	52                   	push   %edx
c00261cf:	68 0e 0c 03 c0       	push   $0xc0030c0e
c00261d4:	6a 08                	push   $0x8
c00261d6:	50                   	push   %eax
c00261d7:	e8 4c 19 00 00       	call   c0027b28 <snprintf>
c00261dc:	83 c4 10             	add    $0x10,%esp
          d->channel = c;
c00261df:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00261e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00261e5:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c00261e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00261eb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00261ee:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c00261f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00261f4:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      for (dev_no = 0; dev_no < 2; dev_no++)
c00261f8:	ff 45 f0             	incl   -0x10(%ebp)
c00261fb:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c00261ff:	7e a0                	jle    c00261a1 <ide_init+0xbe>
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0026201:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0026204:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026207:	8a 40 0a             	mov    0xa(%eax),%al
c002620a:	0f b6 c0             	movzbl %al,%eax
c002620d:	83 ec 04             	sub    $0x4,%esp
c0026210:	52                   	push   %edx
c0026211:	68 21 6d 02 c0       	push   $0xc0026d21
c0026216:	50                   	push   %eax
c0026217:	e8 80 b9 ff ff       	call   c0021b9c <intr_register_ext>
c002621c:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c002621f:	83 ec 0c             	sub    $0xc,%esp
c0026222:	ff 75 ec             	pushl  -0x14(%ebp)
c0026225:	e8 8c 00 00 00       	call   c00262b6 <reset_channel>
c002622a:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c002622d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026230:	83 c0 48             	add    $0x48,%eax
c0026233:	83 ec 0c             	sub    $0xc,%esp
c0026236:	50                   	push   %eax
c0026237:	e8 f8 02 00 00       	call   c0026534 <check_device_type>
c002623c:	83 c4 10             	add    $0x10,%esp
c002623f:	84 c0                	test   %al,%al
c0026241:	74 12                	je     c0026255 <ide_init+0x172>
        check_device_type (&c->devices[1]);
c0026243:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026246:	83 c0 5c             	add    $0x5c,%eax
c0026249:	83 ec 0c             	sub    $0xc,%esp
c002624c:	50                   	push   %eax
c002624d:	e8 e2 02 00 00       	call   c0026534 <check_device_type>
c0026252:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0026255:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002625c:	eb 42                	jmp    c00262a0 <ide_init+0x1bd>
        if (c->devices[dev_no].is_ata)
c002625e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0026261:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0026264:	89 d0                	mov    %edx,%eax
c0026266:	c1 e0 02             	shl    $0x2,%eax
c0026269:	01 d0                	add    %edx,%eax
c002626b:	c1 e0 02             	shl    $0x2,%eax
c002626e:	01 c8                	add    %ecx,%eax
c0026270:	83 c0 58             	add    $0x58,%eax
c0026273:	8a 00                	mov    (%eax),%al
c0026275:	84 c0                	test   %al,%al
c0026277:	74 24                	je     c002629d <ide_init+0x1ba>
          identify_ata_device (&c->devices[dev_no]);
c0026279:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002627c:	89 d0                	mov    %edx,%eax
c002627e:	c1 e0 02             	shl    $0x2,%eax
c0026281:	01 d0                	add    %edx,%eax
c0026283:	c1 e0 02             	shl    $0x2,%eax
c0026286:	8d 50 40             	lea    0x40(%eax),%edx
c0026289:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002628c:	01 d0                	add    %edx,%eax
c002628e:	83 c0 08             	add    $0x8,%eax
c0026291:	83 ec 0c             	sub    $0xc,%esp
c0026294:	50                   	push   %eax
c0026295:	e8 8b 03 00 00       	call   c0026625 <identify_ata_device>
c002629a:	83 c4 10             	add    $0x10,%esp
      for (dev_no = 0; dev_no < 2; dev_no++)
c002629d:	ff 45 f0             	incl   -0x10(%ebp)
c00262a0:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c00262a4:	7e b8                	jle    c002625e <ide_init+0x17b>
  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00262a6:	ff 45 f4             	incl   -0xc(%ebp)
c00262a9:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00262ad:	0f 86 42 fe ff ff    	jbe    c00260f5 <ide_init+0x12>
    }
}
c00262b3:	90                   	nop
c00262b4:	c9                   	leave  
c00262b5:	c3                   	ret    

c00262b6 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c00262b6:	55                   	push   %ebp
c00262b7:	89 e5                	mov    %esp,%ebp
c00262b9:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c00262bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00262c3:	e9 22 01 00 00       	jmp    c00263ea <reset_channel+0x134>
    {
      struct ata_disk *d = &c->devices[dev_no];
c00262c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00262cb:	89 d0                	mov    %edx,%eax
c00262cd:	c1 e0 02             	shl    $0x2,%eax
c00262d0:	01 d0                	add    %edx,%eax
c00262d2:	c1 e0 02             	shl    $0x2,%eax
c00262d5:	8d 50 40             	lea    0x40(%eax),%edx
c00262d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00262db:	01 d0                	add    %edx,%eax
c00262dd:	83 c0 08             	add    $0x8,%eax
c00262e0:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c00262e3:	83 ec 0c             	sub    $0xc,%esp
c00262e6:	ff 75 ec             	pushl  -0x14(%ebp)
c00262e9:	e8 98 09 00 00       	call   c0026c86 <select_device>
c00262ee:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c00262f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00262f4:	8b 40 08             	mov    0x8(%eax),%eax
c00262f7:	83 c0 02             	add    $0x2,%eax
c00262fa:	0f b7 c0             	movzwl %ax,%eax
c00262fd:	83 ec 08             	sub    $0x8,%esp
c0026300:	6a 55                	push   $0x55
c0026302:	50                   	push   %eax
c0026303:	e8 8b fd ff ff       	call   c0026093 <outb>
c0026308:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c002630b:	8b 45 08             	mov    0x8(%ebp),%eax
c002630e:	8b 40 08             	mov    0x8(%eax),%eax
c0026311:	83 c0 03             	add    $0x3,%eax
c0026314:	0f b7 c0             	movzwl %ax,%eax
c0026317:	83 ec 08             	sub    $0x8,%esp
c002631a:	68 aa 00 00 00       	push   $0xaa
c002631f:	50                   	push   %eax
c0026320:	e8 6e fd ff ff       	call   c0026093 <outb>
c0026325:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0026328:	8b 45 08             	mov    0x8(%ebp),%eax
c002632b:	8b 40 08             	mov    0x8(%eax),%eax
c002632e:	83 c0 02             	add    $0x2,%eax
c0026331:	0f b7 c0             	movzwl %ax,%eax
c0026334:	83 ec 08             	sub    $0x8,%esp
c0026337:	68 aa 00 00 00       	push   $0xaa
c002633c:	50                   	push   %eax
c002633d:	e8 51 fd ff ff       	call   c0026093 <outb>
c0026342:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0026345:	8b 45 08             	mov    0x8(%ebp),%eax
c0026348:	8b 40 08             	mov    0x8(%eax),%eax
c002634b:	83 c0 03             	add    $0x3,%eax
c002634e:	0f b7 c0             	movzwl %ax,%eax
c0026351:	83 ec 08             	sub    $0x8,%esp
c0026354:	6a 55                	push   $0x55
c0026356:	50                   	push   %eax
c0026357:	e8 37 fd ff ff       	call   c0026093 <outb>
c002635c:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c002635f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026362:	8b 40 08             	mov    0x8(%eax),%eax
c0026365:	83 c0 02             	add    $0x2,%eax
c0026368:	0f b7 c0             	movzwl %ax,%eax
c002636b:	83 ec 08             	sub    $0x8,%esp
c002636e:	6a 55                	push   $0x55
c0026370:	50                   	push   %eax
c0026371:	e8 1d fd ff ff       	call   c0026093 <outb>
c0026376:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0026379:	8b 45 08             	mov    0x8(%ebp),%eax
c002637c:	8b 40 08             	mov    0x8(%eax),%eax
c002637f:	83 c0 03             	add    $0x3,%eax
c0026382:	0f b7 c0             	movzwl %ax,%eax
c0026385:	83 ec 08             	sub    $0x8,%esp
c0026388:	68 aa 00 00 00       	push   $0xaa
c002638d:	50                   	push   %eax
c002638e:	e8 00 fd ff ff       	call   c0026093 <outb>
c0026393:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0026396:	8b 45 08             	mov    0x8(%ebp),%eax
c0026399:	8b 40 08             	mov    0x8(%eax),%eax
c002639c:	83 c0 02             	add    $0x2,%eax
c002639f:	0f b7 c0             	movzwl %ax,%eax
c00263a2:	83 ec 0c             	sub    $0xc,%esp
c00263a5:	50                   	push   %eax
c00263a6:	e8 9a fc ff ff       	call   c0026045 <inb>
c00263ab:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c00263ae:	3c 55                	cmp    $0x55,%al
c00263b0:	75 23                	jne    c00263d5 <reset_channel+0x11f>
c00263b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00263b5:	8b 40 08             	mov    0x8(%eax),%eax
c00263b8:	83 c0 03             	add    $0x3,%eax
c00263bb:	0f b7 c0             	movzwl %ax,%eax
c00263be:	83 ec 0c             	sub    $0xc,%esp
c00263c1:	50                   	push   %eax
c00263c2:	e8 7e fc ff ff       	call   c0026045 <inb>
c00263c7:	83 c4 10             	add    $0x10,%esp
c00263ca:	3c aa                	cmp    $0xaa,%al
c00263cc:	75 07                	jne    c00263d5 <reset_channel+0x11f>
c00263ce:	b8 01 00 00 00       	mov    $0x1,%eax
c00263d3:	eb 05                	jmp    c00263da <reset_channel+0x124>
c00263d5:	b8 00 00 00 00       	mov    $0x0,%eax
c00263da:	83 e0 01             	and    $0x1,%eax
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00263dd:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c00263e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00263e3:	01 ca                	add    %ecx,%edx
c00263e5:	88 02                	mov    %al,(%edx)
  for (dev_no = 0; dev_no < 2; dev_no++)
c00263e7:	ff 45 f4             	incl   -0xc(%ebp)
c00263ea:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00263ee:	0f 8e d4 fe ff ff    	jle    c00262c8 <reset_channel+0x12>
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c00263f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00263f7:	8b 40 08             	mov    0x8(%eax),%eax
c00263fa:	05 06 02 00 00       	add    $0x206,%eax
c00263ff:	0f b7 c0             	movzwl %ax,%eax
c0026402:	83 ec 08             	sub    $0x8,%esp
c0026405:	6a 00                	push   $0x0
c0026407:	50                   	push   %eax
c0026408:	e8 86 fc ff ff       	call   c0026093 <outb>
c002640d:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0026410:	83 ec 08             	sub    $0x8,%esp
c0026413:	6a 00                	push   $0x0
c0026415:	6a 0a                	push   $0xa
c0026417:	e8 4c e2 ff ff       	call   c0024668 <timer_usleep>
c002641c:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c002641f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026422:	8b 40 08             	mov    0x8(%eax),%eax
c0026425:	05 06 02 00 00       	add    $0x206,%eax
c002642a:	0f b7 c0             	movzwl %ax,%eax
c002642d:	83 ec 08             	sub    $0x8,%esp
c0026430:	6a 04                	push   $0x4
c0026432:	50                   	push   %eax
c0026433:	e8 5b fc ff ff       	call   c0026093 <outb>
c0026438:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c002643b:	83 ec 08             	sub    $0x8,%esp
c002643e:	6a 00                	push   $0x0
c0026440:	6a 0a                	push   $0xa
c0026442:	e8 21 e2 ff ff       	call   c0024668 <timer_usleep>
c0026447:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c002644a:	8b 45 08             	mov    0x8(%ebp),%eax
c002644d:	8b 40 08             	mov    0x8(%eax),%eax
c0026450:	05 06 02 00 00       	add    $0x206,%eax
c0026455:	0f b7 c0             	movzwl %ax,%eax
c0026458:	83 ec 08             	sub    $0x8,%esp
c002645b:	6a 00                	push   $0x0
c002645d:	50                   	push   %eax
c002645e:	e8 30 fc ff ff       	call   c0026093 <outb>
c0026463:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0026466:	83 ec 08             	sub    $0x8,%esp
c0026469:	6a 00                	push   $0x0
c002646b:	68 96 00 00 00       	push   $0x96
c0026470:	e8 c8 e1 ff ff       	call   c002463d <timer_msleep>
c0026475:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0026478:	8a 45 ea             	mov    -0x16(%ebp),%al
c002647b:	84 c0                	test   %al,%al
c002647d:	74 24                	je     c00264a3 <reset_channel+0x1ed>
    {
      select_device (&c->devices[0]);
c002647f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026482:	83 c0 48             	add    $0x48,%eax
c0026485:	83 ec 0c             	sub    $0xc,%esp
c0026488:	50                   	push   %eax
c0026489:	e8 f8 07 00 00       	call   c0026c86 <select_device>
c002648e:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0026491:	8b 45 08             	mov    0x8(%ebp),%eax
c0026494:	83 c0 48             	add    $0x48,%eax
c0026497:	83 ec 0c             	sub    $0xc,%esp
c002649a:	50                   	push   %eax
c002649b:	e8 1d 07 00 00       	call   c0026bbd <wait_while_busy>
c00264a0:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c00264a3:	8a 45 eb             	mov    -0x15(%ebp),%al
c00264a6:	84 c0                	test   %al,%al
c00264a8:	0f 84 83 00 00 00    	je     c0026531 <reset_channel+0x27b>
    {
      int i;

      select_device (&c->devices[1]);
c00264ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00264b1:	83 c0 5c             	add    $0x5c,%eax
c00264b4:	83 ec 0c             	sub    $0xc,%esp
c00264b7:	50                   	push   %eax
c00264b8:	e8 c9 07 00 00       	call   c0026c86 <select_device>
c00264bd:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c00264c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00264c7:	eb 4a                	jmp    c0026513 <reset_channel+0x25d>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c00264c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00264cc:	8b 40 08             	mov    0x8(%eax),%eax
c00264cf:	83 c0 02             	add    $0x2,%eax
c00264d2:	0f b7 c0             	movzwl %ax,%eax
c00264d5:	83 ec 0c             	sub    $0xc,%esp
c00264d8:	50                   	push   %eax
c00264d9:	e8 67 fb ff ff       	call   c0026045 <inb>
c00264de:	83 c4 10             	add    $0x10,%esp
c00264e1:	3c 01                	cmp    $0x1,%al
c00264e3:	75 1c                	jne    c0026501 <reset_channel+0x24b>
c00264e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00264e8:	8b 40 08             	mov    0x8(%eax),%eax
c00264eb:	83 c0 03             	add    $0x3,%eax
c00264ee:	0f b7 c0             	movzwl %ax,%eax
c00264f1:	83 ec 0c             	sub    $0xc,%esp
c00264f4:	50                   	push   %eax
c00264f5:	e8 4b fb ff ff       	call   c0026045 <inb>
c00264fa:	83 c4 10             	add    $0x10,%esp
c00264fd:	3c 01                	cmp    $0x1,%al
c00264ff:	74 1d                	je     c002651e <reset_channel+0x268>
            break;
          timer_msleep (10);
c0026501:	83 ec 08             	sub    $0x8,%esp
c0026504:	6a 00                	push   $0x0
c0026506:	6a 0a                	push   $0xa
c0026508:	e8 30 e1 ff ff       	call   c002463d <timer_msleep>
c002650d:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0026510:	ff 45 f0             	incl   -0x10(%ebp)
c0026513:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c002651a:	7e ad                	jle    c00264c9 <reset_channel+0x213>
c002651c:	eb 01                	jmp    c002651f <reset_channel+0x269>
            break;
c002651e:	90                   	nop
        }
      wait_while_busy (&c->devices[1]);
c002651f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026522:	83 c0 5c             	add    $0x5c,%eax
c0026525:	83 ec 0c             	sub    $0xc,%esp
c0026528:	50                   	push   %eax
c0026529:	e8 8f 06 00 00       	call   c0026bbd <wait_while_busy>
c002652e:	83 c4 10             	add    $0x10,%esp
    }
}
c0026531:	90                   	nop
c0026532:	c9                   	leave  
c0026533:	c3                   	ret    

c0026534 <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0026534:	55                   	push   %ebp
c0026535:	89 e5                	mov    %esp,%ebp
c0026537:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c002653a:	8b 45 08             	mov    0x8(%ebp),%eax
c002653d:	8b 40 08             	mov    0x8(%eax),%eax
c0026540:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0026543:	83 ec 0c             	sub    $0xc,%esp
c0026546:	ff 75 08             	pushl  0x8(%ebp)
c0026549:	e8 38 07 00 00       	call   c0026c86 <select_device>
c002654e:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0026551:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026554:	8b 40 08             	mov    0x8(%eax),%eax
c0026557:	40                   	inc    %eax
c0026558:	0f b7 c0             	movzwl %ax,%eax
c002655b:	83 ec 0c             	sub    $0xc,%esp
c002655e:	50                   	push   %eax
c002655f:	e8 e1 fa ff ff       	call   c0026045 <inb>
c0026564:	83 c4 10             	add    $0x10,%esp
c0026567:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c002656a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002656d:	8b 40 08             	mov    0x8(%eax),%eax
c0026570:	83 c0 04             	add    $0x4,%eax
c0026573:	0f b7 c0             	movzwl %ax,%eax
c0026576:	83 ec 0c             	sub    $0xc,%esp
c0026579:	50                   	push   %eax
c002657a:	e8 c6 fa ff ff       	call   c0026045 <inb>
c002657f:	83 c4 10             	add    $0x10,%esp
c0026582:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0026585:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026588:	8b 40 08             	mov    0x8(%eax),%eax
c002658b:	83 c0 05             	add    $0x5,%eax
c002658e:	0f b7 c0             	movzwl %ax,%eax
c0026591:	83 ec 0c             	sub    $0xc,%esp
c0026594:	50                   	push   %eax
c0026595:	e8 ab fa ff ff       	call   c0026045 <inb>
c002659a:	83 c4 10             	add    $0x10,%esp
c002659d:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c00265a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00265a3:	8b 40 08             	mov    0x8(%eax),%eax
c00265a6:	83 c0 07             	add    $0x7,%eax
c00265a9:	0f b7 c0             	movzwl %ax,%eax
c00265ac:	83 ec 0c             	sub    $0xc,%esp
c00265af:	50                   	push   %eax
c00265b0:	e8 90 fa ff ff       	call   c0026045 <inb>
c00265b5:	83 c4 10             	add    $0x10,%esp
c00265b8:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c00265bb:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c00265bf:	74 11                	je     c00265d2 <check_device_type+0x9e>
c00265c1:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c00265c5:	75 1d                	jne    c00265e4 <check_device_type+0xb0>
c00265c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00265ca:	8b 40 0c             	mov    0xc(%eax),%eax
c00265cd:	83 f8 01             	cmp    $0x1,%eax
c00265d0:	74 12                	je     c00265e4 <check_device_type+0xb0>
      || (status & STA_DRDY) == 0
c00265d2:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c00265d6:	83 e0 40             	and    $0x40,%eax
c00265d9:	85 c0                	test   %eax,%eax
c00265db:	74 07                	je     c00265e4 <check_device_type+0xb0>
      || (status & STA_BSY) != 0)
c00265dd:	8a 45 f0             	mov    -0x10(%ebp),%al
c00265e0:	84 c0                	test   %al,%al
c00265e2:	79 10                	jns    c00265f4 <check_device_type+0xc0>
    {
      d->is_ata = false;
c00265e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00265e7:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c00265eb:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c00265ef:	0f 95 c0             	setne  %al
c00265f2:	eb 2f                	jmp    c0026623 <check_device_type+0xef>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c00265f4:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c00265f8:	75 06                	jne    c0026600 <check_device_type+0xcc>
c00265fa:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c00265fe:	74 0c                	je     c002660c <check_device_type+0xd8>
c0026600:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0026604:	75 0d                	jne    c0026613 <check_device_type+0xdf>
c0026606:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c002660a:	75 07                	jne    c0026613 <check_device_type+0xdf>
c002660c:	b8 01 00 00 00       	mov    $0x1,%eax
c0026611:	eb 05                	jmp    c0026618 <check_device_type+0xe4>
c0026613:	b8 00 00 00 00       	mov    $0x0,%eax
c0026618:	83 e0 01             	and    $0x1,%eax
c002661b:	8b 55 08             	mov    0x8(%ebp),%edx
c002661e:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c0026621:	b0 01                	mov    $0x1,%al
    }
}
c0026623:	c9                   	leave  
c0026624:	c3                   	ret    

c0026625 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0026625:	55                   	push   %ebp
c0026626:	89 e5                	mov    %esp,%ebp
c0026628:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c002662e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026631:	8b 40 08             	mov    0x8(%eax),%eax
c0026634:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0026637:	8b 45 08             	mov    0x8(%ebp),%eax
c002663a:	8a 40 10             	mov    0x10(%eax),%al
c002663d:	84 c0                	test   %al,%al
c002663f:	75 21                	jne    c0026662 <identify_ata_device+0x3d>
c0026641:	83 ec 0c             	sub    $0xc,%esp
c0026644:	68 13 0c 03 c0       	push   $0xc0030c13
c0026649:	68 1d 0c 03 c0       	push   $0xc0030c1d
c002664e:	68 38 0d 03 c0       	push   $0xc0030d38
c0026653:	68 0d 01 00 00       	push   $0x10d
c0026658:	68 fa 0b 03 c0       	push   $0xc0030bfa
c002665d:	e8 c0 39 00 00       	call   c002a022 <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0026662:	83 ec 0c             	sub    $0xc,%esp
c0026665:	ff 75 08             	pushl  0x8(%ebp)
c0026668:	e8 81 06 00 00       	call   c0026cee <select_device_wait>
c002666d:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0026670:	83 ec 08             	sub    $0x8,%esp
c0026673:	68 ec 00 00 00       	push   $0xec
c0026678:	ff 75 f4             	pushl  -0xc(%ebp)
c002667b:	e8 38 04 00 00       	call   c0026ab8 <issue_pio_command>
c0026680:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026683:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026686:	83 c0 34             	add    $0x34,%eax
c0026689:	83 ec 0c             	sub    $0xc,%esp
c002668c:	50                   	push   %eax
c002668d:	e8 31 c7 ff ff       	call   c0022dc3 <sema_down>
c0026692:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0026695:	83 ec 0c             	sub    $0xc,%esp
c0026698:	ff 75 08             	pushl  0x8(%ebp)
c002669b:	e8 1d 05 00 00       	call   c0026bbd <wait_while_busy>
c00266a0:	83 c4 10             	add    $0x10,%esp
c00266a3:	83 f0 01             	xor    $0x1,%eax
c00266a6:	84 c0                	test   %al,%al
c00266a8:	74 0c                	je     c00266b6 <identify_ata_device+0x91>
    {
      d->is_ata = false;
c00266aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00266ad:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c00266b1:	e9 fb 00 00 00       	jmp    c00267b1 <identify_ata_device+0x18c>
    }
  input_sector (c, id);
c00266b6:	83 ec 08             	sub    $0x8,%esp
c00266b9:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00266bf:	50                   	push   %eax
c00266c0:	ff 75 f4             	pushl  -0xc(%ebp)
c00266c3:	e8 4e 04 00 00       	call   c0026b16 <input_sector>
c00266c8:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c00266cb:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00266d1:	83 c0 78             	add    $0x78,%eax
c00266d4:	8b 00                	mov    (%eax),%eax
c00266d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c00266d9:	83 ec 08             	sub    $0x8,%esp
c00266dc:	6a 14                	push   $0x14
c00266de:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00266e4:	83 c0 14             	add    $0x14,%eax
c00266e7:	50                   	push   %eax
c00266e8:	e8 c6 00 00 00       	call   c00267b3 <descramble_ata_string>
c00266ed:	83 c4 10             	add    $0x10,%esp
c00266f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c00266f3:	83 ec 08             	sub    $0x8,%esp
c00266f6:	6a 28                	push   $0x28
c00266f8:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00266fe:	83 c0 36             	add    $0x36,%eax
c0026701:	50                   	push   %eax
c0026702:	e8 ac 00 00 00       	call   c00267b3 <descramble_ata_string>
c0026707:	83 c4 10             	add    $0x10,%esp
c002670a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c002670d:	83 ec 0c             	sub    $0xc,%esp
c0026710:	ff 75 e8             	pushl  -0x18(%ebp)
c0026713:	ff 75 ec             	pushl  -0x14(%ebp)
c0026716:	68 34 0c 03 c0       	push   $0xc0030c34
c002671b:	68 80 00 00 00       	push   $0x80
c0026720:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0026726:	50                   	push   %eax
c0026727:	e8 fc 13 00 00       	call   c0027b28 <snprintf>
c002672c:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c002672f:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c0026736:	76 45                	jbe    c002677d <identify_ata_device+0x158>
    {
      printf ("%s: ignoring ", d->name);
c0026738:	8b 45 08             	mov    0x8(%ebp),%eax
c002673b:	83 ec 08             	sub    $0x8,%esp
c002673e:	50                   	push   %eax
c002673f:	68 4c 0c 03 c0       	push   $0xc0030c4c
c0026744:	e8 08 14 00 00       	call   c0027b51 <printf>
c0026749:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c002674c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002674f:	c1 e0 09             	shl    $0x9,%eax
c0026752:	ba 00 00 00 00       	mov    $0x0,%edx
c0026757:	83 ec 08             	sub    $0x8,%esp
c002675a:	52                   	push   %edx
c002675b:	50                   	push   %eax
c002675c:	e8 06 21 00 00       	call   c0028867 <print_human_readable_size>
c0026761:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c0026764:	83 ec 0c             	sub    $0xc,%esp
c0026767:	68 5a 0c 03 c0       	push   $0xc0030c5a
c002676c:	e8 72 5a 00 00       	call   c002c1e3 <puts>
c0026771:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0026774:	8b 45 08             	mov    0x8(%ebp),%eax
c0026777:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c002677b:	eb 34                	jmp    c00267b1 <identify_ata_device+0x18c>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c002677d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026780:	83 ec 08             	sub    $0x8,%esp
c0026783:	ff 75 08             	pushl  0x8(%ebp)
c0026786:	68 e0 83 03 c0       	push   $0xc00383e0
c002678b:	ff 75 f0             	pushl  -0x10(%ebp)
c002678e:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0026794:	52                   	push   %edx
c0026795:	6a 04                	push   $0x4
c0026797:	50                   	push   %eax
c0026798:	e8 71 f2 ff ff       	call   c0025a0e <block_register>
c002679d:	83 c4 20             	add    $0x20,%esp
c00267a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c00267a3:	83 ec 0c             	sub    $0xc,%esp
c00267a6:	ff 75 e4             	pushl  -0x1c(%ebp)
c00267a9:	e8 a8 f3 ff ff       	call   c0025b56 <partition_scan>
c00267ae:	83 c4 10             	add    $0x10,%esp
}
c00267b1:	c9                   	leave  
c00267b2:	c3                   	ret    

c00267b3 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c00267b3:	55                   	push   %ebp
c00267b4:	89 e5                	mov    %esp,%ebp
c00267b6:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c00267b9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00267c0:	eb 38                	jmp    c00267fa <descramble_ata_string+0x47>
    {
      char tmp = string[i];
c00267c2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00267c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00267c8:	01 d0                	add    %edx,%eax
c00267ca:	8a 00                	mov    (%eax),%al
c00267cc:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c00267cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00267d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00267d5:	01 c2                	add    %eax,%edx
c00267d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00267da:	8d 48 01             	lea    0x1(%eax),%ecx
c00267dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00267e0:	01 c8                	add    %ecx,%eax
c00267e2:	8a 00                	mov    (%eax),%al
c00267e4:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c00267e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00267e9:	8d 50 01             	lea    0x1(%eax),%edx
c00267ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00267ef:	01 c2                	add    %eax,%edx
c00267f1:	8a 45 fb             	mov    -0x5(%ebp),%al
c00267f4:	88 02                	mov    %al,(%edx)
  for (i = 0; i + 1 < size; i += 2)
c00267f6:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c00267fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00267fd:	40                   	inc    %eax
c00267fe:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026801:	7c bf                	jl     c00267c2 <descramble_ata_string+0xf>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0026803:	ff 4d 0c             	decl   0xc(%ebp)
c0026806:	eb 2b                	jmp    c0026833 <descramble_ata_string+0x80>
    {
      int c = string[size - 1];
c0026808:	8b 45 0c             	mov    0xc(%ebp),%eax
c002680b:	8d 50 ff             	lea    -0x1(%eax),%edx
c002680e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026811:	01 d0                	add    %edx,%eax
c0026813:	8a 00                	mov    (%eax),%al
c0026815:	0f be c0             	movsbl %al,%eax
c0026818:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c002681b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002681f:	74 0f                	je     c0026830 <descramble_ata_string+0x7d>
c0026821:	ff 75 f4             	pushl  -0xc(%ebp)
c0026824:	e8 e7 f7 ff ff       	call   c0026010 <isspace>
c0026829:	83 c4 04             	add    $0x4,%esp
c002682c:	85 c0                	test   %eax,%eax
c002682e:	74 0b                	je     c002683b <descramble_ata_string+0x88>
  for (size--; size > 0; size--)
c0026830:	ff 4d 0c             	decl   0xc(%ebp)
c0026833:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0026837:	7f cf                	jg     c0026808 <descramble_ata_string+0x55>
c0026839:	eb 01                	jmp    c002683c <descramble_ata_string+0x89>
        break; 
c002683b:	90                   	nop
    }
  string[size] = '\0';
c002683c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002683f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026842:	01 d0                	add    %edx,%eax
c0026844:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0026847:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002684a:	c9                   	leave  
c002684b:	c3                   	ret    

c002684c <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c002684c:	55                   	push   %ebp
c002684d:	89 e5                	mov    %esp,%ebp
c002684f:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0026852:	8b 45 08             	mov    0x8(%ebp),%eax
c0026855:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0026858:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002685b:	8b 40 08             	mov    0x8(%eax),%eax
c002685e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0026861:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026864:	83 c0 0c             	add    $0xc,%eax
c0026867:	83 ec 0c             	sub    $0xc,%esp
c002686a:	50                   	push   %eax
c002686b:	e8 3f c8 ff ff       	call   c00230af <lock_acquire>
c0026870:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0026873:	83 ec 08             	sub    $0x8,%esp
c0026876:	ff 75 0c             	pushl  0xc(%ebp)
c0026879:	ff 75 f4             	pushl  -0xc(%ebp)
c002687c:	e8 3b 01 00 00       	call   c00269bc <select_sector>
c0026881:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0026884:	83 ec 08             	sub    $0x8,%esp
c0026887:	6a 20                	push   $0x20
c0026889:	ff 75 f0             	pushl  -0x10(%ebp)
c002688c:	e8 27 02 00 00       	call   c0026ab8 <issue_pio_command>
c0026891:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026894:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026897:	83 c0 34             	add    $0x34,%eax
c002689a:	83 ec 0c             	sub    $0xc,%esp
c002689d:	50                   	push   %eax
c002689e:	e8 20 c5 ff ff       	call   c0022dc3 <sema_down>
c00268a3:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c00268a6:	83 ec 0c             	sub    $0xc,%esp
c00268a9:	ff 75 f4             	pushl  -0xc(%ebp)
c00268ac:	e8 0c 03 00 00       	call   c0026bbd <wait_while_busy>
c00268b1:	83 c4 10             	add    $0x10,%esp
c00268b4:	83 f0 01             	xor    $0x1,%eax
c00268b7:	84 c0                	test   %al,%al
c00268b9:	74 23                	je     c00268de <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c00268bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00268be:	83 ec 08             	sub    $0x8,%esp
c00268c1:	ff 75 0c             	pushl  0xc(%ebp)
c00268c4:	50                   	push   %eax
c00268c5:	68 6c 0c 03 c0       	push   $0xc0030c6c
c00268ca:	68 4c 0d 03 c0       	push   $0xc0030d4c
c00268cf:	68 62 01 00 00       	push   $0x162
c00268d4:	68 fa 0b 03 c0       	push   $0xc0030bfa
c00268d9:	e8 44 37 00 00       	call   c002a022 <debug_panic>
  input_sector (c, buffer);
c00268de:	83 ec 08             	sub    $0x8,%esp
c00268e1:	ff 75 10             	pushl  0x10(%ebp)
c00268e4:	ff 75 f0             	pushl  -0x10(%ebp)
c00268e7:	e8 2a 02 00 00       	call   c0026b16 <input_sector>
c00268ec:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c00268ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00268f2:	83 c0 0c             	add    $0xc,%eax
c00268f5:	83 ec 0c             	sub    $0xc,%esp
c00268f8:	50                   	push   %eax
c00268f9:	e8 e2 c9 ff ff       	call   c00232e0 <lock_release>
c00268fe:	83 c4 10             	add    $0x10,%esp
}
c0026901:	90                   	nop
c0026902:	c9                   	leave  
c0026903:	c3                   	ret    

c0026904 <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0026904:	55                   	push   %ebp
c0026905:	89 e5                	mov    %esp,%ebp
c0026907:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c002690a:	8b 45 08             	mov    0x8(%ebp),%eax
c002690d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0026910:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026913:	8b 40 08             	mov    0x8(%eax),%eax
c0026916:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0026919:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002691c:	83 c0 0c             	add    $0xc,%eax
c002691f:	83 ec 0c             	sub    $0xc,%esp
c0026922:	50                   	push   %eax
c0026923:	e8 87 c7 ff ff       	call   c00230af <lock_acquire>
c0026928:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c002692b:	83 ec 08             	sub    $0x8,%esp
c002692e:	ff 75 0c             	pushl  0xc(%ebp)
c0026931:	ff 75 f4             	pushl  -0xc(%ebp)
c0026934:	e8 83 00 00 00       	call   c00269bc <select_sector>
c0026939:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c002693c:	83 ec 08             	sub    $0x8,%esp
c002693f:	6a 30                	push   $0x30
c0026941:	ff 75 f0             	pushl  -0x10(%ebp)
c0026944:	e8 6f 01 00 00       	call   c0026ab8 <issue_pio_command>
c0026949:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c002694c:	83 ec 0c             	sub    $0xc,%esp
c002694f:	ff 75 f4             	pushl  -0xc(%ebp)
c0026952:	e8 66 02 00 00       	call   c0026bbd <wait_while_busy>
c0026957:	83 c4 10             	add    $0x10,%esp
c002695a:	83 f0 01             	xor    $0x1,%eax
c002695d:	84 c0                	test   %al,%al
c002695f:	74 23                	je     c0026984 <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0026961:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026964:	83 ec 08             	sub    $0x8,%esp
c0026967:	ff 75 0c             	pushl  0xc(%ebp)
c002696a:	50                   	push   %eax
c002696b:	68 8c 0c 03 c0       	push   $0xc0030c8c
c0026970:	68 58 0d 03 c0       	push   $0xc0030d58
c0026975:	68 75 01 00 00       	push   $0x175
c002697a:	68 fa 0b 03 c0       	push   $0xc0030bfa
c002697f:	e8 9e 36 00 00       	call   c002a022 <debug_panic>
  output_sector (c, buffer);
c0026984:	83 ec 08             	sub    $0x8,%esp
c0026987:	ff 75 10             	pushl  0x10(%ebp)
c002698a:	ff 75 f0             	pushl  -0x10(%ebp)
c002698d:	e8 a4 01 00 00       	call   c0026b36 <output_sector>
c0026992:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026995:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026998:	83 c0 34             	add    $0x34,%eax
c002699b:	83 ec 0c             	sub    $0xc,%esp
c002699e:	50                   	push   %eax
c002699f:	e8 1f c4 ff ff       	call   c0022dc3 <sema_down>
c00269a4:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c00269a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00269aa:	83 c0 0c             	add    $0xc,%eax
c00269ad:	83 ec 0c             	sub    $0xc,%esp
c00269b0:	50                   	push   %eax
c00269b1:	e8 2a c9 ff ff       	call   c00232e0 <lock_release>
c00269b6:	83 c4 10             	add    $0x10,%esp
}
c00269b9:	90                   	nop
c00269ba:	c9                   	leave  
c00269bb:	c3                   	ret    

c00269bc <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c00269bc:	55                   	push   %ebp
c00269bd:	89 e5                	mov    %esp,%ebp
c00269bf:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00269c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00269c5:	8b 40 08             	mov    0x8(%eax),%eax
c00269c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c00269cb:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c00269d2:	76 21                	jbe    c00269f5 <select_sector+0x39>
c00269d4:	83 ec 0c             	sub    $0xc,%esp
c00269d7:	68 ad 0c 03 c0       	push   $0xc0030cad
c00269dc:	68 1d 0c 03 c0       	push   $0xc0030c1d
c00269e1:	68 64 0d 03 c0       	push   $0xc0030d64
c00269e6:	68 89 01 00 00       	push   $0x189
c00269eb:	68 fa 0b 03 c0       	push   $0xc0030bfa
c00269f0:	e8 2d 36 00 00       	call   c002a022 <debug_panic>
  
  select_device_wait (d);
c00269f5:	83 ec 0c             	sub    $0xc,%esp
c00269f8:	ff 75 08             	pushl  0x8(%ebp)
c00269fb:	e8 ee 02 00 00       	call   c0026cee <select_device_wait>
c0026a00:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c0026a03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a06:	8b 40 08             	mov    0x8(%eax),%eax
c0026a09:	83 c0 02             	add    $0x2,%eax
c0026a0c:	0f b7 c0             	movzwl %ax,%eax
c0026a0f:	83 ec 08             	sub    $0x8,%esp
c0026a12:	6a 01                	push   $0x1
c0026a14:	50                   	push   %eax
c0026a15:	e8 79 f6 ff ff       	call   c0026093 <outb>
c0026a1a:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c0026a1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026a20:	0f b6 d0             	movzbl %al,%edx
c0026a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a26:	8b 40 08             	mov    0x8(%eax),%eax
c0026a29:	83 c0 03             	add    $0x3,%eax
c0026a2c:	0f b7 c0             	movzwl %ax,%eax
c0026a2f:	83 ec 08             	sub    $0x8,%esp
c0026a32:	52                   	push   %edx
c0026a33:	50                   	push   %eax
c0026a34:	e8 5a f6 ff ff       	call   c0026093 <outb>
c0026a39:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c0026a3c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026a3f:	c1 e8 08             	shr    $0x8,%eax
c0026a42:	0f b6 d0             	movzbl %al,%edx
c0026a45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a48:	8b 40 08             	mov    0x8(%eax),%eax
c0026a4b:	83 c0 04             	add    $0x4,%eax
c0026a4e:	0f b7 c0             	movzwl %ax,%eax
c0026a51:	83 ec 08             	sub    $0x8,%esp
c0026a54:	52                   	push   %edx
c0026a55:	50                   	push   %eax
c0026a56:	e8 38 f6 ff ff       	call   c0026093 <outb>
c0026a5b:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c0026a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026a61:	c1 e8 10             	shr    $0x10,%eax
c0026a64:	0f b6 d0             	movzbl %al,%edx
c0026a67:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a6a:	8b 40 08             	mov    0x8(%eax),%eax
c0026a6d:	83 c0 05             	add    $0x5,%eax
c0026a70:	0f b7 c0             	movzwl %ax,%eax
c0026a73:	83 ec 08             	sub    $0x8,%esp
c0026a76:	52                   	push   %edx
c0026a77:	50                   	push   %eax
c0026a78:	e8 16 f6 ff ff       	call   c0026093 <outb>
c0026a7d:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0026a80:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a83:	8b 40 0c             	mov    0xc(%eax),%eax
c0026a86:	83 f8 01             	cmp    $0x1,%eax
c0026a89:	75 04                	jne    c0026a8f <select_sector+0xd3>
c0026a8b:	b0 f0                	mov    $0xf0,%al
c0026a8d:	eb 02                	jmp    c0026a91 <select_sector+0xd5>
c0026a8f:	b0 e0                	mov    $0xe0,%al
c0026a91:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026a94:	c1 ea 18             	shr    $0x18,%edx
c0026a97:	09 d0                	or     %edx,%eax
  outb (reg_device (c),
c0026a99:	0f b6 d0             	movzbl %al,%edx
c0026a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a9f:	8b 40 08             	mov    0x8(%eax),%eax
c0026aa2:	83 c0 06             	add    $0x6,%eax
c0026aa5:	0f b7 c0             	movzwl %ax,%eax
c0026aa8:	83 ec 08             	sub    $0x8,%esp
c0026aab:	52                   	push   %edx
c0026aac:	50                   	push   %eax
c0026aad:	e8 e1 f5 ff ff       	call   c0026093 <outb>
c0026ab2:	83 c4 10             	add    $0x10,%esp
}
c0026ab5:	90                   	nop
c0026ab6:	c9                   	leave  
c0026ab7:	c3                   	ret    

c0026ab8 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c0026ab8:	55                   	push   %ebp
c0026ab9:	89 e5                	mov    %esp,%ebp
c0026abb:	83 ec 18             	sub    $0x18,%esp
c0026abe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026ac1:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c0026ac4:	e8 3f ae ff ff       	call   c0021908 <intr_get_level>
c0026ac9:	83 f8 01             	cmp    $0x1,%eax
c0026acc:	74 21                	je     c0026aef <issue_pio_command+0x37>
c0026ace:	83 ec 0c             	sub    $0xc,%esp
c0026ad1:	68 c2 0c 03 c0       	push   $0xc0030cc2
c0026ad6:	68 1d 0c 03 c0       	push   $0xc0030c1d
c0026adb:	68 74 0d 03 c0       	push   $0xc0030d74
c0026ae0:	68 9b 01 00 00       	push   $0x19b
c0026ae5:	68 fa 0b 03 c0       	push   $0xc0030bfa
c0026aea:	e8 33 35 00 00       	call   c002a022 <debug_panic>

  c->expecting_interrupt = true;
c0026aef:	8b 45 08             	mov    0x8(%ebp),%eax
c0026af2:	c6 40 30 01          	movb   $0x1,0x30(%eax)
  outb (reg_command (c), command);
c0026af6:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0026afa:	8b 45 08             	mov    0x8(%ebp),%eax
c0026afd:	8b 40 08             	mov    0x8(%eax),%eax
c0026b00:	83 c0 07             	add    $0x7,%eax
c0026b03:	0f b7 c0             	movzwl %ax,%eax
c0026b06:	83 ec 08             	sub    $0x8,%esp
c0026b09:	52                   	push   %edx
c0026b0a:	50                   	push   %eax
c0026b0b:	e8 83 f5 ff ff       	call   c0026093 <outb>
c0026b10:	83 c4 10             	add    $0x10,%esp
}
c0026b13:	90                   	nop
c0026b14:	c9                   	leave  
c0026b15:	c3                   	ret    

c0026b16 <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c0026b16:	55                   	push   %ebp
c0026b17:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b1c:	8b 40 08             	mov    0x8(%eax),%eax
c0026b1f:	0f b7 c0             	movzwl %ax,%eax
c0026b22:	68 00 01 00 00       	push   $0x100
c0026b27:	ff 75 0c             	pushl  0xc(%ebp)
c0026b2a:	50                   	push   %eax
c0026b2b:	e8 30 f5 ff ff       	call   c0026060 <insw>
c0026b30:	83 c4 0c             	add    $0xc,%esp
}
c0026b33:	90                   	nop
c0026b34:	c9                   	leave  
c0026b35:	c3                   	ret    

c0026b36 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c0026b36:	55                   	push   %ebp
c0026b37:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b3c:	8b 40 08             	mov    0x8(%eax),%eax
c0026b3f:	0f b7 c0             	movzwl %ax,%eax
c0026b42:	68 00 01 00 00       	push   $0x100
c0026b47:	ff 75 0c             	pushl  0xc(%ebp)
c0026b4a:	50                   	push   %eax
c0026b4b:	e8 60 f5 ff ff       	call   c00260b0 <outsw>
c0026b50:	83 c4 0c             	add    $0xc,%esp
}
c0026b53:	90                   	nop
c0026b54:	c9                   	leave  
c0026b55:	c3                   	ret    

c0026b56 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c0026b56:	55                   	push   %ebp
c0026b57:	89 e5                	mov    %esp,%ebp
c0026b59:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c0026b5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026b63:	eb 36                	jmp    c0026b9b <wait_until_idle+0x45>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0026b65:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b68:	8b 40 08             	mov    0x8(%eax),%eax
c0026b6b:	8b 40 08             	mov    0x8(%eax),%eax
c0026b6e:	83 c0 07             	add    $0x7,%eax
c0026b71:	0f b7 c0             	movzwl %ax,%eax
c0026b74:	50                   	push   %eax
c0026b75:	e8 cb f4 ff ff       	call   c0026045 <inb>
c0026b7a:	83 c4 04             	add    $0x4,%esp
c0026b7d:	0f b6 c0             	movzbl %al,%eax
c0026b80:	25 88 00 00 00       	and    $0x88,%eax
c0026b85:	85 c0                	test   %eax,%eax
c0026b87:	74 31                	je     c0026bba <wait_until_idle+0x64>
        return;
      timer_usleep (10);
c0026b89:	83 ec 08             	sub    $0x8,%esp
c0026b8c:	6a 00                	push   $0x0
c0026b8e:	6a 0a                	push   $0xa
c0026b90:	e8 d3 da ff ff       	call   c0024668 <timer_usleep>
c0026b95:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 1000; i++) 
c0026b98:	ff 45 f4             	incl   -0xc(%ebp)
c0026b9b:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c0026ba2:	7e c1                	jle    c0026b65 <wait_until_idle+0xf>
    }

  printf ("%s: idle timeout\n", d->name);
c0026ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ba7:	83 ec 08             	sub    $0x8,%esp
c0026baa:	50                   	push   %eax
c0026bab:	68 df 0c 03 c0       	push   $0xc0030cdf
c0026bb0:	e8 9c 0f 00 00       	call   c0027b51 <printf>
c0026bb5:	83 c4 10             	add    $0x10,%esp
c0026bb8:	eb 01                	jmp    c0026bbb <wait_until_idle+0x65>
        return;
c0026bba:	90                   	nop
}
c0026bbb:	c9                   	leave  
c0026bbc:	c3                   	ret    

c0026bbd <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c0026bbd:	55                   	push   %ebp
c0026bbe:	89 e5                	mov    %esp,%ebp
c0026bc0:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026bc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bc6:	8b 40 08             	mov    0x8(%eax),%eax
c0026bc9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c0026bcc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026bd3:	e9 8d 00 00 00       	jmp    c0026c65 <wait_while_busy+0xa8>
    {
      if (i == 700)
c0026bd8:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c0026bdf:	75 14                	jne    c0026bf5 <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c0026be1:	8b 45 08             	mov    0x8(%ebp),%eax
c0026be4:	83 ec 08             	sub    $0x8,%esp
c0026be7:	50                   	push   %eax
c0026be8:	68 f1 0c 03 c0       	push   $0xc0030cf1
c0026bed:	e8 5f 0f 00 00       	call   c0027b51 <printf>
c0026bf2:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0026bf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026bf8:	8b 40 08             	mov    0x8(%eax),%eax
c0026bfb:	05 06 02 00 00       	add    $0x206,%eax
c0026c00:	0f b7 c0             	movzwl %ax,%eax
c0026c03:	83 ec 0c             	sub    $0xc,%esp
c0026c06:	50                   	push   %eax
c0026c07:	e8 39 f4 ff ff       	call   c0026045 <inb>
c0026c0c:	83 c4 10             	add    $0x10,%esp
c0026c0f:	84 c0                	test   %al,%al
c0026c11:	78 40                	js     c0026c53 <wait_while_busy+0x96>
        {
          if (i >= 700)
c0026c13:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c0026c1a:	7e 10                	jle    c0026c2c <wait_while_busy+0x6f>
            printf ("ok\n");
c0026c1c:	83 ec 0c             	sub    $0xc,%esp
c0026c1f:	68 06 0d 03 c0       	push   $0xc0030d06
c0026c24:	e8 ba 55 00 00       	call   c002c1e3 <puts>
c0026c29:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0026c2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026c2f:	8b 40 08             	mov    0x8(%eax),%eax
c0026c32:	05 06 02 00 00       	add    $0x206,%eax
c0026c37:	0f b7 c0             	movzwl %ax,%eax
c0026c3a:	83 ec 0c             	sub    $0xc,%esp
c0026c3d:	50                   	push   %eax
c0026c3e:	e8 02 f4 ff ff       	call   c0026045 <inb>
c0026c43:	83 c4 10             	add    $0x10,%esp
c0026c46:	0f b6 c0             	movzbl %al,%eax
c0026c49:	83 e0 08             	and    $0x8,%eax
c0026c4c:	85 c0                	test   %eax,%eax
c0026c4e:	0f 95 c0             	setne  %al
c0026c51:	eb 31                	jmp    c0026c84 <wait_while_busy+0xc7>
        }
      timer_msleep (10);
c0026c53:	83 ec 08             	sub    $0x8,%esp
c0026c56:	6a 00                	push   $0x0
c0026c58:	6a 0a                	push   $0xa
c0026c5a:	e8 de d9 ff ff       	call   c002463d <timer_msleep>
c0026c5f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 3000; i++)
c0026c62:	ff 45 f4             	incl   -0xc(%ebp)
c0026c65:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c0026c6c:	0f 8e 66 ff ff ff    	jle    c0026bd8 <wait_while_busy+0x1b>
    }

  printf ("failed\n");
c0026c72:	83 ec 0c             	sub    $0xc,%esp
c0026c75:	68 09 0d 03 c0       	push   $0xc0030d09
c0026c7a:	e8 64 55 00 00       	call   c002c1e3 <puts>
c0026c7f:	83 c4 10             	add    $0x10,%esp
  return false;
c0026c82:	b0 00                	mov    $0x0,%al
}
c0026c84:	c9                   	leave  
c0026c85:	c3                   	ret    

c0026c86 <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c0026c86:	55                   	push   %ebp
c0026c87:	89 e5                	mov    %esp,%ebp
c0026c89:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026c8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c8f:	8b 40 08             	mov    0x8(%eax),%eax
c0026c92:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c0026c95:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c0026c99:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c9c:	8b 40 0c             	mov    0xc(%eax),%eax
c0026c9f:	83 f8 01             	cmp    $0x1,%eax
c0026ca2:	75 04                	jne    c0026ca8 <select_device+0x22>
    dev |= DEV_DEV;
c0026ca4:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c0026ca8:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0026cac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026caf:	8b 40 08             	mov    0x8(%eax),%eax
c0026cb2:	83 c0 06             	add    $0x6,%eax
c0026cb5:	0f b7 c0             	movzwl %ax,%eax
c0026cb8:	52                   	push   %edx
c0026cb9:	50                   	push   %eax
c0026cba:	e8 d4 f3 ff ff       	call   c0026093 <outb>
c0026cbf:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c0026cc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026cc5:	8b 40 08             	mov    0x8(%eax),%eax
c0026cc8:	05 06 02 00 00       	add    $0x206,%eax
c0026ccd:	0f b7 c0             	movzwl %ax,%eax
c0026cd0:	50                   	push   %eax
c0026cd1:	e8 6f f3 ff ff       	call   c0026045 <inb>
c0026cd6:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0026cd9:	83 ec 08             	sub    $0x8,%esp
c0026cdc:	6a 00                	push   $0x0
c0026cde:	68 90 01 00 00       	push   $0x190
c0026ce3:	e8 ab d9 ff ff       	call   c0024693 <timer_nsleep>
c0026ce8:	83 c4 10             	add    $0x10,%esp
}
c0026ceb:	90                   	nop
c0026cec:	c9                   	leave  
c0026ced:	c3                   	ret    

c0026cee <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c0026cee:	55                   	push   %ebp
c0026cef:	89 e5                	mov    %esp,%ebp
c0026cf1:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c0026cf4:	83 ec 0c             	sub    $0xc,%esp
c0026cf7:	ff 75 08             	pushl  0x8(%ebp)
c0026cfa:	e8 57 fe ff ff       	call   c0026b56 <wait_until_idle>
c0026cff:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c0026d02:	83 ec 0c             	sub    $0xc,%esp
c0026d05:	ff 75 08             	pushl  0x8(%ebp)
c0026d08:	e8 79 ff ff ff       	call   c0026c86 <select_device>
c0026d0d:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c0026d10:	83 ec 0c             	sub    $0xc,%esp
c0026d13:	ff 75 08             	pushl  0x8(%ebp)
c0026d16:	e8 3b fe ff ff       	call   c0026b56 <wait_until_idle>
c0026d1b:	83 c4 10             	add    $0x10,%esp
}
c0026d1e:	90                   	nop
c0026d1f:	c9                   	leave  
c0026d20:	c3                   	ret    

c0026d21 <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0026d21:	55                   	push   %ebp
c0026d22:	89 e5                	mov    %esp,%ebp
c0026d24:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026d27:	c7 45 f4 e0 9d 03 c0 	movl   $0xc0039de0,-0xc(%ebp)
c0026d2e:	eb 60                	jmp    c0026d90 <interrupt_handler+0x6f>
    if (f->vec_no == c->irq)
c0026d30:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d33:	8b 50 30             	mov    0x30(%eax),%edx
c0026d36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d39:	8a 40 0a             	mov    0xa(%eax),%al
c0026d3c:	0f b6 c0             	movzbl %al,%eax
c0026d3f:	39 c2                	cmp    %eax,%edx
c0026d41:	75 49                	jne    c0026d8c <interrupt_handler+0x6b>
      {
        if (c->expecting_interrupt) 
c0026d43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d46:	8a 40 30             	mov    0x30(%eax),%al
c0026d49:	84 c0                	test   %al,%al
c0026d4b:	74 29                	je     c0026d76 <interrupt_handler+0x55>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0026d4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d50:	8b 40 08             	mov    0x8(%eax),%eax
c0026d53:	83 c0 07             	add    $0x7,%eax
c0026d56:	0f b7 c0             	movzwl %ax,%eax
c0026d59:	50                   	push   %eax
c0026d5a:	e8 e6 f2 ff ff       	call   c0026045 <inb>
c0026d5f:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0026d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d65:	83 c0 34             	add    $0x34,%eax
c0026d68:	83 ec 0c             	sub    $0xc,%esp
c0026d6b:	50                   	push   %eax
c0026d6c:	e8 60 c1 ff ff       	call   c0022ed1 <sema_up>
c0026d71:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c0026d74:	eb 3d                	jmp    c0026db3 <interrupt_handler+0x92>
          printf ("%s: unexpected interrupt\n", c->name);
c0026d76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d79:	83 ec 08             	sub    $0x8,%esp
c0026d7c:	50                   	push   %eax
c0026d7d:	68 10 0d 03 c0       	push   $0xc0030d10
c0026d82:	e8 ca 0d 00 00       	call   c0027b51 <printf>
c0026d87:	83 c4 10             	add    $0x10,%esp
        return;
c0026d8a:	eb 27                	jmp    c0026db3 <interrupt_handler+0x92>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026d8c:	83 45 f4 70          	addl   $0x70,-0xc(%ebp)
c0026d90:	b8 c0 9e 03 c0       	mov    $0xc0039ec0,%eax
c0026d95:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0026d98:	72 96                	jb     c0026d30 <interrupt_handler+0xf>
      }

  NOT_REACHED ();
c0026d9a:	68 d8 0b 03 c0       	push   $0xc0030bd8
c0026d9f:	68 88 0d 03 c0       	push   $0xc0030d88
c0026da4:	68 0c 02 00 00       	push   $0x20c
c0026da9:	68 fa 0b 03 c0       	push   $0xc0030bfa
c0026dae:	e8 6f 32 00 00       	call   c002a022 <debug_panic>
}
c0026db3:	c9                   	leave  
c0026db4:	c3                   	ret    

c0026db5 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0026db5:	55                   	push   %ebp
c0026db6:	89 e5                	mov    %esp,%ebp
c0026db8:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c0026dbb:	83 ec 0c             	sub    $0xc,%esp
c0026dbe:	68 c0 9e 03 c0       	push   $0xc0039ec0
c0026dc3:	e8 03 01 00 00       	call   c0026ecb <intq_init>
c0026dc8:	83 c4 10             	add    $0x10,%esp
}
c0026dcb:	90                   	nop
c0026dcc:	c9                   	leave  
c0026dcd:	c3                   	ret    

c0026dce <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0026dce:	55                   	push   %ebp
c0026dcf:	89 e5                	mov    %esp,%ebp
c0026dd1:	83 ec 18             	sub    $0x18,%esp
c0026dd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026dd7:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026dda:	e8 29 ab ff ff       	call   c0021908 <intr_get_level>
c0026ddf:	85 c0                	test   %eax,%eax
c0026de1:	74 1e                	je     c0026e01 <input_putc+0x33>
c0026de3:	83 ec 0c             	sub    $0xc,%esp
c0026de6:	68 9c 0d 03 c0       	push   $0xc0030d9c
c0026deb:	68 ba 0d 03 c0       	push   $0xc0030dba
c0026df0:	68 fc 0d 03 c0       	push   $0xc0030dfc
c0026df5:	6a 15                	push   $0x15
c0026df7:	68 d1 0d 03 c0       	push   $0xc0030dd1
c0026dfc:	e8 21 32 00 00       	call   c002a022 <debug_panic>
  ASSERT (!intq_full (&buffer));
c0026e01:	83 ec 0c             	sub    $0xc,%esp
c0026e04:	68 c0 9e 03 c0       	push   $0xc0039ec0
c0026e09:	e8 41 01 00 00       	call   c0026f4f <intq_full>
c0026e0e:	83 c4 10             	add    $0x10,%esp
c0026e11:	83 f0 01             	xor    $0x1,%eax
c0026e14:	84 c0                	test   %al,%al
c0026e16:	75 1e                	jne    c0026e36 <input_putc+0x68>
c0026e18:	83 ec 0c             	sub    $0xc,%esp
c0026e1b:	68 e7 0d 03 c0       	push   $0xc0030de7
c0026e20:	68 ba 0d 03 c0       	push   $0xc0030dba
c0026e25:	68 fc 0d 03 c0       	push   $0xc0030dfc
c0026e2a:	6a 16                	push   $0x16
c0026e2c:	68 d1 0d 03 c0       	push   $0xc0030dd1
c0026e31:	e8 ec 31 00 00       	call   c002a022 <debug_panic>

  intq_putc (&buffer, key);
c0026e36:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026e3a:	83 ec 08             	sub    $0x8,%esp
c0026e3d:	50                   	push   %eax
c0026e3e:	68 c0 9e 03 c0       	push   $0xc0039ec0
c0026e43:	e8 35 02 00 00       	call   c002707d <intq_putc>
c0026e48:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0026e4b:	e8 29 e6 ff ff       	call   c0025479 <serial_notify>
}
c0026e50:	90                   	nop
c0026e51:	c9                   	leave  
c0026e52:	c3                   	ret    

c0026e53 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0026e53:	55                   	push   %ebp
c0026e54:	89 e5                	mov    %esp,%ebp
c0026e56:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0026e59:	e8 1f ab ff ff       	call   c002197d <intr_disable>
c0026e5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c0026e61:	83 ec 0c             	sub    $0xc,%esp
c0026e64:	68 c0 9e 03 c0       	push   $0xc0039ec0
c0026e69:	e8 2f 01 00 00       	call   c0026f9d <intq_getc>
c0026e6e:	83 c4 10             	add    $0x10,%esp
c0026e71:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c0026e74:	e8 00 e6 ff ff       	call   c0025479 <serial_notify>
  intr_set_level (old_level);
c0026e79:	83 ec 0c             	sub    $0xc,%esp
c0026e7c:	ff 75 f4             	pushl  -0xc(%ebp)
c0026e7f:	e8 a1 aa ff ff       	call   c0021925 <intr_set_level>
c0026e84:	83 c4 10             	add    $0x10,%esp
  
  return key;
c0026e87:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c0026e8a:	c9                   	leave  
c0026e8b:	c3                   	ret    

c0026e8c <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0026e8c:	55                   	push   %ebp
c0026e8d:	89 e5                	mov    %esp,%ebp
c0026e8f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026e92:	e8 71 aa ff ff       	call   c0021908 <intr_get_level>
c0026e97:	85 c0                	test   %eax,%eax
c0026e99:	74 1e                	je     c0026eb9 <input_full+0x2d>
c0026e9b:	83 ec 0c             	sub    $0xc,%esp
c0026e9e:	68 9c 0d 03 c0       	push   $0xc0030d9c
c0026ea3:	68 ba 0d 03 c0       	push   $0xc0030dba
c0026ea8:	68 08 0e 03 c0       	push   $0xc0030e08
c0026ead:	6a 32                	push   $0x32
c0026eaf:	68 d1 0d 03 c0       	push   $0xc0030dd1
c0026eb4:	e8 69 31 00 00       	call   c002a022 <debug_panic>
  return intq_full (&buffer);
c0026eb9:	83 ec 0c             	sub    $0xc,%esp
c0026ebc:	68 c0 9e 03 c0       	push   $0xc0039ec0
c0026ec1:	e8 89 00 00 00       	call   c0026f4f <intq_full>
c0026ec6:	83 c4 10             	add    $0x10,%esp
}
c0026ec9:	c9                   	leave  
c0026eca:	c3                   	ret    

c0026ecb <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0026ecb:	55                   	push   %ebp
c0026ecc:	89 e5                	mov    %esp,%ebp
c0026ece:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c0026ed1:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ed4:	83 ec 0c             	sub    $0xc,%esp
c0026ed7:	50                   	push   %eax
c0026ed8:	e8 85 c1 ff ff       	call   c0023062 <lock_init>
c0026edd:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c0026ee0:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ee3:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0026eea:	8b 45 08             	mov    0x8(%ebp),%eax
c0026eed:	8b 50 28             	mov    0x28(%eax),%edx
c0026ef0:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ef3:	89 50 24             	mov    %edx,0x24(%eax)
  q->head = q->tail = 0;
c0026ef6:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ef9:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
c0026f00:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f03:	8b 50 70             	mov    0x70(%eax),%edx
c0026f06:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f09:	89 50 6c             	mov    %edx,0x6c(%eax)
}
c0026f0c:	90                   	nop
c0026f0d:	c9                   	leave  
c0026f0e:	c3                   	ret    

c0026f0f <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0026f0f:	55                   	push   %ebp
c0026f10:	89 e5                	mov    %esp,%ebp
c0026f12:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026f15:	e8 ee a9 ff ff       	call   c0021908 <intr_get_level>
c0026f1a:	85 c0                	test   %eax,%eax
c0026f1c:	74 1e                	je     c0026f3c <intq_empty+0x2d>
c0026f1e:	83 ec 0c             	sub    $0xc,%esp
c0026f21:	68 14 0e 03 c0       	push   $0xc0030e14
c0026f26:	68 32 0e 03 c0       	push   $0xc0030e32
c0026f2b:	68 28 0f 03 c0       	push   $0xc0030f28
c0026f30:	6a 16                	push   $0x16
c0026f32:	68 49 0e 03 c0       	push   $0xc0030e49
c0026f37:	e8 e6 30 00 00       	call   c002a022 <debug_panic>
  return q->head == q->tail;
c0026f3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f3f:	8b 50 6c             	mov    0x6c(%eax),%edx
c0026f42:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f45:	8b 40 70             	mov    0x70(%eax),%eax
c0026f48:	39 c2                	cmp    %eax,%edx
c0026f4a:	0f 94 c0             	sete   %al
}
c0026f4d:	c9                   	leave  
c0026f4e:	c3                   	ret    

c0026f4f <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0026f4f:	55                   	push   %ebp
c0026f50:	89 e5                	mov    %esp,%ebp
c0026f52:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026f55:	e8 ae a9 ff ff       	call   c0021908 <intr_get_level>
c0026f5a:	85 c0                	test   %eax,%eax
c0026f5c:	74 1e                	je     c0026f7c <intq_full+0x2d>
c0026f5e:	83 ec 0c             	sub    $0xc,%esp
c0026f61:	68 14 0e 03 c0       	push   $0xc0030e14
c0026f66:	68 32 0e 03 c0       	push   $0xc0030e32
c0026f6b:	68 34 0f 03 c0       	push   $0xc0030f34
c0026f70:	6a 1e                	push   $0x1e
c0026f72:	68 49 0e 03 c0       	push   $0xc0030e49
c0026f77:	e8 a6 30 00 00       	call   c002a022 <debug_panic>
  return next (q->head) == q->tail;
c0026f7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f7f:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026f82:	83 ec 0c             	sub    $0xc,%esp
c0026f85:	50                   	push   %eax
c0026f86:	e8 d6 01 00 00       	call   c0027161 <next>
c0026f8b:	83 c4 10             	add    $0x10,%esp
c0026f8e:	89 c2                	mov    %eax,%edx
c0026f90:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f93:	8b 40 70             	mov    0x70(%eax),%eax
c0026f96:	39 c2                	cmp    %eax,%edx
c0026f98:	0f 94 c0             	sete   %al
}
c0026f9b:	c9                   	leave  
c0026f9c:	c3                   	ret    

c0026f9d <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c0026f9d:	55                   	push   %ebp
c0026f9e:	89 e5                	mov    %esp,%ebp
c0026fa0:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c0026fa3:	e8 60 a9 ff ff       	call   c0021908 <intr_get_level>
c0026fa8:	85 c0                	test   %eax,%eax
c0026faa:	74 7b                	je     c0027027 <intq_getc+0x8a>
c0026fac:	83 ec 0c             	sub    $0xc,%esp
c0026faf:	68 14 0e 03 c0       	push   $0xc0030e14
c0026fb4:	68 32 0e 03 c0       	push   $0xc0030e32
c0026fb9:	68 40 0f 03 c0       	push   $0xc0030f40
c0026fbe:	6a 2a                	push   $0x2a
c0026fc0:	68 49 0e 03 c0       	push   $0xc0030e49
c0026fc5:	e8 58 30 00 00       	call   c002a022 <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c0026fca:	e8 7b ac ff ff       	call   c0021c4a <intr_context>
c0026fcf:	83 f0 01             	xor    $0x1,%eax
c0026fd2:	84 c0                	test   %al,%al
c0026fd4:	75 1e                	jne    c0026ff4 <intq_getc+0x57>
c0026fd6:	83 ec 0c             	sub    $0xc,%esp
c0026fd9:	68 5e 0e 03 c0       	push   $0xc0030e5e
c0026fde:	68 32 0e 03 c0       	push   $0xc0030e32
c0026fe3:	68 40 0f 03 c0       	push   $0xc0030f40
c0026fe8:	6a 2d                	push   $0x2d
c0026fea:	68 49 0e 03 c0       	push   $0xc0030e49
c0026fef:	e8 2e 30 00 00       	call   c002a022 <debug_panic>
      lock_acquire (&q->lock);
c0026ff4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ff7:	83 ec 0c             	sub    $0xc,%esp
c0026ffa:	50                   	push   %eax
c0026ffb:	e8 af c0 ff ff       	call   c00230af <lock_acquire>
c0027000:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c0027003:	8b 45 08             	mov    0x8(%ebp),%eax
c0027006:	83 c0 28             	add    $0x28,%eax
c0027009:	83 ec 08             	sub    $0x8,%esp
c002700c:	50                   	push   %eax
c002700d:	ff 75 08             	pushl  0x8(%ebp)
c0027010:	e8 63 01 00 00       	call   c0027178 <wait>
c0027015:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0027018:	8b 45 08             	mov    0x8(%ebp),%eax
c002701b:	83 ec 0c             	sub    $0xc,%esp
c002701e:	50                   	push   %eax
c002701f:	e8 bc c2 ff ff       	call   c00232e0 <lock_release>
c0027024:	83 c4 10             	add    $0x10,%esp
  while (intq_empty (q)) 
c0027027:	83 ec 0c             	sub    $0xc,%esp
c002702a:	ff 75 08             	pushl  0x8(%ebp)
c002702d:	e8 dd fe ff ff       	call   c0026f0f <intq_empty>
c0027032:	83 c4 10             	add    $0x10,%esp
c0027035:	84 c0                	test   %al,%al
c0027037:	75 91                	jne    c0026fca <intq_getc+0x2d>
    }
  
  byte = q->buf[q->tail];
c0027039:	8b 45 08             	mov    0x8(%ebp),%eax
c002703c:	8b 40 70             	mov    0x70(%eax),%eax
c002703f:	8b 55 08             	mov    0x8(%ebp),%edx
c0027042:	8a 44 02 2c          	mov    0x2c(%edx,%eax,1),%al
c0027046:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0027049:	8b 45 08             	mov    0x8(%ebp),%eax
c002704c:	8b 40 70             	mov    0x70(%eax),%eax
c002704f:	83 ec 0c             	sub    $0xc,%esp
c0027052:	50                   	push   %eax
c0027053:	e8 09 01 00 00       	call   c0027161 <next>
c0027058:	83 c4 10             	add    $0x10,%esp
c002705b:	89 c2                	mov    %eax,%edx
c002705d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027060:	89 50 70             	mov    %edx,0x70(%eax)
  signal (q, &q->not_full);
c0027063:	8b 45 08             	mov    0x8(%ebp),%eax
c0027066:	83 c0 24             	add    $0x24,%eax
c0027069:	83 ec 08             	sub    $0x8,%esp
c002706c:	50                   	push   %eax
c002706d:	ff 75 08             	pushl  0x8(%ebp)
c0027070:	e8 c6 01 00 00       	call   c002723b <signal>
c0027075:	83 c4 10             	add    $0x10,%esp
  return byte;
c0027078:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002707b:	c9                   	leave  
c002707c:	c3                   	ret    

c002707d <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c002707d:	55                   	push   %ebp
c002707e:	89 e5                	mov    %esp,%ebp
c0027080:	83 ec 18             	sub    $0x18,%esp
c0027083:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027086:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0027089:	e8 7a a8 ff ff       	call   c0021908 <intr_get_level>
c002708e:	85 c0                	test   %eax,%eax
c0027090:	74 7b                	je     c002710d <intq_putc+0x90>
c0027092:	83 ec 0c             	sub    $0xc,%esp
c0027095:	68 14 0e 03 c0       	push   $0xc0030e14
c002709a:	68 32 0e 03 c0       	push   $0xc0030e32
c002709f:	68 4c 0f 03 c0       	push   $0xc0030f4c
c00270a4:	6a 3f                	push   $0x3f
c00270a6:	68 49 0e 03 c0       	push   $0xc0030e49
c00270ab:	e8 72 2f 00 00       	call   c002a022 <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c00270b0:	e8 95 ab ff ff       	call   c0021c4a <intr_context>
c00270b5:	83 f0 01             	xor    $0x1,%eax
c00270b8:	84 c0                	test   %al,%al
c00270ba:	75 1e                	jne    c00270da <intq_putc+0x5d>
c00270bc:	83 ec 0c             	sub    $0xc,%esp
c00270bf:	68 5e 0e 03 c0       	push   $0xc0030e5e
c00270c4:	68 32 0e 03 c0       	push   $0xc0030e32
c00270c9:	68 4c 0f 03 c0       	push   $0xc0030f4c
c00270ce:	6a 42                	push   $0x42
c00270d0:	68 49 0e 03 c0       	push   $0xc0030e49
c00270d5:	e8 48 2f 00 00       	call   c002a022 <debug_panic>
      lock_acquire (&q->lock);
c00270da:	8b 45 08             	mov    0x8(%ebp),%eax
c00270dd:	83 ec 0c             	sub    $0xc,%esp
c00270e0:	50                   	push   %eax
c00270e1:	e8 c9 bf ff ff       	call   c00230af <lock_acquire>
c00270e6:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c00270e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00270ec:	83 c0 24             	add    $0x24,%eax
c00270ef:	83 ec 08             	sub    $0x8,%esp
c00270f2:	50                   	push   %eax
c00270f3:	ff 75 08             	pushl  0x8(%ebp)
c00270f6:	e8 7d 00 00 00       	call   c0027178 <wait>
c00270fb:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c00270fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0027101:	83 ec 0c             	sub    $0xc,%esp
c0027104:	50                   	push   %eax
c0027105:	e8 d6 c1 ff ff       	call   c00232e0 <lock_release>
c002710a:	83 c4 10             	add    $0x10,%esp
  while (intq_full (q))
c002710d:	83 ec 0c             	sub    $0xc,%esp
c0027110:	ff 75 08             	pushl  0x8(%ebp)
c0027113:	e8 37 fe ff ff       	call   c0026f4f <intq_full>
c0027118:	83 c4 10             	add    $0x10,%esp
c002711b:	84 c0                	test   %al,%al
c002711d:	75 91                	jne    c00270b0 <intq_putc+0x33>
    }

  q->buf[q->head] = byte;
c002711f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027122:	8b 40 6c             	mov    0x6c(%eax),%eax
c0027125:	8b 55 08             	mov    0x8(%ebp),%edx
c0027128:	8a 4d f4             	mov    -0xc(%ebp),%cl
c002712b:	88 4c 02 2c          	mov    %cl,0x2c(%edx,%eax,1)
  q->head = next (q->head);
c002712f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027132:	8b 40 6c             	mov    0x6c(%eax),%eax
c0027135:	83 ec 0c             	sub    $0xc,%esp
c0027138:	50                   	push   %eax
c0027139:	e8 23 00 00 00       	call   c0027161 <next>
c002713e:	83 c4 10             	add    $0x10,%esp
c0027141:	89 c2                	mov    %eax,%edx
c0027143:	8b 45 08             	mov    0x8(%ebp),%eax
c0027146:	89 50 6c             	mov    %edx,0x6c(%eax)
  signal (q, &q->not_empty);
c0027149:	8b 45 08             	mov    0x8(%ebp),%eax
c002714c:	83 c0 28             	add    $0x28,%eax
c002714f:	83 ec 08             	sub    $0x8,%esp
c0027152:	50                   	push   %eax
c0027153:	ff 75 08             	pushl  0x8(%ebp)
c0027156:	e8 e0 00 00 00       	call   c002723b <signal>
c002715b:	83 c4 10             	add    $0x10,%esp
}
c002715e:	90                   	nop
c002715f:	c9                   	leave  
c0027160:	c3                   	ret    

c0027161 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0027161:	55                   	push   %ebp
c0027162:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c0027164:	8b 45 08             	mov    0x8(%ebp),%eax
c0027167:	40                   	inc    %eax
c0027168:	25 3f 00 00 80       	and    $0x8000003f,%eax
c002716d:	85 c0                	test   %eax,%eax
c002716f:	79 05                	jns    c0027176 <next+0x15>
c0027171:	48                   	dec    %eax
c0027172:	83 c8 c0             	or     $0xffffffc0,%eax
c0027175:	40                   	inc    %eax
}
c0027176:	5d                   	pop    %ebp
c0027177:	c3                   	ret    

c0027178 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0027178:	55                   	push   %ebp
c0027179:	89 e5                	mov    %esp,%ebp
c002717b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c002717e:	e8 c7 aa ff ff       	call   c0021c4a <intr_context>
c0027183:	83 f0 01             	xor    $0x1,%eax
c0027186:	84 c0                	test   %al,%al
c0027188:	75 1e                	jne    c00271a8 <wait+0x30>
c002718a:	83 ec 0c             	sub    $0xc,%esp
c002718d:	68 5e 0e 03 c0       	push   $0xc0030e5e
c0027192:	68 32 0e 03 c0       	push   $0xc0030e32
c0027197:	68 58 0f 03 c0       	push   $0xc0030f58
c002719c:	6a 59                	push   $0x59
c002719e:	68 49 0e 03 c0       	push   $0xc0030e49
c00271a3:	e8 7a 2e 00 00       	call   c002a022 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00271a8:	e8 5b a7 ff ff       	call   c0021908 <intr_get_level>
c00271ad:	85 c0                	test   %eax,%eax
c00271af:	74 1e                	je     c00271cf <wait+0x57>
c00271b1:	83 ec 0c             	sub    $0xc,%esp
c00271b4:	68 14 0e 03 c0       	push   $0xc0030e14
c00271b9:	68 32 0e 03 c0       	push   $0xc0030e32
c00271be:	68 58 0f 03 c0       	push   $0xc0030f58
c00271c3:	6a 5a                	push   $0x5a
c00271c5:	68 49 0e 03 c0       	push   $0xc0030e49
c00271ca:	e8 53 2e 00 00       	call   c002a022 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00271cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00271d2:	83 c0 28             	add    $0x28,%eax
c00271d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00271d8:	75 12                	jne    c00271ec <wait+0x74>
c00271da:	83 ec 0c             	sub    $0xc,%esp
c00271dd:	ff 75 08             	pushl  0x8(%ebp)
c00271e0:	e8 2a fd ff ff       	call   c0026f0f <intq_empty>
c00271e5:	83 c4 10             	add    $0x10,%esp
c00271e8:	84 c0                	test   %al,%al
c00271ea:	75 3b                	jne    c0027227 <wait+0xaf>
c00271ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00271ef:	83 c0 24             	add    $0x24,%eax
c00271f2:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00271f5:	75 12                	jne    c0027209 <wait+0x91>
c00271f7:	83 ec 0c             	sub    $0xc,%esp
c00271fa:	ff 75 08             	pushl  0x8(%ebp)
c00271fd:	e8 4d fd ff ff       	call   c0026f4f <intq_full>
c0027202:	83 c4 10             	add    $0x10,%esp
c0027205:	84 c0                	test   %al,%al
c0027207:	75 1e                	jne    c0027227 <wait+0xaf>
c0027209:	83 ec 0c             	sub    $0xc,%esp
c002720c:	68 70 0e 03 c0       	push   $0xc0030e70
c0027211:	68 32 0e 03 c0       	push   $0xc0030e32
c0027216:	68 58 0f 03 c0       	push   $0xc0030f58
c002721b:	6a 5c                	push   $0x5c
c002721d:	68 49 0e 03 c0       	push   $0xc0030e49
c0027222:	e8 fb 2d 00 00       	call   c002a022 <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0027227:	e8 5f 9a ff ff       	call   c0020c8b <thread_current>
c002722c:	89 c2                	mov    %eax,%edx
c002722e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027231:	89 10                	mov    %edx,(%eax)
  thread_block ();
c0027233:	e8 2f 99 ff ff       	call   c0020b67 <thread_block>
}
c0027238:	90                   	nop
c0027239:	c9                   	leave  
c002723a:	c3                   	ret    

c002723b <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c002723b:	55                   	push   %ebp
c002723c:	89 e5                	mov    %esp,%ebp
c002723e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0027241:	e8 c2 a6 ff ff       	call   c0021908 <intr_get_level>
c0027246:	85 c0                	test   %eax,%eax
c0027248:	74 1e                	je     c0027268 <signal+0x2d>
c002724a:	83 ec 0c             	sub    $0xc,%esp
c002724d:	68 14 0e 03 c0       	push   $0xc0030e14
c0027252:	68 32 0e 03 c0       	push   $0xc0030e32
c0027257:	68 60 0f 03 c0       	push   $0xc0030f60
c002725c:	6a 69                	push   $0x69
c002725e:	68 49 0e 03 c0       	push   $0xc0030e49
c0027263:	e8 ba 2d 00 00       	call   c002a022 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0027268:	8b 45 08             	mov    0x8(%ebp),%eax
c002726b:	83 c0 28             	add    $0x28,%eax
c002726e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027271:	75 15                	jne    c0027288 <signal+0x4d>
c0027273:	83 ec 0c             	sub    $0xc,%esp
c0027276:	ff 75 08             	pushl  0x8(%ebp)
c0027279:	e8 91 fc ff ff       	call   c0026f0f <intq_empty>
c002727e:	83 c4 10             	add    $0x10,%esp
c0027281:	83 f0 01             	xor    $0x1,%eax
c0027284:	84 c0                	test   %al,%al
c0027286:	75 3e                	jne    c00272c6 <signal+0x8b>
c0027288:	8b 45 08             	mov    0x8(%ebp),%eax
c002728b:	83 c0 24             	add    $0x24,%eax
c002728e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027291:	75 15                	jne    c00272a8 <signal+0x6d>
c0027293:	83 ec 0c             	sub    $0xc,%esp
c0027296:	ff 75 08             	pushl  0x8(%ebp)
c0027299:	e8 b1 fc ff ff       	call   c0026f4f <intq_full>
c002729e:	83 c4 10             	add    $0x10,%esp
c00272a1:	83 f0 01             	xor    $0x1,%eax
c00272a4:	84 c0                	test   %al,%al
c00272a6:	75 1e                	jne    c00272c6 <signal+0x8b>
c00272a8:	83 ec 0c             	sub    $0xc,%esp
c00272ab:	68 cc 0e 03 c0       	push   $0xc0030ecc
c00272b0:	68 32 0e 03 c0       	push   $0xc0030e32
c00272b5:	68 60 0f 03 c0       	push   $0xc0030f60
c00272ba:	6a 6b                	push   $0x6b
c00272bc:	68 49 0e 03 c0       	push   $0xc0030e49
c00272c1:	e8 5c 2d 00 00       	call   c002a022 <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c00272c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272c9:	8b 00                	mov    (%eax),%eax
c00272cb:	85 c0                	test   %eax,%eax
c00272cd:	74 1a                	je     c00272e9 <signal+0xae>
    {
      thread_unblock (*waiter);
c00272cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272d2:	8b 00                	mov    (%eax),%eax
c00272d4:	83 ec 0c             	sub    $0xc,%esp
c00272d7:	50                   	push   %eax
c00272d8:	e8 fb 98 ff ff       	call   c0020bd8 <thread_unblock>
c00272dd:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c00272e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272e3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c00272e9:	90                   	nop
c00272ea:	c9                   	leave  
c00272eb:	c3                   	ret    

c00272ec <inb>:
{
c00272ec:	55                   	push   %ebp
c00272ed:	89 e5                	mov    %esp,%ebp
c00272ef:	83 ec 14             	sub    $0x14,%esp
c00272f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00272f5:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00272f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00272fc:	89 c2                	mov    %eax,%edx
c00272fe:	ec                   	in     (%dx),%al
c00272ff:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0027302:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0027305:	c9                   	leave  
c0027306:	c3                   	ret    

c0027307 <outb>:
{
c0027307:	55                   	push   %ebp
c0027308:	89 e5                	mov    %esp,%ebp
c002730a:	83 ec 08             	sub    $0x8,%esp
c002730d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027310:	8b 55 0c             	mov    0xc(%ebp),%edx
c0027313:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0027317:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002731a:	8a 45 f8             	mov    -0x8(%ebp),%al
c002731d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027320:	ee                   	out    %al,(%dx)
}
c0027321:	90                   	nop
c0027322:	c9                   	leave  
c0027323:	c3                   	ret    

c0027324 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0027324:	55                   	push   %ebp
c0027325:	89 e5                	mov    %esp,%ebp
c0027327:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c002732a:	83 ec 0c             	sub    $0xc,%esp
c002732d:	6a 00                	push   $0x0
c002732f:	e8 01 02 00 00       	call   c0027535 <cmos_read>
c0027334:	83 c4 10             	add    $0x10,%esp
c0027337:	0f b6 c0             	movzbl %al,%eax
c002733a:	83 ec 0c             	sub    $0xc,%esp
c002733d:	50                   	push   %eax
c002733e:	e8 c7 01 00 00       	call   c002750a <bcd_to_bin>
c0027343:	83 c4 10             	add    $0x10,%esp
c0027346:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0027349:	83 ec 0c             	sub    $0xc,%esp
c002734c:	6a 02                	push   $0x2
c002734e:	e8 e2 01 00 00       	call   c0027535 <cmos_read>
c0027353:	83 c4 10             	add    $0x10,%esp
c0027356:	0f b6 c0             	movzbl %al,%eax
c0027359:	83 ec 0c             	sub    $0xc,%esp
c002735c:	50                   	push   %eax
c002735d:	e8 a8 01 00 00       	call   c002750a <bcd_to_bin>
c0027362:	83 c4 10             	add    $0x10,%esp
c0027365:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0027368:	83 ec 0c             	sub    $0xc,%esp
c002736b:	6a 04                	push   $0x4
c002736d:	e8 c3 01 00 00       	call   c0027535 <cmos_read>
c0027372:	83 c4 10             	add    $0x10,%esp
c0027375:	0f b6 c0             	movzbl %al,%eax
c0027378:	83 ec 0c             	sub    $0xc,%esp
c002737b:	50                   	push   %eax
c002737c:	e8 89 01 00 00       	call   c002750a <bcd_to_bin>
c0027381:	83 c4 10             	add    $0x10,%esp
c0027384:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c0027387:	83 ec 0c             	sub    $0xc,%esp
c002738a:	6a 07                	push   $0x7
c002738c:	e8 a4 01 00 00       	call   c0027535 <cmos_read>
c0027391:	83 c4 10             	add    $0x10,%esp
c0027394:	0f b6 c0             	movzbl %al,%eax
c0027397:	83 ec 0c             	sub    $0xc,%esp
c002739a:	50                   	push   %eax
c002739b:	e8 6a 01 00 00       	call   c002750a <bcd_to_bin>
c00273a0:	83 c4 10             	add    $0x10,%esp
c00273a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c00273a6:	83 ec 0c             	sub    $0xc,%esp
c00273a9:	6a 08                	push   $0x8
c00273ab:	e8 85 01 00 00       	call   c0027535 <cmos_read>
c00273b0:	83 c4 10             	add    $0x10,%esp
c00273b3:	0f b6 c0             	movzbl %al,%eax
c00273b6:	83 ec 0c             	sub    $0xc,%esp
c00273b9:	50                   	push   %eax
c00273ba:	e8 4b 01 00 00       	call   c002750a <bcd_to_bin>
c00273bf:	83 c4 10             	add    $0x10,%esp
c00273c2:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c00273c5:	83 ec 0c             	sub    $0xc,%esp
c00273c8:	6a 09                	push   $0x9
c00273ca:	e8 66 01 00 00       	call   c0027535 <cmos_read>
c00273cf:	83 c4 10             	add    $0x10,%esp
c00273d2:	0f b6 c0             	movzbl %al,%eax
c00273d5:	83 ec 0c             	sub    $0xc,%esp
c00273d8:	50                   	push   %eax
c00273d9:	e8 2c 01 00 00       	call   c002750a <bcd_to_bin>
c00273de:	83 c4 10             	add    $0x10,%esp
c00273e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c00273e4:	83 ec 0c             	sub    $0xc,%esp
c00273e7:	6a 00                	push   $0x0
c00273e9:	e8 47 01 00 00       	call   c0027535 <cmos_read>
c00273ee:	83 c4 10             	add    $0x10,%esp
c00273f1:	0f b6 c0             	movzbl %al,%eax
c00273f4:	83 ec 0c             	sub    $0xc,%esp
c00273f7:	50                   	push   %eax
c00273f8:	e8 0d 01 00 00       	call   c002750a <bcd_to_bin>
c00273fd:	83 c4 10             	add    $0x10,%esp
c0027400:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027403:	0f 85 21 ff ff ff    	jne    c002732a <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0027409:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c002740d:	7f 04                	jg     c0027413 <rtc_get_time+0xef>
    year += 100;
c002740f:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0027413:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0027417:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002741a:	89 d0                	mov    %edx,%eax
c002741c:	c1 e0 03             	shl    $0x3,%eax
c002741f:	01 d0                	add    %edx,%eax
c0027421:	c1 e0 03             	shl    $0x3,%eax
c0027424:	01 d0                	add    %edx,%eax
c0027426:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002742d:	01 c2                	add    %eax,%edx
c002742f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027432:	48                   	dec    %eax
c0027433:	85 c0                	test   %eax,%eax
c0027435:	79 03                	jns    c002743a <rtc_get_time+0x116>
c0027437:	83 c0 03             	add    $0x3,%eax
c002743a:	c1 f8 02             	sar    $0x2,%eax
c002743d:	01 c2                	add    %eax,%edx
c002743f:	89 d0                	mov    %edx,%eax
c0027441:	c1 e0 02             	shl    $0x2,%eax
c0027444:	01 d0                	add    %edx,%eax
c0027446:	c1 e0 02             	shl    $0x2,%eax
c0027449:	01 d0                	add    %edx,%eax
c002744b:	c1 e0 03             	shl    $0x3,%eax
c002744e:	01 d0                	add    %edx,%eax
c0027450:	c1 e0 02             	shl    $0x2,%eax
c0027453:	29 d0                	sub    %edx,%eax
c0027455:	c1 e0 07             	shl    $0x7,%eax
c0027458:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c002745b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0027462:	eb 2a                	jmp    c002748e <rtc_get_time+0x16a>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0027464:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027467:	48                   	dec    %eax
c0027468:	8b 14 85 80 0f 03 c0 	mov    -0x3ffcf080(,%eax,4),%edx
c002746f:	89 d0                	mov    %edx,%eax
c0027471:	c1 e0 02             	shl    $0x2,%eax
c0027474:	01 d0                	add    %edx,%eax
c0027476:	c1 e0 02             	shl    $0x2,%eax
c0027479:	01 d0                	add    %edx,%eax
c002747b:	c1 e0 03             	shl    $0x3,%eax
c002747e:	01 d0                	add    %edx,%eax
c0027480:	c1 e0 02             	shl    $0x2,%eax
c0027483:	29 d0                	sub    %edx,%eax
c0027485:	c1 e0 07             	shl    $0x7,%eax
c0027488:	01 45 f0             	add    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c002748b:	ff 45 ec             	incl   -0x14(%ebp)
c002748e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027491:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0027494:	7e ce                	jle    c0027464 <rtc_get_time+0x140>
  if (mon > 2 && year % 4 == 0)
c0027496:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c002749a:	7e 11                	jle    c00274ad <rtc_get_time+0x189>
c002749c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002749f:	83 e0 03             	and    $0x3,%eax
c00274a2:	85 c0                	test   %eax,%eax
c00274a4:	75 07                	jne    c00274ad <rtc_get_time+0x189>
    time += 24 * 60 * 60;
c00274a6:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c00274ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00274b0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00274b3:	89 d0                	mov    %edx,%eax
c00274b5:	c1 e0 02             	shl    $0x2,%eax
c00274b8:	01 d0                	add    %edx,%eax
c00274ba:	c1 e0 02             	shl    $0x2,%eax
c00274bd:	01 d0                	add    %edx,%eax
c00274bf:	c1 e0 03             	shl    $0x3,%eax
c00274c2:	01 d0                	add    %edx,%eax
c00274c4:	c1 e0 02             	shl    $0x2,%eax
c00274c7:	29 d0                	sub    %edx,%eax
c00274c9:	c1 e0 07             	shl    $0x7,%eax
c00274cc:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c00274cf:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00274d2:	89 d0                	mov    %edx,%eax
c00274d4:	01 c0                	add    %eax,%eax
c00274d6:	01 d0                	add    %edx,%eax
c00274d8:	01 c0                	add    %eax,%eax
c00274da:	01 d0                	add    %edx,%eax
c00274dc:	c1 e0 05             	shl    $0x5,%eax
c00274df:	01 d0                	add    %edx,%eax
c00274e1:	c1 e0 04             	shl    $0x4,%eax
c00274e4:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c00274e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00274ea:	89 d0                	mov    %edx,%eax
c00274ec:	01 c0                	add    %eax,%eax
c00274ee:	01 d0                	add    %edx,%eax
c00274f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00274f7:	01 d0                	add    %edx,%eax
c00274f9:	c1 e0 02             	shl    $0x2,%eax
c00274fc:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c00274ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027502:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0027505:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027508:	c9                   	leave  
c0027509:	c3                   	ret    

c002750a <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c002750a:	55                   	push   %ebp
c002750b:	89 e5                	mov    %esp,%ebp
c002750d:	83 ec 04             	sub    $0x4,%esp
c0027510:	8b 45 08             	mov    0x8(%ebp),%eax
c0027513:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0027516:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c002751a:	83 e0 0f             	and    $0xf,%eax
c002751d:	89 c1                	mov    %eax,%ecx
c002751f:	8a 45 fc             	mov    -0x4(%ebp),%al
c0027522:	c0 e8 04             	shr    $0x4,%al
c0027525:	0f b6 d0             	movzbl %al,%edx
c0027528:	89 d0                	mov    %edx,%eax
c002752a:	c1 e0 02             	shl    $0x2,%eax
c002752d:	01 d0                	add    %edx,%eax
c002752f:	01 c0                	add    %eax,%eax
c0027531:	01 c8                	add    %ecx,%eax
}
c0027533:	c9                   	leave  
c0027534:	c3                   	ret    

c0027535 <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0027535:	55                   	push   %ebp
c0027536:	89 e5                	mov    %esp,%ebp
c0027538:	83 ec 04             	sub    $0x4,%esp
c002753b:	8b 45 08             	mov    0x8(%ebp),%eax
c002753e:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0027541:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0027545:	50                   	push   %eax
c0027546:	6a 70                	push   $0x70
c0027548:	e8 ba fd ff ff       	call   c0027307 <outb>
c002754d:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0027550:	6a 71                	push   $0x71
c0027552:	e8 95 fd ff ff       	call   c00272ec <inb>
c0027557:	83 c4 04             	add    $0x4,%esp
}
c002755a:	c9                   	leave  
c002755b:	c3                   	ret    

c002755c <inb>:
{
c002755c:	55                   	push   %ebp
c002755d:	89 e5                	mov    %esp,%ebp
c002755f:	83 ec 14             	sub    $0x14,%esp
c0027562:	8b 45 08             	mov    0x8(%ebp),%eax
c0027565:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0027569:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002756c:	89 c2                	mov    %eax,%edx
c002756e:	ec                   	in     (%dx),%al
c002756f:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0027572:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0027575:	c9                   	leave  
c0027576:	c3                   	ret    

c0027577 <outb>:
{
c0027577:	55                   	push   %ebp
c0027578:	89 e5                	mov    %esp,%ebp
c002757a:	83 ec 08             	sub    $0x8,%esp
c002757d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027580:	8b 55 0c             	mov    0xc(%ebp),%edx
c0027583:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0027587:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002758a:	8a 45 f8             	mov    -0x8(%ebp),%al
c002758d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027590:	ee                   	out    %al,(%dx)
}
c0027591:	90                   	nop
c0027592:	c9                   	leave  
c0027593:	c3                   	ret    

c0027594 <outw>:
{
c0027594:	55                   	push   %ebp
c0027595:	89 e5                	mov    %esp,%ebp
c0027597:	83 ec 08             	sub    $0x8,%esp
c002759a:	8b 55 08             	mov    0x8(%ebp),%edx
c002759d:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275a0:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00275a4:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00275a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00275ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00275ae:	66 ef                	out    %ax,(%dx)
}
c00275b0:	90                   	nop
c00275b1:	c9                   	leave  
c00275b2:	c3                   	ret    

c00275b3 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c00275b3:	55                   	push   %ebp
c00275b4:	89 e5                	mov    %esp,%ebp
c00275b6:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c00275b9:	a1 34 9f 03 c0       	mov    0xc0039f34,%eax
c00275be:	83 f8 01             	cmp    $0x1,%eax
c00275c1:	74 07                	je     c00275ca <shutdown+0x17>
c00275c3:	83 f8 02             	cmp    $0x2,%eax
c00275c6:	74 07                	je     c00275cf <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c00275c8:	eb 0a                	jmp    c00275d4 <shutdown+0x21>
      shutdown_power_off ();
c00275ca:	e8 9c 00 00 00       	call   c002766b <shutdown_power_off>
      shutdown_reboot ();
c00275cf:	e8 11 00 00 00       	call   c00275e5 <shutdown_reboot>
    }
}
c00275d4:	90                   	nop
c00275d5:	c9                   	leave  
c00275d6:	c3                   	ret    

c00275d7 <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c00275d7:	55                   	push   %ebp
c00275d8:	89 e5                	mov    %esp,%ebp
  how = type;
c00275da:	8b 45 08             	mov    0x8(%ebp),%eax
c00275dd:	a3 34 9f 03 c0       	mov    %eax,0xc0039f34
}
c00275e2:	90                   	nop
c00275e3:	5d                   	pop    %ebp
c00275e4:	c3                   	ret    

c00275e5 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c00275e5:	55                   	push   %ebp
c00275e6:	89 e5                	mov    %esp,%ebp
c00275e8:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c00275eb:	83 ec 0c             	sub    $0xc,%esp
c00275ee:	68 b0 0f 03 c0       	push   $0xc0030fb0
c00275f3:	e8 eb 4b 00 00       	call   c002c1e3 <puts>
c00275f8:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c00275fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027602:	eb 29                	jmp    c002762d <shutdown_reboot+0x48>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0027604:	83 ec 0c             	sub    $0xc,%esp
c0027607:	6a 64                	push   $0x64
c0027609:	e8 4e ff ff ff       	call   c002755c <inb>
c002760e:	83 c4 10             	add    $0x10,%esp
c0027611:	0f b6 c0             	movzbl %al,%eax
c0027614:	83 e0 02             	and    $0x2,%eax
c0027617:	85 c0                	test   %eax,%eax
c0027619:	74 1d                	je     c0027638 <shutdown_reboot+0x53>
            break;
          timer_udelay (2);
c002761b:	83 ec 08             	sub    $0x8,%esp
c002761e:	6a 00                	push   $0x0
c0027620:	6a 02                	push   $0x2
c0027622:	e8 c2 d0 ff ff       	call   c00246e9 <timer_udelay>
c0027627:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 0x10000; i++)
c002762a:	ff 45 f4             	incl   -0xc(%ebp)
c002762d:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0027634:	7e ce                	jle    c0027604 <shutdown_reboot+0x1f>
c0027636:	eb 01                	jmp    c0027639 <shutdown_reboot+0x54>
            break;
c0027638:	90                   	nop
        }

      timer_udelay (50);
c0027639:	83 ec 08             	sub    $0x8,%esp
c002763c:	6a 00                	push   $0x0
c002763e:	6a 32                	push   $0x32
c0027640:	e8 a4 d0 ff ff       	call   c00246e9 <timer_udelay>
c0027645:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c0027648:	83 ec 08             	sub    $0x8,%esp
c002764b:	68 fe 00 00 00       	push   $0xfe
c0027650:	6a 64                	push   $0x64
c0027652:	e8 20 ff ff ff       	call   c0027577 <outb>
c0027657:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c002765a:	83 ec 08             	sub    $0x8,%esp
c002765d:	6a 00                	push   $0x0
c002765f:	6a 32                	push   $0x32
c0027661:	e8 83 d0 ff ff       	call   c00246e9 <timer_udelay>
c0027666:	83 c4 10             	add    $0x10,%esp
    {
c0027669:	eb 90                	jmp    c00275fb <shutdown_reboot+0x16>

c002766b <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c002766b:	55                   	push   %ebp
c002766c:	89 e5                	mov    %esp,%ebp
c002766e:	57                   	push   %edi
c002766f:	56                   	push   %esi
c0027670:	53                   	push   %ebx
c0027671:	83 ec 1c             	sub    $0x1c,%esp
  const char s[] = "Shutdown";
c0027674:	8d 45 db             	lea    -0x25(%ebp),%eax
c0027677:	bb de 0f 03 c0       	mov    $0xc0030fde,%ebx
c002767c:	ba 09 00 00 00       	mov    $0x9,%edx
c0027681:	89 c7                	mov    %eax,%edi
c0027683:	89 de                	mov    %ebx,%esi
c0027685:	89 d1                	mov    %edx,%ecx
c0027687:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c0027689:	e8 7d 00 00 00       	call   c002770b <print_stats>

  printf ("Powering off...\n");
c002768e:	83 ec 0c             	sub    $0xc,%esp
c0027691:	68 bd 0f 03 c0       	push   $0xc0030fbd
c0027696:	e8 48 4b 00 00       	call   c002c1e3 <puts>
c002769b:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c002769e:	e8 7f dd ff ff       	call   c0025422 <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c00276a3:	83 ec 08             	sub    $0x8,%esp
c00276a6:	68 00 20 00 00       	push   $0x2000
c00276ab:	68 04 b0 00 00       	push   $0xb004
c00276b0:	e8 df fe ff ff       	call   c0027594 <outw>
c00276b5:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c00276b8:	8d 45 db             	lea    -0x25(%ebp),%eax
c00276bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00276be:	eb 1c                	jmp    c00276dc <shutdown_power_off+0x71>
    outb (0x8900, *p);
c00276c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00276c3:	8a 00                	mov    (%eax),%al
c00276c5:	0f b6 c0             	movzbl %al,%eax
c00276c8:	83 ec 08             	sub    $0x8,%esp
c00276cb:	50                   	push   %eax
c00276cc:	68 00 89 00 00       	push   $0x8900
c00276d1:	e8 a1 fe ff ff       	call   c0027577 <outb>
c00276d6:	83 c4 10             	add    $0x10,%esp
  for (p = s; *p != '\0'; p++)
c00276d9:	ff 45 e4             	incl   -0x1c(%ebp)
c00276dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00276df:	8a 00                	mov    (%eax),%al
c00276e1:	84 c0                	test   %al,%al
c00276e3:	75 db                	jne    c00276c0 <shutdown_power_off+0x55>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c00276e5:	83 ec 08             	sub    $0x8,%esp
c00276e8:	6a 31                	push   $0x31
c00276ea:	68 01 05 00 00       	push   $0x501
c00276ef:	e8 83 fe ff ff       	call   c0027577 <outb>
c00276f4:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c00276f7:	fa                   	cli    
c00276f8:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c00276f9:	83 ec 0c             	sub    $0xc,%esp
c00276fc:	68 cd 0f 03 c0       	push   $0xc0030fcd
c0027701:	e8 dd 4a 00 00       	call   c002c1e3 <puts>
c0027706:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0027709:	eb fe                	jmp    c0027709 <shutdown_power_off+0x9e>

c002770b <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c002770b:	55                   	push   %ebp
c002770c:	89 e5                	mov    %esp,%ebp
c002770e:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0027711:	e8 29 d0 ff ff       	call   c002473f <timer_print_stats>
  thread_print_stats ();
c0027716:	e8 f6 92 ff ff       	call   c0020a11 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c002771b:	e8 97 49 00 00       	call   c002c0b7 <console_print_stats>
  kbd_print_stats ();
c0027720:	e8 38 d4 ff ff       	call   c0024b5d <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c0027725:	90                   	nop
c0027726:	c9                   	leave  
c0027727:	c3                   	ret    

c0027728 <inb>:
{
c0027728:	55                   	push   %ebp
c0027729:	89 e5                	mov    %esp,%ebp
c002772b:	83 ec 14             	sub    $0x14,%esp
c002772e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027731:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0027735:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027738:	89 c2                	mov    %eax,%edx
c002773a:	ec                   	in     (%dx),%al
c002773b:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002773e:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0027741:	c9                   	leave  
c0027742:	c3                   	ret    

c0027743 <outb>:
{
c0027743:	55                   	push   %ebp
c0027744:	89 e5                	mov    %esp,%ebp
c0027746:	83 ec 08             	sub    $0x8,%esp
c0027749:	8b 45 08             	mov    0x8(%ebp),%eax
c002774c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002774f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0027753:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0027756:	8a 45 f8             	mov    -0x8(%ebp),%al
c0027759:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002775c:	ee                   	out    %al,(%dx)
}
c002775d:	90                   	nop
c002775e:	c9                   	leave  
c002775f:	c3                   	ret    

c0027760 <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0027760:	55                   	push   %ebp
c0027761:	89 e5                	mov    %esp,%ebp
c0027763:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c0027766:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c002776a:	7e 54                	jle    c00277c0 <speaker_on+0x60>
c002776c:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0027773:	7f 4b                	jg     c00277c0 <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0027775:	e8 03 a2 ff ff       	call   c002197d <intr_disable>
c002777a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c002777d:	83 ec 04             	sub    $0x4,%esp
c0027780:	ff 75 08             	pushl  0x8(%ebp)
c0027783:	6a 03                	push   $0x3
c0027785:	6a 02                	push   $0x2
c0027787:	e8 3e cb ff ff       	call   c00242ca <pit_configure_channel>
c002778c:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c002778f:	83 ec 0c             	sub    $0xc,%esp
c0027792:	6a 61                	push   $0x61
c0027794:	e8 8f ff ff ff       	call   c0027728 <inb>
c0027799:	83 c4 10             	add    $0x10,%esp
c002779c:	83 c8 03             	or     $0x3,%eax
c002779f:	0f b6 c0             	movzbl %al,%eax
c00277a2:	83 ec 08             	sub    $0x8,%esp
c00277a5:	50                   	push   %eax
c00277a6:	6a 61                	push   $0x61
c00277a8:	e8 96 ff ff ff       	call   c0027743 <outb>
c00277ad:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c00277b0:	83 ec 0c             	sub    $0xc,%esp
c00277b3:	ff 75 f4             	pushl  -0xc(%ebp)
c00277b6:	e8 6a a1 ff ff       	call   c0021925 <intr_set_level>
c00277bb:	83 c4 10             	add    $0x10,%esp
    {
c00277be:	eb 05                	jmp    c00277c5 <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c00277c0:	e8 03 00 00 00       	call   c00277c8 <speaker_off>
    }
}
c00277c5:	90                   	nop
c00277c6:	c9                   	leave  
c00277c7:	c3                   	ret    

c00277c8 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c00277c8:	55                   	push   %ebp
c00277c9:	89 e5                	mov    %esp,%ebp
c00277cb:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c00277ce:	e8 aa a1 ff ff       	call   c002197d <intr_disable>
c00277d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c00277d6:	83 ec 0c             	sub    $0xc,%esp
c00277d9:	6a 61                	push   $0x61
c00277db:	e8 48 ff ff ff       	call   c0027728 <inb>
c00277e0:	83 c4 10             	add    $0x10,%esp
c00277e3:	0f b6 c0             	movzbl %al,%eax
c00277e6:	25 fc 00 00 00       	and    $0xfc,%eax
c00277eb:	83 ec 08             	sub    $0x8,%esp
c00277ee:	50                   	push   %eax
c00277ef:	6a 61                	push   $0x61
c00277f1:	e8 4d ff ff ff       	call   c0027743 <outb>
c00277f6:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c00277f9:	83 ec 0c             	sub    $0xc,%esp
c00277fc:	ff 75 f4             	pushl  -0xc(%ebp)
c00277ff:	e8 21 a1 ff ff       	call   c0021925 <intr_set_level>
c0027804:	83 c4 10             	add    $0x10,%esp
}
c0027807:	90                   	nop
c0027808:	c9                   	leave  
c0027809:	c3                   	ret    

c002780a <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c002780a:	55                   	push   %ebp
c002780b:	89 e5                	mov    %esp,%ebp
c002780d:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0027810:	e8 f3 a0 ff ff       	call   c0021908 <intr_get_level>
c0027815:	83 f8 01             	cmp    $0x1,%eax
c0027818:	75 27                	jne    c0027841 <speaker_beep+0x37>
    {
      speaker_on (440);
c002781a:	83 ec 0c             	sub    $0xc,%esp
c002781d:	68 b8 01 00 00       	push   $0x1b8
c0027822:	e8 39 ff ff ff       	call   c0027760 <speaker_on>
c0027827:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c002782a:	83 ec 08             	sub    $0x8,%esp
c002782d:	6a 00                	push   $0x0
c002782f:	68 fa 00 00 00       	push   $0xfa
c0027834:	e8 04 ce ff ff       	call   c002463d <timer_msleep>
c0027839:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c002783c:	e8 87 ff ff ff       	call   c00277c8 <speaker_off>
    }
}
c0027841:	90                   	nop
c0027842:	c9                   	leave  
c0027843:	c3                   	ret    

c0027844 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0027844:	55                   	push   %ebp
c0027845:	89 e5                	mov    %esp,%ebp
c0027847:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c002784a:	8b 45 04             	mov    0x4(%ebp),%eax
c002784d:	83 ec 08             	sub    $0x8,%esp
c0027850:	50                   	push   %eax
c0027851:	68 e8 0f 03 c0       	push   $0xc0030fe8
c0027856:	e8 f6 02 00 00       	call   c0027b51 <printf>
c002785b:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c002785e:	8b 45 00             	mov    0x0(%ebp),%eax
c0027861:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0027864:	eb 21                	jmp    c0027887 <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0027866:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027869:	83 c0 04             	add    $0x4,%eax
c002786c:	8b 00                	mov    (%eax),%eax
c002786e:	83 ec 08             	sub    $0x8,%esp
c0027871:	50                   	push   %eax
c0027872:	68 f7 0f 03 c0       	push   $0xc0030ff7
c0027877:	e8 d5 02 00 00       	call   c0027b51 <printf>
c002787c:	83 c4 10             	add    $0x10,%esp
       frame = frame[0]) 
c002787f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027882:	8b 00                	mov    (%eax),%eax
c0027884:	89 45 f4             	mov    %eax,-0xc(%ebp)
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0027887:	8b 45 f4             	mov    -0xc(%ebp),%eax
  for (frame = __builtin_frame_address (1);
c002788a:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002788f:	76 09                	jbe    c002789a <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0027891:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027894:	8b 00                	mov    (%eax),%eax
c0027896:	85 c0                	test   %eax,%eax
c0027898:	75 cc                	jne    c0027866 <debug_backtrace+0x22>
  printf (".\n");
c002789a:	83 ec 0c             	sub    $0xc,%esp
c002789d:	68 fb 0f 03 c0       	push   $0xc0030ffb
c00278a2:	e8 3c 49 00 00       	call   c002c1e3 <puts>
c00278a7:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c00278aa:	a0 38 9f 03 c0       	mov    0xc0039f38,%al
c00278af:	83 f0 01             	xor    $0x1,%eax
c00278b2:	84 c0                	test   %al,%al
c00278b4:	74 17                	je     c00278cd <debug_backtrace+0x89>
    {
      explained = true;
c00278b6:	c6 05 38 9f 03 c0 01 	movb   $0x1,0xc0039f38
      printf ("The `backtrace' program can make call stacks useful.\n"
c00278bd:	83 ec 0c             	sub    $0xc,%esp
c00278c0:	68 00 10 03 c0       	push   $0xc0031000
c00278c5:	e8 19 49 00 00       	call   c002c1e3 <puts>
c00278ca:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c00278cd:	90                   	nop
c00278ce:	c9                   	leave  
c00278cf:	c3                   	ret    

c00278d0 <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c00278d0:	55                   	push   %ebp
c00278d1:	89 e5                	mov    %esp,%ebp
c00278d3:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c00278d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00278d9:	8a 00                	mov    (%eax),%al
c00278db:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c00278de:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278e1:	8a 10                	mov    (%eax),%dl
c00278e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00278e6:	88 10                	mov    %dl,(%eax)
  *b = t;
c00278e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278eb:	8a 55 ff             	mov    -0x1(%ebp),%dl
c00278ee:	88 10                	mov    %dl,(%eax)
}
c00278f0:	90                   	nop
c00278f1:	c9                   	leave  
c00278f2:	c3                   	ret    

c00278f3 <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c00278f3:	55                   	push   %ebp
c00278f4:	89 e5                	mov    %esp,%ebp
c00278f6:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c00278f9:	8d 45 08             	lea    0x8(%ebp),%eax
c00278fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c00278ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0027906:	eb 12                	jmp    c002791a <random_init+0x27>
    s[i] = i;
c0027908:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002790b:	88 c2                	mov    %al,%dl
c002790d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027910:	05 40 9f 03 c0       	add    $0xc0039f40,%eax
c0027915:	88 10                	mov    %dl,(%eax)
  for (i = 0; i < 256; i++) 
c0027917:	ff 45 fc             	incl   -0x4(%ebp)
c002791a:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0027921:	7e e5                	jle    c0027908 <random_init+0x15>
  for (i = j = 0; i < 256; i++) 
c0027923:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c0027927:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002792e:	eb 3d                	jmp    c002796d <random_init+0x7a>
    {
      j += s[i] + seedp[i % sizeof seed];
c0027930:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027933:	05 40 9f 03 c0       	add    $0xc0039f40,%eax
c0027938:	8a 10                	mov    (%eax),%dl
c002793a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002793d:	83 e0 03             	and    $0x3,%eax
c0027940:	89 c1                	mov    %eax,%ecx
c0027942:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027945:	01 c8                	add    %ecx,%eax
c0027947:	8a 00                	mov    (%eax),%al
c0027949:	01 d0                	add    %edx,%eax
c002794b:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c002794e:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0027952:	8d 90 40 9f 03 c0    	lea    -0x3ffc60c0(%eax),%edx
c0027958:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002795b:	05 40 9f 03 c0       	add    $0xc0039f40,%eax
c0027960:	52                   	push   %edx
c0027961:	50                   	push   %eax
c0027962:	e8 69 ff ff ff       	call   c00278d0 <swap_byte>
c0027967:	83 c4 08             	add    $0x8,%esp
  for (i = j = 0; i < 256; i++) 
c002796a:	ff 45 fc             	incl   -0x4(%ebp)
c002796d:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0027974:	7e ba                	jle    c0027930 <random_init+0x3d>
    }

  s_i = s_j = 0;
c0027976:	c6 05 41 a0 03 c0 00 	movb   $0x0,0xc003a041
c002797d:	a0 41 a0 03 c0       	mov    0xc003a041,%al
c0027982:	a2 40 a0 03 c0       	mov    %al,0xc003a040
  inited = true;
c0027987:	c6 05 42 a0 03 c0 01 	movb   $0x1,0xc003a042
}
c002798e:	90                   	nop
c002798f:	c9                   	leave  
c0027990:	c3                   	ret    

c0027991 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0027991:	55                   	push   %ebp
c0027992:	89 e5                	mov    %esp,%ebp
c0027994:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c0027997:	a0 42 a0 03 c0       	mov    0xc003a042,%al
c002799c:	83 f0 01             	xor    $0x1,%eax
c002799f:	84 c0                	test   %al,%al
c00279a1:	74 0a                	je     c00279ad <random_bytes+0x1c>
    random_init (0);
c00279a3:	6a 00                	push   $0x0
c00279a5:	e8 49 ff ff ff       	call   c00278f3 <random_init>
c00279aa:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c00279ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00279b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00279b3:	eb 7d                	jmp    c0027a32 <random_bytes+0xa1>
    {
      uint8_t s_k;
      
      s_i++;
c00279b5:	a0 40 a0 03 c0       	mov    0xc003a040,%al
c00279ba:	40                   	inc    %eax
c00279bb:	a2 40 a0 03 c0       	mov    %al,0xc003a040
      s_j += s[s_i];
c00279c0:	a0 40 a0 03 c0       	mov    0xc003a040,%al
c00279c5:	0f b6 c0             	movzbl %al,%eax
c00279c8:	8a 90 40 9f 03 c0    	mov    -0x3ffc60c0(%eax),%dl
c00279ce:	a0 41 a0 03 c0       	mov    0xc003a041,%al
c00279d3:	01 d0                	add    %edx,%eax
c00279d5:	a2 41 a0 03 c0       	mov    %al,0xc003a041
      swap_byte (s + s_i, s + s_j);
c00279da:	a0 41 a0 03 c0       	mov    0xc003a041,%al
c00279df:	0f b6 c0             	movzbl %al,%eax
c00279e2:	8d 90 40 9f 03 c0    	lea    -0x3ffc60c0(%eax),%edx
c00279e8:	a0 40 a0 03 c0       	mov    0xc003a040,%al
c00279ed:	0f b6 c0             	movzbl %al,%eax
c00279f0:	05 40 9f 03 c0       	add    $0xc0039f40,%eax
c00279f5:	52                   	push   %edx
c00279f6:	50                   	push   %eax
c00279f7:	e8 d4 fe ff ff       	call   c00278d0 <swap_byte>
c00279fc:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c00279ff:	a0 40 a0 03 c0       	mov    0xc003a040,%al
c0027a04:	0f b6 c0             	movzbl %al,%eax
c0027a07:	8a 90 40 9f 03 c0    	mov    -0x3ffc60c0(%eax),%dl
c0027a0d:	a0 41 a0 03 c0       	mov    0xc003a041,%al
c0027a12:	0f b6 c0             	movzbl %al,%eax
c0027a15:	8a 80 40 9f 03 c0    	mov    -0x3ffc60c0(%eax),%al
c0027a1b:	01 d0                	add    %edx,%eax
c0027a1d:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c0027a20:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0027a24:	8a 90 40 9f 03 c0    	mov    -0x3ffc60c0(%eax),%dl
c0027a2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027a2d:	88 10                	mov    %dl,(%eax)
  for (buf = buf_; size-- > 0; buf++)
c0027a2f:	ff 45 fc             	incl   -0x4(%ebp)
c0027a32:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a35:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027a38:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a3b:	85 c0                	test   %eax,%eax
c0027a3d:	0f 85 72 ff ff ff    	jne    c00279b5 <random_bytes+0x24>
    }
}
c0027a43:	90                   	nop
c0027a44:	c9                   	leave  
c0027a45:	c3                   	ret    

c0027a46 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0027a46:	55                   	push   %ebp
c0027a47:	89 e5                	mov    %esp,%ebp
c0027a49:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0027a4c:	6a 04                	push   $0x4
c0027a4e:	8d 45 fc             	lea    -0x4(%ebp),%eax
c0027a51:	50                   	push   %eax
c0027a52:	e8 3a ff ff ff       	call   c0027991 <random_bytes>
c0027a57:	83 c4 08             	add    $0x8,%esp
  return ul;
c0027a5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0027a5d:	c9                   	leave  
c0027a5e:	c3                   	ret    

c0027a5f <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027a5f:	55                   	push   %ebp
c0027a60:	89 e5                	mov    %esp,%ebp
c0027a62:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027a66:	7e 0d                	jle    c0027a75 <isdigit+0x16>
c0027a68:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027a6c:	7f 07                	jg     c0027a75 <isdigit+0x16>
c0027a6e:	b8 01 00 00 00       	mov    $0x1,%eax
c0027a73:	eb 05                	jmp    c0027a7a <isdigit+0x1b>
c0027a75:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a7a:	5d                   	pop    %ebp
c0027a7b:	c3                   	ret    

c0027a7c <isprint>:
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027a7c:	55                   	push   %ebp
c0027a7d:	89 e5                	mov    %esp,%ebp
c0027a7f:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0027a83:	7e 0d                	jle    c0027a92 <isprint+0x16>
c0027a85:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0027a89:	7f 07                	jg     c0027a92 <isprint+0x16>
c0027a8b:	b8 01 00 00 00       	mov    $0x1,%eax
c0027a90:	eb 05                	jmp    c0027a97 <isprint+0x1b>
c0027a92:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a97:	5d                   	pop    %ebp
c0027a98:	c3                   	ret    

c0027a99 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c0027a99:	55                   	push   %ebp
c0027a9a:	89 e5                	mov    %esp,%ebp
c0027a9c:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c0027a9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027aa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c0027aa5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027aac:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027ab0:	74 06                	je     c0027ab8 <vsnprintf+0x1f>
c0027ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ab5:	48                   	dec    %eax
c0027ab6:	eb 05                	jmp    c0027abd <vsnprintf+0x24>
c0027ab8:	b8 00 00 00 00       	mov    $0x0,%eax
c0027abd:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027ac0:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0027ac3:	50                   	push   %eax
c0027ac4:	68 e8 7a 02 c0       	push   $0xc0027ae8
c0027ac9:	ff 75 14             	pushl  0x14(%ebp)
c0027acc:	ff 75 10             	pushl  0x10(%ebp)
c0027acf:	e8 a3 00 00 00       	call   c0027b77 <__vprintf>
c0027ad4:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c0027ad7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027adb:	74 06                	je     c0027ae3 <vsnprintf+0x4a>
    *aux.p = '\0';
c0027add:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027ae0:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c0027ae3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027ae6:	c9                   	leave  
c0027ae7:	c3                   	ret    

c0027ae8 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027ae8:	55                   	push   %ebp
c0027ae9:	89 e5                	mov    %esp,%ebp
c0027aeb:	83 ec 14             	sub    $0x14,%esp
c0027aee:	8b 45 08             	mov    0x8(%ebp),%eax
c0027af1:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c0027af4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027af7:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0027afa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027afd:	8b 40 04             	mov    0x4(%eax),%eax
c0027b00:	8d 48 01             	lea    0x1(%eax),%ecx
c0027b03:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027b06:	89 4a 04             	mov    %ecx,0x4(%edx)
c0027b09:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027b0c:	8b 52 08             	mov    0x8(%edx),%edx
c0027b0f:	39 d0                	cmp    %edx,%eax
c0027b11:	7d 12                	jge    c0027b25 <vsnprintf_helper+0x3d>
    *aux->p++ = ch;
c0027b13:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027b16:	8b 00                	mov    (%eax),%eax
c0027b18:	8d 48 01             	lea    0x1(%eax),%ecx
c0027b1b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027b1e:	89 0a                	mov    %ecx,(%edx)
c0027b20:	8a 55 ec             	mov    -0x14(%ebp),%dl
c0027b23:	88 10                	mov    %dl,(%eax)
}
c0027b25:	90                   	nop
c0027b26:	c9                   	leave  
c0027b27:	c3                   	ret    

c0027b28 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c0027b28:	55                   	push   %ebp
c0027b29:	89 e5                	mov    %esp,%ebp
c0027b2b:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027b2e:	8d 45 14             	lea    0x14(%ebp),%eax
c0027b31:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c0027b34:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027b37:	50                   	push   %eax
c0027b38:	ff 75 10             	pushl  0x10(%ebp)
c0027b3b:	ff 75 0c             	pushl  0xc(%ebp)
c0027b3e:	ff 75 08             	pushl  0x8(%ebp)
c0027b41:	e8 53 ff ff ff       	call   c0027a99 <vsnprintf>
c0027b46:	83 c4 10             	add    $0x10,%esp
c0027b49:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027b4f:	c9                   	leave  
c0027b50:	c3                   	ret    

c0027b51 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c0027b51:	55                   	push   %ebp
c0027b52:	89 e5                	mov    %esp,%ebp
c0027b54:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027b57:	8d 45 0c             	lea    0xc(%ebp),%eax
c0027b5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c0027b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027b60:	83 ec 08             	sub    $0x8,%esp
c0027b63:	50                   	push   %eax
c0027b64:	ff 75 08             	pushl  0x8(%ebp)
c0027b67:	e8 44 46 00 00       	call   c002c1b0 <vprintf>
c0027b6c:	83 c4 10             	add    $0x10,%esp
c0027b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027b75:	c9                   	leave  
c0027b76:	c3                   	ret    

c0027b77 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c0027b77:	55                   	push   %ebp
c0027b78:	89 e5                	mov    %esp,%ebp
c0027b7a:	53                   	push   %ebx
c0027b7b:	83 ec 34             	sub    $0x34,%esp
  for (; *format != '\0'; format++)
c0027b7e:	e9 25 04 00 00       	jmp    c0027fa8 <__vprintf+0x431>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c0027b83:	8b 45 08             	mov    0x8(%ebp),%eax
c0027b86:	8a 00                	mov    (%eax),%al
c0027b88:	3c 25                	cmp    $0x25,%al
c0027b8a:	74 1c                	je     c0027ba8 <__vprintf+0x31>
        {
          output (*format, aux);
c0027b8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0027b8f:	8a 00                	mov    (%eax),%al
c0027b91:	0f be c0             	movsbl %al,%eax
c0027b94:	83 ec 08             	sub    $0x8,%esp
c0027b97:	ff 75 14             	pushl  0x14(%ebp)
c0027b9a:	50                   	push   %eax
c0027b9b:	8b 45 10             	mov    0x10(%ebp),%eax
c0027b9e:	ff d0                	call   *%eax
c0027ba0:	83 c4 10             	add    $0x10,%esp
          continue;
c0027ba3:	e9 fd 03 00 00       	jmp    c0027fa5 <__vprintf+0x42e>
        }
      format++;
c0027ba8:	ff 45 08             	incl   0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c0027bab:	8b 45 08             	mov    0x8(%ebp),%eax
c0027bae:	8a 00                	mov    (%eax),%al
c0027bb0:	3c 25                	cmp    $0x25,%al
c0027bb2:	75 15                	jne    c0027bc9 <__vprintf+0x52>
        {
          output ('%', aux);
c0027bb4:	83 ec 08             	sub    $0x8,%esp
c0027bb7:	ff 75 14             	pushl  0x14(%ebp)
c0027bba:	6a 25                	push   $0x25
c0027bbc:	8b 45 10             	mov    0x10(%ebp),%eax
c0027bbf:	ff d0                	call   *%eax
c0027bc1:	83 c4 10             	add    $0x10,%esp
          continue;
c0027bc4:	e9 dc 03 00 00       	jmp    c0027fa5 <__vprintf+0x42e>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c0027bc9:	83 ec 04             	sub    $0x4,%esp
c0027bcc:	8d 45 0c             	lea    0xc(%ebp),%eax
c0027bcf:	50                   	push   %eax
c0027bd0:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027bd3:	50                   	push   %eax
c0027bd4:	ff 75 08             	pushl  0x8(%ebp)
c0027bd7:	e8 df 03 00 00       	call   c0027fbb <parse_conversion>
c0027bdc:	83 c4 10             	add    $0x10,%esp
c0027bdf:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c0027be2:	8b 45 08             	mov    0x8(%ebp),%eax
c0027be5:	8a 00                	mov    (%eax),%al
c0027be7:	0f be c0             	movsbl %al,%eax
c0027bea:	83 e8 45             	sub    $0x45,%eax
c0027bed:	83 f8 33             	cmp    $0x33,%eax
c0027bf0:	0f 87 92 03 00 00    	ja     c0027f88 <__vprintf+0x411>
c0027bf6:	8b 04 85 84 11 03 c0 	mov    -0x3ffcee7c(,%eax,4),%eax
c0027bfd:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c0027bff:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027c02:	83 f8 08             	cmp    $0x8,%eax
c0027c05:	0f 87 d8 00 00 00    	ja     c0027ce3 <__vprintf+0x16c>
c0027c0b:	8b 04 85 54 12 03 c0 	mov    -0x3ffcedac(,%eax,4),%eax
c0027c12:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c0027c14:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c17:	8d 50 04             	lea    0x4(%eax),%edx
c0027c1a:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c1d:	8b 00                	mov    (%eax),%eax
c0027c1f:	0f be c0             	movsbl %al,%eax
c0027c22:	99                   	cltd   
c0027c23:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027c26:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027c29:	e9 cf 00 00 00       	jmp    c0027cfd <__vprintf+0x186>
              case SHORT:
                value = (short) va_arg (args, int);
c0027c2e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c31:	8d 50 04             	lea    0x4(%eax),%edx
c0027c34:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c37:	8b 00                	mov    (%eax),%eax
c0027c39:	98                   	cwtl   
c0027c3a:	99                   	cltd   
c0027c3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027c3e:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027c41:	e9 b7 00 00 00       	jmp    c0027cfd <__vprintf+0x186>
              case INT:
                value = va_arg (args, int);
c0027c46:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c49:	8d 50 04             	lea    0x4(%eax),%edx
c0027c4c:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c4f:	8b 00                	mov    (%eax),%eax
c0027c51:	99                   	cltd   
c0027c52:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027c55:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027c58:	e9 a0 00 00 00       	jmp    c0027cfd <__vprintf+0x186>
              case INTMAX:
                value = va_arg (args, intmax_t);
c0027c5d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c60:	8d 50 08             	lea    0x8(%eax),%edx
c0027c63:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c66:	8b 50 04             	mov    0x4(%eax),%edx
c0027c69:	8b 00                	mov    (%eax),%eax
c0027c6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027c6e:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027c71:	e9 87 00 00 00       	jmp    c0027cfd <__vprintf+0x186>
              case LONG:
                value = va_arg (args, long);
c0027c76:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c79:	8d 50 04             	lea    0x4(%eax),%edx
c0027c7c:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c7f:	8b 00                	mov    (%eax),%eax
c0027c81:	99                   	cltd   
c0027c82:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027c85:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027c88:	eb 73                	jmp    c0027cfd <__vprintf+0x186>
              case LONGLONG:
                value = va_arg (args, long long);
c0027c8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c8d:	8d 50 08             	lea    0x8(%eax),%edx
c0027c90:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c93:	8b 50 04             	mov    0x4(%eax),%edx
c0027c96:	8b 00                	mov    (%eax),%eax
c0027c98:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027c9b:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027c9e:	eb 5d                	jmp    c0027cfd <__vprintf+0x186>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0027ca0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ca3:	8d 50 04             	lea    0x4(%eax),%edx
c0027ca6:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027ca9:	8b 00                	mov    (%eax),%eax
c0027cab:	99                   	cltd   
c0027cac:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027caf:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027cb2:	eb 49                	jmp    c0027cfd <__vprintf+0x186>
              case SIZET:
                value = va_arg (args, size_t);
c0027cb4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cb7:	8d 50 04             	lea    0x4(%eax),%edx
c0027cba:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027cbd:	8b 00                	mov    (%eax),%eax
c0027cbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027cc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                if (value > SIZE_MAX / 2)
c0027cc9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0027ccd:	78 2d                	js     c0027cfc <__vprintf+0x185>
c0027ccf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0027cd3:	7f 09                	jg     c0027cde <__vprintf+0x167>
c0027cd5:	81 7d f0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x10(%ebp)
c0027cdc:	76 1e                	jbe    c0027cfc <__vprintf+0x185>
                  value = value - SIZE_MAX - 1;
c0027cde:	ff 4d f4             	decl   -0xc(%ebp)
                break;
c0027ce1:	eb 19                	jmp    c0027cfc <__vprintf+0x185>
              default:
                NOT_REACHED ();
c0027ce3:	68 1c 11 03 c0       	push   $0xc003111c
c0027ce8:	68 50 13 03 c0       	push   $0xc0031350
c0027ced:	68 dc 00 00 00       	push   $0xdc
c0027cf2:	68 3e 11 03 c0       	push   $0xc003113e
c0027cf7:	e8 26 23 00 00       	call   c002a022 <debug_panic>
                break;
c0027cfc:	90                   	nop
              }

            format_integer (value < 0 ? -value : value,
c0027cfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027d00:	c1 e8 1f             	shr    $0x1f,%eax
c0027d03:	0f b6 c8             	movzbl %al,%ecx
c0027d06:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027d09:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027d0c:	85 d2                	test   %edx,%edx
c0027d0e:	79 07                	jns    c0027d17 <__vprintf+0x1a0>
c0027d10:	f7 d8                	neg    %eax
c0027d12:	83 d2 00             	adc    $0x0,%edx
c0027d15:	f7 da                	neg    %edx
c0027d17:	ff 75 14             	pushl  0x14(%ebp)
c0027d1a:	ff 75 10             	pushl  0x10(%ebp)
c0027d1d:	8d 5d cc             	lea    -0x34(%ebp),%ebx
c0027d20:	53                   	push   %ebx
c0027d21:	68 a8 10 03 c0       	push   $0xc00310a8
c0027d26:	51                   	push   %ecx
c0027d27:	6a 01                	push   $0x1
c0027d29:	52                   	push   %edx
c0027d2a:	50                   	push   %eax
c0027d2b:	e8 3f 05 00 00       	call   c002826f <format_integer>
c0027d30:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c0027d33:	e9 6d 02 00 00       	jmp    c0027fa5 <__vprintf+0x42e>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c0027d38:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027d3b:	83 f8 08             	cmp    $0x8,%eax
c0027d3e:	0f 87 d3 00 00 00    	ja     c0027e17 <__vprintf+0x2a0>
c0027d44:	8b 04 85 78 12 03 c0 	mov    -0x3ffced88(,%eax,4),%eax
c0027d4b:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c0027d4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d50:	8d 50 04             	lea    0x4(%eax),%edx
c0027d53:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027d56:	8b 00                	mov    (%eax),%eax
c0027d58:	0f b6 c0             	movzbl %al,%eax
c0027d5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027d5e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027d65:	e9 c6 00 00 00       	jmp    c0027e30 <__vprintf+0x2b9>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c0027d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d6d:	8d 50 04             	lea    0x4(%eax),%edx
c0027d70:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027d73:	8b 00                	mov    (%eax),%eax
c0027d75:	0f b7 c0             	movzwl %ax,%eax
c0027d78:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027d7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027d82:	e9 a9 00 00 00       	jmp    c0027e30 <__vprintf+0x2b9>
              case INT:
                value = va_arg (args, unsigned);
c0027d87:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d8a:	8d 50 04             	lea    0x4(%eax),%edx
c0027d8d:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027d90:	8b 00                	mov    (%eax),%eax
c0027d92:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027d95:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027d9c:	e9 8f 00 00 00       	jmp    c0027e30 <__vprintf+0x2b9>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c0027da1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027da4:	8d 50 08             	lea    0x8(%eax),%edx
c0027da7:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027daa:	8b 50 04             	mov    0x4(%eax),%edx
c0027dad:	8b 00                	mov    (%eax),%eax
c0027daf:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027db2:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c0027db5:	eb 79                	jmp    c0027e30 <__vprintf+0x2b9>
              case LONG:
                value = va_arg (args, unsigned long);
c0027db7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dba:	8d 50 04             	lea    0x4(%eax),%edx
c0027dbd:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027dc0:	8b 00                	mov    (%eax),%eax
c0027dc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027dc5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027dcc:	eb 62                	jmp    c0027e30 <__vprintf+0x2b9>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c0027dce:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dd1:	8d 50 08             	lea    0x8(%eax),%edx
c0027dd4:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027dd7:	8b 50 04             	mov    0x4(%eax),%edx
c0027dda:	8b 00                	mov    (%eax),%eax
c0027ddc:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027ddf:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c0027de2:	eb 4c                	jmp    c0027e30 <__vprintf+0x2b9>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0027de4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027de7:	8d 50 04             	lea    0x4(%eax),%edx
c0027dea:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027ded:	8b 00                	mov    (%eax),%eax
c0027def:	99                   	cltd   
c0027df0:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027df3:	89 55 ec             	mov    %edx,-0x14(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027df6:	83 65 e8 ff          	andl   $0xffffffff,-0x18(%ebp)
c0027dfa:	83 65 ec 00          	andl   $0x0,-0x14(%ebp)
#endif
                break;
c0027dfe:	eb 30                	jmp    c0027e30 <__vprintf+0x2b9>
              case SIZET:
                value = va_arg (args, size_t);
c0027e00:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e03:	8d 50 04             	lea    0x4(%eax),%edx
c0027e06:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027e09:	8b 00                	mov    (%eax),%eax
c0027e0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027e0e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027e15:	eb 19                	jmp    c0027e30 <__vprintf+0x2b9>
              default:
                NOT_REACHED ();
c0027e17:	68 1c 11 03 c0       	push   $0xc003111c
c0027e1c:	68 50 13 03 c0       	push   $0xc0031350
c0027e21:	68 0b 01 00 00       	push   $0x10b
c0027e26:	68 3e 11 03 c0       	push   $0xc003113e
c0027e2b:	e8 f2 21 00 00       	call   c002a022 <debug_panic>
              }

            switch (*format) 
c0027e30:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e33:	8a 00                	mov    (%eax),%al
c0027e35:	0f be c0             	movsbl %al,%eax
c0027e38:	83 f8 6f             	cmp    $0x6f,%eax
c0027e3b:	74 18                	je     c0027e55 <__vprintf+0x2de>
c0027e3d:	83 f8 6f             	cmp    $0x6f,%eax
c0027e40:	7f 07                	jg     c0027e49 <__vprintf+0x2d2>
c0027e42:	83 f8 58             	cmp    $0x58,%eax
c0027e45:	74 29                	je     c0027e70 <__vprintf+0x2f9>
c0027e47:	eb 30                	jmp    c0027e79 <__vprintf+0x302>
c0027e49:	83 f8 75             	cmp    $0x75,%eax
c0027e4c:	74 10                	je     c0027e5e <__vprintf+0x2e7>
c0027e4e:	83 f8 78             	cmp    $0x78,%eax
c0027e51:	74 14                	je     c0027e67 <__vprintf+0x2f0>
c0027e53:	eb 24                	jmp    c0027e79 <__vprintf+0x302>
              {
              case 'o': b = &base_o; break;
c0027e55:	c7 45 e4 c4 10 03 c0 	movl   $0xc00310c4,-0x1c(%ebp)
c0027e5c:	eb 34                	jmp    c0027e92 <__vprintf+0x31b>
              case 'u': b = &base_d; break;
c0027e5e:	c7 45 e4 a8 10 03 c0 	movl   $0xc00310a8,-0x1c(%ebp)
c0027e65:	eb 2b                	jmp    c0027e92 <__vprintf+0x31b>
              case 'x': b = &base_x; break;
c0027e67:	c7 45 e4 e8 10 03 c0 	movl   $0xc00310e8,-0x1c(%ebp)
c0027e6e:	eb 22                	jmp    c0027e92 <__vprintf+0x31b>
              case 'X': b = &base_X; break;
c0027e70:	c7 45 e4 0c 11 03 c0 	movl   $0xc003110c,-0x1c(%ebp)
c0027e77:	eb 19                	jmp    c0027e92 <__vprintf+0x31b>
              default: NOT_REACHED ();
c0027e79:	68 1c 11 03 c0       	push   $0xc003111c
c0027e7e:	68 50 13 03 c0       	push   $0xc0031350
c0027e83:	68 14 01 00 00       	push   $0x114
c0027e88:	68 3e 11 03 c0       	push   $0xc003113e
c0027e8d:	e8 90 21 00 00       	call   c002a022 <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c0027e92:	ff 75 14             	pushl  0x14(%ebp)
c0027e95:	ff 75 10             	pushl  0x10(%ebp)
c0027e98:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027e9b:	50                   	push   %eax
c0027e9c:	ff 75 e4             	pushl  -0x1c(%ebp)
c0027e9f:	6a 00                	push   $0x0
c0027ea1:	6a 00                	push   $0x0
c0027ea3:	ff 75 ec             	pushl  -0x14(%ebp)
c0027ea6:	ff 75 e8             	pushl  -0x18(%ebp)
c0027ea9:	e8 c1 03 00 00       	call   c002826f <format_integer>
c0027eae:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027eb1:	e9 ef 00 00 00       	jmp    c0027fa5 <__vprintf+0x42e>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c0027eb6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027eb9:	8d 50 04             	lea    0x4(%eax),%edx
c0027ebc:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027ebf:	8b 00                	mov    (%eax),%eax
c0027ec1:	88 45 cb             	mov    %al,-0x35(%ebp)
            format_string (&ch, 1, &c, output, aux);
c0027ec4:	83 ec 0c             	sub    $0xc,%esp
c0027ec7:	ff 75 14             	pushl  0x14(%ebp)
c0027eca:	ff 75 10             	pushl  0x10(%ebp)
c0027ecd:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027ed0:	50                   	push   %eax
c0027ed1:	6a 01                	push   $0x1
c0027ed3:	8d 45 cb             	lea    -0x35(%ebp),%eax
c0027ed6:	50                   	push   %eax
c0027ed7:	e8 ed 06 00 00       	call   c00285c9 <format_string>
c0027edc:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027edf:	e9 c1 00 00 00       	jmp    c0027fa5 <__vprintf+0x42e>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c0027ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ee7:	8d 50 04             	lea    0x4(%eax),%edx
c0027eea:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027eed:	8b 00                	mov    (%eax),%eax
c0027eef:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (s == NULL)
c0027ef2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027ef6:	75 07                	jne    c0027eff <__vprintf+0x388>
              s = "(null)";
c0027ef8:	c7 45 e0 50 11 03 c0 	movl   $0xc0031150,-0x20(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027eff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027f02:	83 ec 08             	sub    $0x8,%esp
c0027f05:	50                   	push   %eax
c0027f06:	ff 75 e0             	pushl  -0x20(%ebp)
c0027f09:	e8 c2 14 00 00       	call   c00293d0 <strnlen>
c0027f0e:	83 c4 10             	add    $0x10,%esp
c0027f11:	89 c2                	mov    %eax,%edx
c0027f13:	83 ec 0c             	sub    $0xc,%esp
c0027f16:	ff 75 14             	pushl  0x14(%ebp)
c0027f19:	ff 75 10             	pushl  0x10(%ebp)
c0027f1c:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027f1f:	50                   	push   %eax
c0027f20:	52                   	push   %edx
c0027f21:	ff 75 e0             	pushl  -0x20(%ebp)
c0027f24:	e8 a0 06 00 00       	call   c00285c9 <format_string>
c0027f29:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027f2c:	eb 77                	jmp    c0027fa5 <__vprintf+0x42e>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0027f2e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f31:	8d 50 04             	lea    0x4(%eax),%edx
c0027f34:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027f37:	8b 00                	mov    (%eax),%eax
c0027f39:	89 45 dc             	mov    %eax,-0x24(%ebp)

            c.flags = POUND;
c0027f3c:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%ebp)
            format_integer ((uintptr_t) p, false, false,
c0027f43:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027f46:	ba 00 00 00 00       	mov    $0x0,%edx
c0027f4b:	ff 75 14             	pushl  0x14(%ebp)
c0027f4e:	ff 75 10             	pushl  0x10(%ebp)
c0027f51:	8d 4d cc             	lea    -0x34(%ebp),%ecx
c0027f54:	51                   	push   %ecx
c0027f55:	68 e8 10 03 c0       	push   $0xc00310e8
c0027f5a:	6a 00                	push   $0x0
c0027f5c:	6a 00                	push   $0x0
c0027f5e:	52                   	push   %edx
c0027f5f:	50                   	push   %eax
c0027f60:	e8 0a 03 00 00       	call   c002826f <format_integer>
c0027f65:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c0027f68:	eb 3b                	jmp    c0027fa5 <__vprintf+0x42e>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027f6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f6d:	8a 00                	mov    (%eax),%al
c0027f6f:	0f be c0             	movsbl %al,%eax
c0027f72:	50                   	push   %eax
c0027f73:	ff 75 14             	pushl  0x14(%ebp)
c0027f76:	ff 75 10             	pushl  0x10(%ebp)
c0027f79:	68 57 11 03 c0       	push   $0xc0031157
c0027f7e:	e8 e1 06 00 00       	call   c0028664 <__printf>
c0027f83:	83 c4 10             	add    $0x10,%esp
          break;
c0027f86:	eb 1d                	jmp    c0027fa5 <__vprintf+0x42e>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027f88:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f8b:	8a 00                	mov    (%eax),%al
c0027f8d:	0f be c0             	movsbl %al,%eax
c0027f90:	50                   	push   %eax
c0027f91:	ff 75 14             	pushl  0x14(%ebp)
c0027f94:	ff 75 10             	pushl  0x10(%ebp)
c0027f97:	68 6d 11 03 c0       	push   $0xc003116d
c0027f9c:	e8 c3 06 00 00       	call   c0028664 <__printf>
c0027fa1:	83 c4 10             	add    $0x10,%esp
          break;
c0027fa4:	90                   	nop
  for (; *format != '\0'; format++)
c0027fa5:	ff 45 08             	incl   0x8(%ebp)
c0027fa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fab:	8a 00                	mov    (%eax),%al
c0027fad:	84 c0                	test   %al,%al
c0027faf:	0f 85 ce fb ff ff    	jne    c0027b83 <__vprintf+0xc>
        }
    }
}
c0027fb5:	90                   	nop
c0027fb6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027fb9:	c9                   	leave  
c0027fba:	c3                   	ret    

c0027fbb <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c0027fbb:	55                   	push   %ebp
c0027fbc:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c0027fbe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027fc1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c0027fc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fca:	8d 50 01             	lea    0x1(%eax),%edx
c0027fcd:	89 55 08             	mov    %edx,0x8(%ebp)
c0027fd0:	8a 00                	mov    (%eax),%al
c0027fd2:	0f be c0             	movsbl %al,%eax
c0027fd5:	83 e8 20             	sub    $0x20,%eax
c0027fd8:	83 f8 10             	cmp    $0x10,%eax
c0027fdb:	77 6f                	ja     c002804c <parse_conversion+0x91>
c0027fdd:	8b 04 85 9c 12 03 c0 	mov    -0x3ffced64(,%eax,4),%eax
c0027fe4:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c0027fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027fe9:	8b 00                	mov    (%eax),%eax
c0027feb:	83 c8 01             	or     $0x1,%eax
c0027fee:	89 c2                	mov    %eax,%edx
c0027ff0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ff3:	89 10                	mov    %edx,(%eax)
          break;
c0027ff5:	eb 67                	jmp    c002805e <parse_conversion+0xa3>
        case '+':
          c->flags |= PLUS;
c0027ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ffa:	8b 00                	mov    (%eax),%eax
c0027ffc:	83 c8 02             	or     $0x2,%eax
c0027fff:	89 c2                	mov    %eax,%edx
c0028001:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028004:	89 10                	mov    %edx,(%eax)
          break;
c0028006:	eb 56                	jmp    c002805e <parse_conversion+0xa3>
        case ' ':
          c->flags |= SPACE;
c0028008:	8b 45 0c             	mov    0xc(%ebp),%eax
c002800b:	8b 00                	mov    (%eax),%eax
c002800d:	83 c8 04             	or     $0x4,%eax
c0028010:	89 c2                	mov    %eax,%edx
c0028012:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028015:	89 10                	mov    %edx,(%eax)
          break;
c0028017:	eb 45                	jmp    c002805e <parse_conversion+0xa3>
        case '#':
          c->flags |= POUND;
c0028019:	8b 45 0c             	mov    0xc(%ebp),%eax
c002801c:	8b 00                	mov    (%eax),%eax
c002801e:	83 c8 08             	or     $0x8,%eax
c0028021:	89 c2                	mov    %eax,%edx
c0028023:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028026:	89 10                	mov    %edx,(%eax)
          break;
c0028028:	eb 34                	jmp    c002805e <parse_conversion+0xa3>
        case '0':
          c->flags |= ZERO;
c002802a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002802d:	8b 00                	mov    (%eax),%eax
c002802f:	83 c8 10             	or     $0x10,%eax
c0028032:	89 c2                	mov    %eax,%edx
c0028034:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028037:	89 10                	mov    %edx,(%eax)
          break;
c0028039:	eb 23                	jmp    c002805e <parse_conversion+0xa3>
        case '\'':
          c->flags |= GROUP;
c002803b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002803e:	8b 00                	mov    (%eax),%eax
c0028040:	83 c8 20             	or     $0x20,%eax
c0028043:	89 c2                	mov    %eax,%edx
c0028045:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028048:	89 10                	mov    %edx,(%eax)
          break;
c002804a:	eb 12                	jmp    c002805e <parse_conversion+0xa3>
        default:
          format--;
c002804c:	ff 4d 08             	decl   0x8(%ebp)
          goto not_a_flag;
c002804f:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c0028050:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028053:	8b 00                	mov    (%eax),%eax
c0028055:	83 e0 01             	and    $0x1,%eax
c0028058:	85 c0                	test   %eax,%eax
c002805a:	74 16                	je     c0028072 <parse_conversion+0xb7>
c002805c:	eb 05                	jmp    c0028063 <parse_conversion+0xa8>
      switch (*format++) 
c002805e:	e9 64 ff ff ff       	jmp    c0027fc7 <parse_conversion+0xc>
    c->flags &= ~ZERO;
c0028063:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028066:	8b 00                	mov    (%eax),%eax
c0028068:	83 e0 ef             	and    $0xffffffef,%eax
c002806b:	89 c2                	mov    %eax,%edx
c002806d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028070:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c0028072:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028075:	8b 00                	mov    (%eax),%eax
c0028077:	83 e0 02             	and    $0x2,%eax
c002807a:	85 c0                	test   %eax,%eax
c002807c:	74 0f                	je     c002808d <parse_conversion+0xd2>
    c->flags &= ~SPACE;
c002807e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028081:	8b 00                	mov    (%eax),%eax
c0028083:	83 e0 fb             	and    $0xfffffffb,%eax
c0028086:	89 c2                	mov    %eax,%edx
c0028088:	8b 45 0c             	mov    0xc(%ebp),%eax
c002808b:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c002808d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028090:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c0028097:	8b 45 08             	mov    0x8(%ebp),%eax
c002809a:	8a 00                	mov    (%eax),%al
c002809c:	3c 2a                	cmp    $0x2a,%al
c002809e:	75 41                	jne    c00280e1 <parse_conversion+0x126>
    {
      format++;
c00280a0:	ff 45 08             	incl   0x8(%ebp)
      c->width = va_arg (*args, int);
c00280a3:	8b 45 10             	mov    0x10(%ebp),%eax
c00280a6:	8b 00                	mov    (%eax),%eax
c00280a8:	8d 48 04             	lea    0x4(%eax),%ecx
c00280ab:	8b 55 10             	mov    0x10(%ebp),%edx
c00280ae:	89 0a                	mov    %ecx,(%edx)
c00280b0:	8b 10                	mov    (%eax),%edx
c00280b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00280b5:	89 50 04             	mov    %edx,0x4(%eax)
c00280b8:	eb 3c                	jmp    c00280f6 <parse_conversion+0x13b>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c00280ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00280bd:	8b 50 04             	mov    0x4(%eax),%edx
c00280c0:	89 d0                	mov    %edx,%eax
c00280c2:	c1 e0 02             	shl    $0x2,%eax
c00280c5:	01 d0                	add    %edx,%eax
c00280c7:	01 c0                	add    %eax,%eax
c00280c9:	89 c2                	mov    %eax,%edx
c00280cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00280ce:	8a 00                	mov    (%eax),%al
c00280d0:	0f be c0             	movsbl %al,%eax
c00280d3:	01 d0                	add    %edx,%eax
c00280d5:	8d 50 d0             	lea    -0x30(%eax),%edx
c00280d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00280db:	89 50 04             	mov    %edx,0x4(%eax)
      for (; isdigit (*format); format++)
c00280de:	ff 45 08             	incl   0x8(%ebp)
c00280e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00280e4:	8a 00                	mov    (%eax),%al
c00280e6:	0f be c0             	movsbl %al,%eax
c00280e9:	50                   	push   %eax
c00280ea:	e8 70 f9 ff ff       	call   c0027a5f <isdigit>
c00280ef:	83 c4 04             	add    $0x4,%esp
c00280f2:	85 c0                	test   %eax,%eax
c00280f4:	75 c4                	jne    c00280ba <parse_conversion+0xff>
    }
  if (c->width < 0) 
c00280f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00280f9:	8b 40 04             	mov    0x4(%eax),%eax
c00280fc:	85 c0                	test   %eax,%eax
c00280fe:	79 1f                	jns    c002811f <parse_conversion+0x164>
    {
      c->width = -c->width;
c0028100:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028103:	8b 40 04             	mov    0x4(%eax),%eax
c0028106:	f7 d8                	neg    %eax
c0028108:	89 c2                	mov    %eax,%edx
c002810a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002810d:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c0028110:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028113:	8b 00                	mov    (%eax),%eax
c0028115:	83 c8 01             	or     $0x1,%eax
c0028118:	89 c2                	mov    %eax,%edx
c002811a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002811d:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c002811f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028122:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0028129:	8b 45 08             	mov    0x8(%ebp),%eax
c002812c:	8a 00                	mov    (%eax),%al
c002812e:	3c 2e                	cmp    $0x2e,%al
c0028130:	0f 85 82 00 00 00    	jne    c00281b8 <parse_conversion+0x1fd>
    {
      format++;
c0028136:	ff 45 08             	incl   0x8(%ebp)
      if (*format == '*') 
c0028139:	8b 45 08             	mov    0x8(%ebp),%eax
c002813c:	8a 00                	mov    (%eax),%al
c002813e:	3c 2a                	cmp    $0x2a,%al
c0028140:	75 1a                	jne    c002815c <parse_conversion+0x1a1>
        {
          format++;
c0028142:	ff 45 08             	incl   0x8(%ebp)
          c->precision = va_arg (*args, int);
c0028145:	8b 45 10             	mov    0x10(%ebp),%eax
c0028148:	8b 00                	mov    (%eax),%eax
c002814a:	8d 48 04             	lea    0x4(%eax),%ecx
c002814d:	8b 55 10             	mov    0x10(%ebp),%edx
c0028150:	89 0a                	mov    %ecx,(%edx)
c0028152:	8b 10                	mov    (%eax),%edx
c0028154:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028157:	89 50 08             	mov    %edx,0x8(%eax)
c002815a:	eb 48                	jmp    c00281a4 <parse_conversion+0x1e9>
        }
      else 
        {
          c->precision = 0;
c002815c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002815f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c0028166:	eb 27                	jmp    c002818f <parse_conversion+0x1d4>
            c->precision = c->precision * 10 + *format - '0';
c0028168:	8b 45 0c             	mov    0xc(%ebp),%eax
c002816b:	8b 50 08             	mov    0x8(%eax),%edx
c002816e:	89 d0                	mov    %edx,%eax
c0028170:	c1 e0 02             	shl    $0x2,%eax
c0028173:	01 d0                	add    %edx,%eax
c0028175:	01 c0                	add    %eax,%eax
c0028177:	89 c2                	mov    %eax,%edx
c0028179:	8b 45 08             	mov    0x8(%ebp),%eax
c002817c:	8a 00                	mov    (%eax),%al
c002817e:	0f be c0             	movsbl %al,%eax
c0028181:	01 d0                	add    %edx,%eax
c0028183:	8d 50 d0             	lea    -0x30(%eax),%edx
c0028186:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028189:	89 50 08             	mov    %edx,0x8(%eax)
          for (; isdigit (*format); format++)
c002818c:	ff 45 08             	incl   0x8(%ebp)
c002818f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028192:	8a 00                	mov    (%eax),%al
c0028194:	0f be c0             	movsbl %al,%eax
c0028197:	50                   	push   %eax
c0028198:	e8 c2 f8 ff ff       	call   c0027a5f <isdigit>
c002819d:	83 c4 04             	add    $0x4,%esp
c00281a0:	85 c0                	test   %eax,%eax
c00281a2:	75 c4                	jne    c0028168 <parse_conversion+0x1ad>
        }
      if (c->precision < 0) 
c00281a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281a7:	8b 40 08             	mov    0x8(%eax),%eax
c00281aa:	85 c0                	test   %eax,%eax
c00281ac:	79 0a                	jns    c00281b8 <parse_conversion+0x1fd>
        c->precision = -1;
c00281ae:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281b1:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c00281b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281bb:	8b 40 08             	mov    0x8(%eax),%eax
c00281be:	85 c0                	test   %eax,%eax
c00281c0:	78 0f                	js     c00281d1 <parse_conversion+0x216>
    c->flags &= ~ZERO;
c00281c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281c5:	8b 00                	mov    (%eax),%eax
c00281c7:	83 e0 ef             	and    $0xffffffef,%eax
c00281ca:	89 c2                	mov    %eax,%edx
c00281cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281cf:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c00281d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281d4:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c00281db:	8b 45 08             	mov    0x8(%ebp),%eax
c00281de:	8d 50 01             	lea    0x1(%eax),%edx
c00281e1:	89 55 08             	mov    %edx,0x8(%ebp)
c00281e4:	8a 00                	mov    (%eax),%al
c00281e6:	0f be c0             	movsbl %al,%eax
c00281e9:	83 e8 68             	sub    $0x68,%eax
c00281ec:	83 f8 12             	cmp    $0x12,%eax
c00281ef:	77 75                	ja     c0028266 <parse_conversion+0x2ab>
c00281f1:	8b 04 85 e0 12 03 c0 	mov    -0x3ffced20(,%eax,4),%eax
c00281f8:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c00281fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00281fd:	8a 00                	mov    (%eax),%al
c00281ff:	3c 68                	cmp    $0x68,%al
c0028201:	75 0f                	jne    c0028212 <parse_conversion+0x257>
        {
          format++;
c0028203:	ff 45 08             	incl   0x8(%ebp)
          c->type = CHAR;
c0028206:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028209:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0028210:	eb 58                	jmp    c002826a <parse_conversion+0x2af>
        c->type = SHORT;
c0028212:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028215:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c002821c:	eb 4c                	jmp    c002826a <parse_conversion+0x2af>
      
    case 'j':
      c->type = INTMAX;
c002821e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028221:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0028228:	eb 40                	jmp    c002826a <parse_conversion+0x2af>

    case 'l':
      if (*format == 'l')
c002822a:	8b 45 08             	mov    0x8(%ebp),%eax
c002822d:	8a 00                	mov    (%eax),%al
c002822f:	3c 6c                	cmp    $0x6c,%al
c0028231:	75 0f                	jne    c0028242 <parse_conversion+0x287>
        {
          format++;
c0028233:	ff 45 08             	incl   0x8(%ebp)
          c->type = LONGLONG;
c0028236:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028239:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0028240:	eb 28                	jmp    c002826a <parse_conversion+0x2af>
        c->type = LONG;
c0028242:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028245:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c002824c:	eb 1c                	jmp    c002826a <parse_conversion+0x2af>

    case 't':
      c->type = PTRDIFFT;
c002824e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028251:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0028258:	eb 10                	jmp    c002826a <parse_conversion+0x2af>

    case 'z':
      c->type = SIZET;
c002825a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002825d:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c0028264:	eb 04                	jmp    c002826a <parse_conversion+0x2af>

    default:
      format--;
c0028266:	ff 4d 08             	decl   0x8(%ebp)
      break;
c0028269:	90                   	nop
    }

  return format;
c002826a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002826d:	c9                   	leave  
c002826e:	c3                   	ret    

c002826f <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c002826f:	55                   	push   %ebp
c0028270:	89 e5                	mov    %esp,%ebp
c0028272:	57                   	push   %edi
c0028273:	56                   	push   %esi
c0028274:	53                   	push   %ebx
c0028275:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
c002827b:	8b 45 10             	mov    0x10(%ebp),%eax
c002827e:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
c0028284:	8b 5d 14             	mov    0x14(%ebp),%ebx
c0028287:	8b 45 08             	mov    0x8(%ebp),%eax
c002828a:	89 45 80             	mov    %eax,-0x80(%ebp)
c002828d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028290:	89 45 84             	mov    %eax,-0x7c(%ebp)
c0028293:	8a 85 6c ff ff ff    	mov    -0x94(%ebp),%al
c0028299:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
c002829f:	88 9d 78 ff ff ff    	mov    %bl,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c00282a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c00282ac:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c00282b3:	74 5c                	je     c0028311 <format_integer+0xa2>
    {
      if (c->flags & PLUS)
c00282b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00282b8:	8b 00                	mov    (%eax),%eax
c00282ba:	83 e0 02             	and    $0x2,%eax
c00282bd:	85 c0                	test   %eax,%eax
c00282bf:	74 1a                	je     c00282db <format_integer+0x6c>
        sign = negative ? '-' : '+';
c00282c1:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00282c8:	74 07                	je     c00282d1 <format_integer+0x62>
c00282ca:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00282cf:	eb 05                	jmp    c00282d6 <format_integer+0x67>
c00282d1:	b8 2b 00 00 00       	mov    $0x2b,%eax
c00282d6:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00282d9:	eb 36                	jmp    c0028311 <format_integer+0xa2>
      else if (c->flags & SPACE)
c00282db:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00282de:	8b 00                	mov    (%eax),%eax
c00282e0:	83 e0 04             	and    $0x4,%eax
c00282e3:	85 c0                	test   %eax,%eax
c00282e5:	74 1a                	je     c0028301 <format_integer+0x92>
        sign = negative ? '-' : ' ';
c00282e7:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00282ee:	74 07                	je     c00282f7 <format_integer+0x88>
c00282f0:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00282f5:	eb 05                	jmp    c00282fc <format_integer+0x8d>
c00282f7:	b8 20 00 00 00       	mov    $0x20,%eax
c00282fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00282ff:	eb 10                	jmp    c0028311 <format_integer+0xa2>
      else if (negative)
c0028301:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0028308:	74 07                	je     c0028311 <format_integer+0xa2>
        sign = '-';
c002830a:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0028311:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028314:	8b 00                	mov    (%eax),%eax
c0028316:	83 e0 08             	and    $0x8,%eax
c0028319:	85 c0                	test   %eax,%eax
c002831b:	74 20                	je     c002833d <format_integer+0xce>
c002831d:	8b 45 80             	mov    -0x80(%ebp),%eax
c0028320:	80 f4 00             	xor    $0x0,%ah
c0028323:	89 c2                	mov    %eax,%edx
c0028325:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0028328:	80 f4 00             	xor    $0x0,%ah
c002832b:	89 c1                	mov    %eax,%ecx
c002832d:	89 c8                	mov    %ecx,%eax
c002832f:	09 d0                	or     %edx,%eax
c0028331:	85 c0                	test   %eax,%eax
c0028333:	74 08                	je     c002833d <format_integer+0xce>
c0028335:	8b 45 18             	mov    0x18(%ebp),%eax
c0028338:	8b 40 08             	mov    0x8(%eax),%eax
c002833b:	eb 05                	jmp    c0028342 <format_integer+0xd3>
c002833d:	b8 00 00 00 00       	mov    $0x0,%eax
c0028342:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0028345:	8d 45 90             	lea    -0x70(%ebp),%eax
c0028348:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c002834b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c0028352:	e9 82 00 00 00       	jmp    c00283d9 <format_integer+0x16a>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0028357:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002835a:	8b 00                	mov    (%eax),%eax
c002835c:	83 e0 20             	and    $0x20,%eax
c002835f:	85 c0                	test   %eax,%eax
c0028361:	74 24                	je     c0028387 <format_integer+0x118>
c0028363:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0028367:	7e 1e                	jle    c0028387 <format_integer+0x118>
c0028369:	8b 45 18             	mov    0x18(%ebp),%eax
c002836c:	8b 48 0c             	mov    0xc(%eax),%ecx
c002836f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028372:	99                   	cltd   
c0028373:	f7 f9                	idiv   %ecx
c0028375:	89 d0                	mov    %edx,%eax
c0028377:	85 c0                	test   %eax,%eax
c0028379:	75 0c                	jne    c0028387 <format_integer+0x118>
        *cp++ = ',';
c002837b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002837e:	8d 50 01             	lea    0x1(%eax),%edx
c0028381:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0028384:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c0028387:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c002838a:	8d 46 01             	lea    0x1(%esi),%eax
c002838d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0028390:	8b 45 18             	mov    0x18(%ebp),%eax
c0028393:	8b 78 04             	mov    0x4(%eax),%edi
c0028396:	8b 45 18             	mov    0x18(%ebp),%eax
c0028399:	8b 00                	mov    (%eax),%eax
c002839b:	89 c1                	mov    %eax,%ecx
c002839d:	89 c3                	mov    %eax,%ebx
c002839f:	c1 fb 1f             	sar    $0x1f,%ebx
c00283a2:	8b 45 80             	mov    -0x80(%ebp),%eax
c00283a5:	8b 55 84             	mov    -0x7c(%ebp),%edx
c00283a8:	53                   	push   %ebx
c00283a9:	51                   	push   %ecx
c00283aa:	52                   	push   %edx
c00283ab:	50                   	push   %eax
c00283ac:	e8 02 16 00 00       	call   c00299b3 <__umoddi3>
c00283b1:	83 c4 10             	add    $0x10,%esp
c00283b4:	01 f8                	add    %edi,%eax
c00283b6:	8a 00                	mov    (%eax),%al
c00283b8:	88 06                	mov    %al,(%esi)
      value /= b->base;
c00283ba:	8b 45 18             	mov    0x18(%ebp),%eax
c00283bd:	8b 00                	mov    (%eax),%eax
c00283bf:	99                   	cltd   
c00283c0:	52                   	push   %edx
c00283c1:	50                   	push   %eax
c00283c2:	ff 75 84             	pushl  -0x7c(%ebp)
c00283c5:	ff 75 80             	pushl  -0x80(%ebp)
c00283c8:	e8 b2 15 00 00       	call   c002997f <__udivdi3>
c00283cd:	83 c4 10             	add    $0x10,%esp
c00283d0:	89 45 80             	mov    %eax,-0x80(%ebp)
c00283d3:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c00283d6:	ff 45 d8             	incl   -0x28(%ebp)
  while (value > 0) 
c00283d9:	8b 45 80             	mov    -0x80(%ebp),%eax
c00283dc:	80 f4 00             	xor    $0x0,%ah
c00283df:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
c00283e5:	8b 45 84             	mov    -0x7c(%ebp),%eax
c00283e8:	80 f4 00             	xor    $0x0,%ah
c00283eb:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c00283f1:	8b 9d 70 ff ff ff    	mov    -0x90(%ebp),%ebx
c00283f7:	8b b5 74 ff ff ff    	mov    -0x8c(%ebp),%esi
c00283fd:	89 f0                	mov    %esi,%eax
c00283ff:	09 d8                	or     %ebx,%eax
c0028401:	85 c0                	test   %eax,%eax
c0028403:	0f 85 4e ff ff ff    	jne    c0028357 <format_integer+0xe8>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0028409:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002840c:	8b 40 08             	mov    0x8(%eax),%eax
c002840f:	85 c0                	test   %eax,%eax
c0028411:	78 08                	js     c002841b <format_integer+0x1ac>
c0028413:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028416:	8b 40 08             	mov    0x8(%eax),%eax
c0028419:	eb 05                	jmp    c0028420 <format_integer+0x1b1>
c002841b:	b8 01 00 00 00       	mov    $0x1,%eax
c0028420:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0028423:	eb 0c                	jmp    c0028431 <format_integer+0x1c2>
    *cp++ = '0';
c0028425:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028428:	8d 50 01             	lea    0x1(%eax),%edx
c002842b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002842e:	c6 00 30             	movb   $0x30,(%eax)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0028431:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0028434:	8d 45 90             	lea    -0x70(%ebp),%eax
c0028437:	29 c2                	sub    %eax,%edx
c0028439:	89 d0                	mov    %edx,%eax
c002843b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c002843e:	7d 0b                	jge    c002844b <format_integer+0x1dc>
c0028440:	8d 45 90             	lea    -0x70(%ebp),%eax
c0028443:	83 c0 3f             	add    $0x3f,%eax
c0028446:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0028449:	77 da                	ja     c0028425 <format_integer+0x1b6>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c002844b:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002844e:	8b 00                	mov    (%eax),%eax
c0028450:	83 e0 08             	and    $0x8,%eax
c0028453:	85 c0                	test   %eax,%eax
c0028455:	74 28                	je     c002847f <format_integer+0x210>
c0028457:	8b 45 18             	mov    0x18(%ebp),%eax
c002845a:	8b 00                	mov    (%eax),%eax
c002845c:	83 f8 08             	cmp    $0x8,%eax
c002845f:	75 1e                	jne    c002847f <format_integer+0x210>
c0028461:	8d 45 90             	lea    -0x70(%ebp),%eax
c0028464:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0028467:	74 0a                	je     c0028473 <format_integer+0x204>
c0028469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002846c:	48                   	dec    %eax
c002846d:	8a 00                	mov    (%eax),%al
c002846f:	3c 30                	cmp    $0x30,%al
c0028471:	74 0c                	je     c002847f <format_integer+0x210>
    *cp++ = '0';
c0028473:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028476:	8d 50 01             	lea    0x1(%eax),%edx
c0028479:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002847c:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c002847f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028482:	8b 40 04             	mov    0x4(%eax),%eax
c0028485:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0028488:	8d 55 90             	lea    -0x70(%ebp),%edx
c002848b:	29 d1                	sub    %edx,%ecx
c002848d:	89 ca                	mov    %ecx,%edx
c002848f:	29 d0                	sub    %edx,%eax
c0028491:	89 c2                	mov    %eax,%edx
c0028493:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028497:	74 07                	je     c00284a0 <format_integer+0x231>
c0028499:	b8 02 00 00 00       	mov    $0x2,%eax
c002849e:	eb 05                	jmp    c00284a5 <format_integer+0x236>
c00284a0:	b8 00 00 00 00       	mov    $0x0,%eax
c00284a5:	29 c2                	sub    %eax,%edx
c00284a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00284ab:	0f 95 c0             	setne  %al
c00284ae:	0f b6 c0             	movzbl %al,%eax
c00284b1:	29 c2                	sub    %eax,%edx
c00284b3:	89 d0                	mov    %edx,%eax
c00284b5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c00284b8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00284bc:	79 07                	jns    c00284c5 <format_integer+0x256>
    pad_cnt = 0;
c00284be:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c00284c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00284c8:	8b 00                	mov    (%eax),%eax
c00284ca:	83 e0 11             	and    $0x11,%eax
c00284cd:	85 c0                	test   %eax,%eax
c00284cf:	75 14                	jne    c00284e5 <format_integer+0x276>
    output_dup (' ', pad_cnt, output, aux);
c00284d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00284d4:	ff 75 24             	pushl  0x24(%ebp)
c00284d7:	ff 75 20             	pushl  0x20(%ebp)
c00284da:	50                   	push   %eax
c00284db:	6a 20                	push   $0x20
c00284dd:	e8 b6 00 00 00       	call   c0028598 <output_dup>
c00284e2:	83 c4 10             	add    $0x10,%esp
  if (sign)
c00284e5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00284e9:	74 15                	je     c0028500 <format_integer+0x291>
    output (sign, aux);
c00284eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284ee:	0f be c0             	movsbl %al,%eax
c00284f1:	83 ec 08             	sub    $0x8,%esp
c00284f4:	ff 75 24             	pushl  0x24(%ebp)
c00284f7:	50                   	push   %eax
c00284f8:	8b 45 20             	mov    0x20(%ebp),%eax
c00284fb:	ff d0                	call   *%eax
c00284fd:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0028500:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028504:	74 25                	je     c002852b <format_integer+0x2bc>
    {
      output ('0', aux);
c0028506:	83 ec 08             	sub    $0x8,%esp
c0028509:	ff 75 24             	pushl  0x24(%ebp)
c002850c:	6a 30                	push   $0x30
c002850e:	8b 45 20             	mov    0x20(%ebp),%eax
c0028511:	ff d0                	call   *%eax
c0028513:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c0028516:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0028519:	0f be c0             	movsbl %al,%eax
c002851c:	83 ec 08             	sub    $0x8,%esp
c002851f:	ff 75 24             	pushl  0x24(%ebp)
c0028522:	50                   	push   %eax
c0028523:	8b 45 20             	mov    0x20(%ebp),%eax
c0028526:	ff d0                	call   *%eax
c0028528:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c002852b:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002852e:	8b 00                	mov    (%eax),%eax
c0028530:	83 e0 10             	and    $0x10,%eax
c0028533:	85 c0                	test   %eax,%eax
c0028535:	74 30                	je     c0028567 <format_integer+0x2f8>
    output_dup ('0', pad_cnt, output, aux);
c0028537:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002853a:	ff 75 24             	pushl  0x24(%ebp)
c002853d:	ff 75 20             	pushl  0x20(%ebp)
c0028540:	50                   	push   %eax
c0028541:	6a 30                	push   $0x30
c0028543:	e8 50 00 00 00       	call   c0028598 <output_dup>
c0028548:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c002854b:	eb 1a                	jmp    c0028567 <format_integer+0x2f8>
    output (*--cp, aux);
c002854d:	ff 4d e4             	decl   -0x1c(%ebp)
c0028550:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028553:	8a 00                	mov    (%eax),%al
c0028555:	0f be c0             	movsbl %al,%eax
c0028558:	83 ec 08             	sub    $0x8,%esp
c002855b:	ff 75 24             	pushl  0x24(%ebp)
c002855e:	50                   	push   %eax
c002855f:	8b 45 20             	mov    0x20(%ebp),%eax
c0028562:	ff d0                	call   *%eax
c0028564:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0028567:	8d 45 90             	lea    -0x70(%ebp),%eax
c002856a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c002856d:	77 de                	ja     c002854d <format_integer+0x2de>
  if (c->flags & MINUS)
c002856f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028572:	8b 00                	mov    (%eax),%eax
c0028574:	83 e0 01             	and    $0x1,%eax
c0028577:	85 c0                	test   %eax,%eax
c0028579:	74 14                	je     c002858f <format_integer+0x320>
    output_dup (' ', pad_cnt, output, aux);
c002857b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002857e:	ff 75 24             	pushl  0x24(%ebp)
c0028581:	ff 75 20             	pushl  0x20(%ebp)
c0028584:	50                   	push   %eax
c0028585:	6a 20                	push   $0x20
c0028587:	e8 0c 00 00 00       	call   c0028598 <output_dup>
c002858c:	83 c4 10             	add    $0x10,%esp
}
c002858f:	90                   	nop
c0028590:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028593:	5b                   	pop    %ebx
c0028594:	5e                   	pop    %esi
c0028595:	5f                   	pop    %edi
c0028596:	5d                   	pop    %ebp
c0028597:	c3                   	ret    

c0028598 <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0028598:	55                   	push   %ebp
c0028599:	89 e5                	mov    %esp,%ebp
c002859b:	83 ec 18             	sub    $0x18,%esp
c002859e:	8b 45 08             	mov    0x8(%ebp),%eax
c00285a1:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c00285a4:	eb 13                	jmp    c00285b9 <output_dup+0x21>
    output (ch, aux);
c00285a6:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c00285aa:	83 ec 08             	sub    $0x8,%esp
c00285ad:	ff 75 14             	pushl  0x14(%ebp)
c00285b0:	50                   	push   %eax
c00285b1:	8b 45 10             	mov    0x10(%ebp),%eax
c00285b4:	ff d0                	call   *%eax
c00285b6:	83 c4 10             	add    $0x10,%esp
  while (cnt-- > 0)
c00285b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00285bc:	8d 50 ff             	lea    -0x1(%eax),%edx
c00285bf:	89 55 0c             	mov    %edx,0xc(%ebp)
c00285c2:	85 c0                	test   %eax,%eax
c00285c4:	75 e0                	jne    c00285a6 <output_dup+0xe>
}
c00285c6:	90                   	nop
c00285c7:	c9                   	leave  
c00285c8:	c3                   	ret    

c00285c9 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c00285c9:	55                   	push   %ebp
c00285ca:	89 e5                	mov    %esp,%ebp
c00285cc:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c00285cf:	8b 45 10             	mov    0x10(%ebp),%eax
c00285d2:	8b 40 04             	mov    0x4(%eax),%eax
c00285d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00285d8:	7e 26                	jle    c0028600 <format_string+0x37>
c00285da:	8b 45 10             	mov    0x10(%ebp),%eax
c00285dd:	8b 00                	mov    (%eax),%eax
c00285df:	83 e0 01             	and    $0x1,%eax
c00285e2:	85 c0                	test   %eax,%eax
c00285e4:	75 1a                	jne    c0028600 <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c00285e6:	8b 45 10             	mov    0x10(%ebp),%eax
c00285e9:	8b 40 04             	mov    0x4(%eax),%eax
c00285ec:	2b 45 0c             	sub    0xc(%ebp),%eax
c00285ef:	ff 75 18             	pushl  0x18(%ebp)
c00285f2:	ff 75 14             	pushl  0x14(%ebp)
c00285f5:	50                   	push   %eax
c00285f6:	6a 20                	push   $0x20
c00285f8:	e8 9b ff ff ff       	call   c0028598 <output_dup>
c00285fd:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0028600:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028607:	eb 1f                	jmp    c0028628 <format_string+0x5f>
    output (string[i], aux);
c0028609:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002860c:	8b 45 08             	mov    0x8(%ebp),%eax
c002860f:	01 d0                	add    %edx,%eax
c0028611:	8a 00                	mov    (%eax),%al
c0028613:	0f be c0             	movsbl %al,%eax
c0028616:	83 ec 08             	sub    $0x8,%esp
c0028619:	ff 75 18             	pushl  0x18(%ebp)
c002861c:	50                   	push   %eax
c002861d:	8b 45 14             	mov    0x14(%ebp),%eax
c0028620:	ff d0                	call   *%eax
c0028622:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0028625:	ff 45 f4             	incl   -0xc(%ebp)
c0028628:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002862b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002862e:	7c d9                	jl     c0028609 <format_string+0x40>
  if (c->width > length && (c->flags & MINUS) != 0)
c0028630:	8b 45 10             	mov    0x10(%ebp),%eax
c0028633:	8b 40 04             	mov    0x4(%eax),%eax
c0028636:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028639:	7e 26                	jle    c0028661 <format_string+0x98>
c002863b:	8b 45 10             	mov    0x10(%ebp),%eax
c002863e:	8b 00                	mov    (%eax),%eax
c0028640:	83 e0 01             	and    $0x1,%eax
c0028643:	85 c0                	test   %eax,%eax
c0028645:	74 1a                	je     c0028661 <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0028647:	8b 45 10             	mov    0x10(%ebp),%eax
c002864a:	8b 40 04             	mov    0x4(%eax),%eax
c002864d:	2b 45 0c             	sub    0xc(%ebp),%eax
c0028650:	ff 75 18             	pushl  0x18(%ebp)
c0028653:	ff 75 14             	pushl  0x14(%ebp)
c0028656:	50                   	push   %eax
c0028657:	6a 20                	push   $0x20
c0028659:	e8 3a ff ff ff       	call   c0028598 <output_dup>
c002865e:	83 c4 10             	add    $0x10,%esp
}
c0028661:	90                   	nop
c0028662:	c9                   	leave  
c0028663:	c3                   	ret    

c0028664 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0028664:	55                   	push   %ebp
c0028665:	89 e5                	mov    %esp,%ebp
c0028667:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c002866a:	8d 45 14             	lea    0x14(%ebp),%eax
c002866d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0028670:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028673:	ff 75 10             	pushl  0x10(%ebp)
c0028676:	ff 75 0c             	pushl  0xc(%ebp)
c0028679:	50                   	push   %eax
c002867a:	ff 75 08             	pushl  0x8(%ebp)
c002867d:	e8 f5 f4 ff ff       	call   c0027b77 <__vprintf>
c0028682:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0028685:	90                   	nop
c0028686:	c9                   	leave  
c0028687:	c3                   	ret    

c0028688 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0028688:	55                   	push   %ebp
c0028689:	89 e5                	mov    %esp,%ebp
c002868b:	83 ec 38             	sub    $0x38,%esp
c002868e:	8b 45 14             	mov    0x14(%ebp),%eax
c0028691:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0028694:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028697:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c002869a:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c00286a1:	e9 b4 01 00 00       	jmp    c002885a <hex_dump+0x1d2>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c00286a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00286a9:	ba 00 00 00 00       	mov    $0x0,%edx
c00286ae:	f7 75 e8             	divl   -0x18(%ebp)
c00286b1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c00286b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00286b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c00286ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00286bd:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00286c0:	3b 45 10             	cmp    0x10(%ebp),%eax
c00286c3:	76 0b                	jbe    c00286d0 <hex_dump+0x48>
        end = start + size;
c00286c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00286c8:	8b 45 10             	mov    0x10(%ebp),%eax
c00286cb:	01 d0                	add    %edx,%eax
c00286cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c00286d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00286d3:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00286d6:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c00286d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00286dc:	ba 00 00 00 00       	mov    $0x0,%edx
c00286e1:	f7 75 e8             	divl   -0x18(%ebp)
c00286e4:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c00286e8:	ba 00 00 00 00       	mov    $0x0,%edx
c00286ed:	83 ec 04             	sub    $0x4,%esp
c00286f0:	52                   	push   %edx
c00286f1:	50                   	push   %eax
c00286f2:	68 2c 13 03 c0       	push   $0xc003132c
c00286f7:	e8 55 f4 ff ff       	call   c0027b51 <printf>
c00286fc:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c00286ff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0028706:	eb 13                	jmp    c002871b <hex_dump+0x93>
        printf ("   ");
c0028708:	83 ec 0c             	sub    $0xc,%esp
c002870b:	68 34 13 03 c0       	push   $0xc0031334
c0028710:	e8 3c f4 ff ff       	call   c0027b51 <printf>
c0028715:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0028718:	ff 45 ec             	incl   -0x14(%ebp)
c002871b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002871e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0028721:	72 e5                	jb     c0028708 <hex_dump+0x80>
      for (; i < end; i++) 
c0028723:	eb 3e                	jmp    c0028763 <hex_dump+0xdb>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0028725:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028728:	d1 e8                	shr    %eax
c002872a:	48                   	dec    %eax
        printf ("%02hhx%c",
c002872b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002872e:	75 07                	jne    c0028737 <hex_dump+0xaf>
c0028730:	ba 2d 00 00 00       	mov    $0x2d,%edx
c0028735:	eb 05                	jmp    c002873c <hex_dump+0xb4>
c0028737:	ba 20 00 00 00       	mov    $0x20,%edx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c002873c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002873f:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028742:	89 c1                	mov    %eax,%ecx
c0028744:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028747:	01 c8                	add    %ecx,%eax
c0028749:	8a 00                	mov    (%eax),%al
        printf ("%02hhx%c",
c002874b:	0f b6 c0             	movzbl %al,%eax
c002874e:	83 ec 04             	sub    $0x4,%esp
c0028751:	52                   	push   %edx
c0028752:	50                   	push   %eax
c0028753:	68 38 13 03 c0       	push   $0xc0031338
c0028758:	e8 f4 f3 ff ff       	call   c0027b51 <printf>
c002875d:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
c0028760:	ff 45 ec             	incl   -0x14(%ebp)
c0028763:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028766:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028769:	72 ba                	jb     c0028725 <hex_dump+0x9d>
      if (ascii) 
c002876b:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c002876f:	0f 84 c6 00 00 00    	je     c002883b <hex_dump+0x1b3>
        {
          for (; i < per_line; i++)
c0028775:	eb 13                	jmp    c002878a <hex_dump+0x102>
            printf ("   ");
c0028777:	83 ec 0c             	sub    $0xc,%esp
c002877a:	68 34 13 03 c0       	push   $0xc0031334
c002877f:	e8 cd f3 ff ff       	call   c0027b51 <printf>
c0028784:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0028787:	ff 45 ec             	incl   -0x14(%ebp)
c002878a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002878d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0028790:	72 e5                	jb     c0028777 <hex_dump+0xef>
          printf ("|");
c0028792:	83 ec 0c             	sub    $0xc,%esp
c0028795:	6a 7c                	push   $0x7c
c0028797:	e8 cc 3a 00 00       	call   c002c268 <putchar>
c002879c:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c002879f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c00287a6:	eb 10                	jmp    c00287b8 <hex_dump+0x130>
            printf (" ");
c00287a8:	83 ec 0c             	sub    $0xc,%esp
c00287ab:	6a 20                	push   $0x20
c00287ad:	e8 b6 3a 00 00       	call   c002c268 <putchar>
c00287b2:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c00287b5:	ff 45 ec             	incl   -0x14(%ebp)
c00287b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00287bb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00287be:	72 e8                	jb     c00287a8 <hex_dump+0x120>
          for (; i < end; i++)
c00287c0:	eb 4a                	jmp    c002880c <hex_dump+0x184>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00287c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00287c5:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00287c8:	89 c2                	mov    %eax,%edx
c00287ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287cd:	01 d0                	add    %edx,%eax
c00287cf:	8a 00                	mov    (%eax),%al
c00287d1:	0f b6 c0             	movzbl %al,%eax
c00287d4:	83 ec 0c             	sub    $0xc,%esp
c00287d7:	50                   	push   %eax
c00287d8:	e8 9f f2 ff ff       	call   c0027a7c <isprint>
c00287dd:	83 c4 10             	add    $0x10,%esp
            printf ("%c",
c00287e0:	85 c0                	test   %eax,%eax
c00287e2:	74 14                	je     c00287f8 <hex_dump+0x170>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00287e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00287e7:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00287ea:	89 c2                	mov    %eax,%edx
c00287ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287ef:	01 d0                	add    %edx,%eax
c00287f1:	8a 00                	mov    (%eax),%al
            printf ("%c",
c00287f3:	0f b6 c0             	movzbl %al,%eax
c00287f6:	eb 05                	jmp    c00287fd <hex_dump+0x175>
c00287f8:	b8 2e 00 00 00       	mov    $0x2e,%eax
c00287fd:	83 ec 0c             	sub    $0xc,%esp
c0028800:	50                   	push   %eax
c0028801:	e8 62 3a 00 00       	call   c002c268 <putchar>
c0028806:	83 c4 10             	add    $0x10,%esp
          for (; i < end; i++)
c0028809:	ff 45 ec             	incl   -0x14(%ebp)
c002880c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002880f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028812:	72 ae                	jb     c00287c2 <hex_dump+0x13a>
          for (; i < per_line; i++)
c0028814:	eb 10                	jmp    c0028826 <hex_dump+0x19e>
            printf (" ");
c0028816:	83 ec 0c             	sub    $0xc,%esp
c0028819:	6a 20                	push   $0x20
c002881b:	e8 48 3a 00 00       	call   c002c268 <putchar>
c0028820:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0028823:	ff 45 ec             	incl   -0x14(%ebp)
c0028826:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028829:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002882c:	72 e8                	jb     c0028816 <hex_dump+0x18e>
          printf ("|");
c002882e:	83 ec 0c             	sub    $0xc,%esp
c0028831:	6a 7c                	push   $0x7c
c0028833:	e8 30 3a 00 00       	call   c002c268 <putchar>
c0028838:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c002883b:	83 ec 0c             	sub    $0xc,%esp
c002883e:	6a 0a                	push   $0xa
c0028840:	e8 23 3a 00 00       	call   c002c268 <putchar>
c0028845:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c0028848:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002884b:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c002884e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028851:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c0028854:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028857:	29 45 10             	sub    %eax,0x10(%ebp)
  while (size > 0)
c002885a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002885e:	0f 85 42 fe ff ff    	jne    c00286a6 <hex_dump+0x1e>
    }
}
c0028864:	90                   	nop
c0028865:	c9                   	leave  
c0028866:	c3                   	ret    

c0028867 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0028867:	55                   	push   %ebp
c0028868:	89 e5                	mov    %esp,%ebp
c002886a:	83 ec 28             	sub    $0x28,%esp
c002886d:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0028870:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0028873:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0028876:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if (size == 1)
c0028879:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002887c:	83 f1 01             	xor    $0x1,%ecx
c002887f:	89 c8                	mov    %ecx,%eax
c0028881:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0028884:	80 f5 00             	xor    $0x0,%ch
c0028887:	89 ca                	mov    %ecx,%edx
c0028889:	09 d0                	or     %edx,%eax
c002888b:	85 c0                	test   %eax,%eax
c002888d:	75 12                	jne    c00288a1 <print_human_readable_size+0x3a>
    printf ("1 byte");
c002888f:	83 ec 0c             	sub    $0xc,%esp
c0028892:	68 41 13 03 c0       	push   $0xc0031341
c0028897:	e8 b5 f2 ff ff       	call   c0027b51 <printf>
c002889c:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c002889f:	eb 5a                	jmp    c00288fb <print_human_readable_size+0x94>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00288a1:	c7 45 f4 e8 83 03 c0 	movl   $0xc00383e8,-0xc(%ebp)
c00288a8:	eb 17                	jmp    c00288c1 <print_human_readable_size+0x5a>
        size /= 1024;
c00288aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00288ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00288b0:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c00288b4:	c1 ea 0a             	shr    $0xa,%edx
c00288b7:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00288ba:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00288bd:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c00288c1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00288c5:	72 1b                	jb     c00288e2 <print_human_readable_size+0x7b>
c00288c7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00288cb:	77 09                	ja     c00288d6 <print_human_readable_size+0x6f>
c00288cd:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c00288d4:	76 0c                	jbe    c00288e2 <print_human_readable_size+0x7b>
c00288d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00288d9:	83 c0 04             	add    $0x4,%eax
c00288dc:	8b 00                	mov    (%eax),%eax
c00288de:	85 c0                	test   %eax,%eax
c00288e0:	75 c8                	jne    c00288aa <print_human_readable_size+0x43>
      printf ("%"PRIu64" %s", size, *fp);
c00288e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00288e5:	8b 00                	mov    (%eax),%eax
c00288e7:	50                   	push   %eax
c00288e8:	ff 75 e4             	pushl  -0x1c(%ebp)
c00288eb:	ff 75 e0             	pushl  -0x20(%ebp)
c00288ee:	68 48 13 03 c0       	push   $0xc0031348
c00288f3:	e8 59 f2 ff ff       	call   c0027b51 <printf>
c00288f8:	83 c4 10             	add    $0x10,%esp
}
c00288fb:	90                   	nop
c00288fc:	c9                   	leave  
c00288fd:	c3                   	ret    

c00288fe <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00288fe:	55                   	push   %ebp
c00288ff:	89 e5                	mov    %esp,%ebp
c0028901:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0028905:	7e 0d                	jle    c0028914 <isdigit+0x16>
c0028907:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c002890b:	7f 07                	jg     c0028914 <isdigit+0x16>
c002890d:	b8 01 00 00 00       	mov    $0x1,%eax
c0028912:	eb 05                	jmp    c0028919 <isdigit+0x1b>
c0028914:	b8 00 00 00 00       	mov    $0x0,%eax
c0028919:	5d                   	pop    %ebp
c002891a:	c3                   	ret    

c002891b <isspace>:
static inline int isspace (int c) {
c002891b:	55                   	push   %ebp
c002891c:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c002891e:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0028922:	74 1e                	je     c0028942 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0028924:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0028928:	74 18                	je     c0028942 <isspace+0x27>
c002892a:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c002892e:	74 12                	je     c0028942 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0028930:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0028934:	74 0c                	je     c0028942 <isspace+0x27>
c0028936:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c002893a:	74 06                	je     c0028942 <isspace+0x27>
c002893c:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0028940:	75 07                	jne    c0028949 <isspace+0x2e>
c0028942:	b8 01 00 00 00       	mov    $0x1,%eax
c0028947:	eb 05                	jmp    c002894e <isspace+0x33>
c0028949:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002894e:	5d                   	pop    %ebp
c002894f:	c3                   	ret    

c0028950 <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c0028950:	55                   	push   %ebp
c0028951:	89 e5                	mov    %esp,%ebp
c0028953:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c0028956:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002895a:	75 21                	jne    c002897d <atoi+0x2d>
c002895c:	83 ec 0c             	sub    $0xc,%esp
c002895f:	68 6c 13 03 c0       	push   $0xc003136c
c0028964:	68 76 13 03 c0       	push   $0xc0031376
c0028969:	68 d4 13 03 c0       	push   $0xc00313d4
c002896e:	6a 0f                	push   $0xf
c0028970:	68 8d 13 03 c0       	push   $0xc003138d
c0028975:	e8 a8 16 00 00       	call   c002a022 <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c002897a:	ff 45 08             	incl   0x8(%ebp)
  while (isspace ((unsigned char) *s))
c002897d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028980:	8a 00                	mov    (%eax),%al
c0028982:	0f b6 c0             	movzbl %al,%eax
c0028985:	83 ec 0c             	sub    $0xc,%esp
c0028988:	50                   	push   %eax
c0028989:	e8 8d ff ff ff       	call   c002891b <isspace>
c002898e:	83 c4 10             	add    $0x10,%esp
c0028991:	85 c0                	test   %eax,%eax
c0028993:	75 e5                	jne    c002897a <atoi+0x2a>

  /* Parse sign. */
  negative = false;
c0028995:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0028999:	8b 45 08             	mov    0x8(%ebp),%eax
c002899c:	8a 00                	mov    (%eax),%al
c002899e:	3c 2b                	cmp    $0x2b,%al
c00289a0:	75 05                	jne    c00289a7 <atoi+0x57>
    s++;
c00289a2:	ff 45 08             	incl   0x8(%ebp)
c00289a5:	eb 10                	jmp    c00289b7 <atoi+0x67>
  else if (*s == '-')
c00289a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00289aa:	8a 00                	mov    (%eax),%al
c00289ac:	3c 2d                	cmp    $0x2d,%al
c00289ae:	75 07                	jne    c00289b7 <atoi+0x67>
    {
      negative = true;
c00289b0:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c00289b4:	ff 45 08             	incl   0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c00289b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00289be:	eb 23                	jmp    c00289e3 <atoi+0x93>
    value = value * 10 - (*s - '0');
c00289c0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00289c3:	89 d0                	mov    %edx,%eax
c00289c5:	c1 e0 02             	shl    $0x2,%eax
c00289c8:	01 d0                	add    %edx,%eax
c00289ca:	01 c0                	add    %eax,%eax
c00289cc:	89 c2                	mov    %eax,%edx
c00289ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00289d1:	8a 00                	mov    (%eax),%al
c00289d3:	0f be c0             	movsbl %al,%eax
c00289d6:	83 e8 30             	sub    $0x30,%eax
c00289d9:	29 c2                	sub    %eax,%edx
c00289db:	89 d0                	mov    %edx,%eax
c00289dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (value = 0; isdigit (*s); s++)
c00289e0:	ff 45 08             	incl   0x8(%ebp)
c00289e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00289e6:	8a 00                	mov    (%eax),%al
c00289e8:	0f be c0             	movsbl %al,%eax
c00289eb:	83 ec 0c             	sub    $0xc,%esp
c00289ee:	50                   	push   %eax
c00289ef:	e8 0a ff ff ff       	call   c00288fe <isdigit>
c00289f4:	83 c4 10             	add    $0x10,%esp
c00289f7:	85 c0                	test   %eax,%eax
c00289f9:	75 c5                	jne    c00289c0 <atoi+0x70>
  if (!negative)
c00289fb:	8a 45 f7             	mov    -0x9(%ebp),%al
c00289fe:	83 f0 01             	xor    $0x1,%eax
c0028a01:	84 c0                	test   %al,%al
c0028a03:	74 03                	je     c0028a08 <atoi+0xb8>
    value = -value;
c0028a05:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c0028a08:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028a0b:	c9                   	leave  
c0028a0c:	c3                   	ret    

c0028a0d <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0028a0d:	55                   	push   %ebp
c0028a0e:	89 e5                	mov    %esp,%ebp
c0028a10:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c0028a13:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a16:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c0028a19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a1c:	8b 00                	mov    (%eax),%eax
c0028a1e:	83 ec 08             	sub    $0x8,%esp
c0028a21:	ff 75 0c             	pushl  0xc(%ebp)
c0028a24:	ff 75 08             	pushl  0x8(%ebp)
c0028a27:	ff d0                	call   *%eax
c0028a29:	83 c4 10             	add    $0x10,%esp
}
c0028a2c:	c9                   	leave  
c0028a2d:	c3                   	ret    

c0028a2e <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c0028a2e:	55                   	push   %ebp
c0028a2f:	89 e5                	mov    %esp,%ebp
c0028a31:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c0028a34:	83 ec 0c             	sub    $0xc,%esp
c0028a37:	8d 45 14             	lea    0x14(%ebp),%eax
c0028a3a:	50                   	push   %eax
c0028a3b:	68 0d 8a 02 c0       	push   $0xc0028a0d
c0028a40:	ff 75 10             	pushl  0x10(%ebp)
c0028a43:	ff 75 0c             	pushl  0xc(%ebp)
c0028a46:	ff 75 08             	pushl  0x8(%ebp)
c0028a49:	e8 51 01 00 00       	call   c0028b9f <sort>
c0028a4e:	83 c4 20             	add    $0x20,%esp
}
c0028a51:	90                   	nop
c0028a52:	c9                   	leave  
c0028a53:	c3                   	ret    

c0028a54 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0028a54:	55                   	push   %ebp
c0028a55:	89 e5                	mov    %esp,%ebp
c0028a57:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c0028a5a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028a5d:	48                   	dec    %eax
c0028a5e:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028a62:	89 c2                	mov    %eax,%edx
c0028a64:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a67:	01 d0                	add    %edx,%eax
c0028a69:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c0028a6c:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a6f:	48                   	dec    %eax
c0028a70:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028a74:	89 c2                	mov    %eax,%edx
c0028a76:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a79:	01 d0                	add    %edx,%eax
c0028a7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c0028a7e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028a85:	eb 31                	jmp    c0028ab8 <do_swap+0x64>
    {
      unsigned char t = a[i];
c0028a87:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028a8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028a8d:	01 d0                	add    %edx,%eax
c0028a8f:	8a 00                	mov    (%eax),%al
c0028a91:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c0028a94:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028a97:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028a9a:	01 c2                	add    %eax,%edx
c0028a9c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0028a9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028aa2:	01 c8                	add    %ecx,%eax
c0028aa4:	8a 00                	mov    (%eax),%al
c0028aa6:	88 02                	mov    %al,(%edx)
      b[i] = t;
c0028aa8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028aab:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028aae:	01 c2                	add    %eax,%edx
c0028ab0:	8a 45 f3             	mov    -0xd(%ebp),%al
c0028ab3:	88 02                	mov    %al,(%edx)
  for (i = 0; i < size; i++)
c0028ab5:	ff 45 fc             	incl   -0x4(%ebp)
c0028ab8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028abb:	3b 45 14             	cmp    0x14(%ebp),%eax
c0028abe:	72 c7                	jb     c0028a87 <do_swap+0x33>
    }
}
c0028ac0:	90                   	nop
c0028ac1:	c9                   	leave  
c0028ac2:	c3                   	ret    

c0028ac3 <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c0028ac3:	55                   	push   %ebp
c0028ac4:	89 e5                	mov    %esp,%ebp
c0028ac6:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028ac9:	8b 45 10             	mov    0x10(%ebp),%eax
c0028acc:	48                   	dec    %eax
c0028acd:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028ad1:	89 c2                	mov    %eax,%edx
c0028ad3:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ad6:	01 c2                	add    %eax,%edx
c0028ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028adb:	48                   	dec    %eax
c0028adc:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028ae0:	89 c1                	mov    %eax,%ecx
c0028ae2:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ae5:	01 c8                	add    %ecx,%eax
c0028ae7:	83 ec 04             	sub    $0x4,%esp
c0028aea:	ff 75 1c             	pushl  0x1c(%ebp)
c0028aed:	52                   	push   %edx
c0028aee:	50                   	push   %eax
c0028aef:	8b 45 18             	mov    0x18(%ebp),%eax
c0028af2:	ff d0                	call   *%eax
c0028af4:	83 c4 10             	add    $0x10,%esp
}
c0028af7:	c9                   	leave  
c0028af8:	c3                   	ret    

c0028af9 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0028af9:	55                   	push   %ebp
c0028afa:	89 e5                	mov    %esp,%ebp
c0028afc:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c0028aff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b02:	01 c0                	add    %eax,%eax
c0028b04:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c0028b07:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b0a:	01 c0                	add    %eax,%eax
c0028b0c:	40                   	inc    %eax
c0028b0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c0028b10:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b13:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0028b16:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b19:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028b1c:	77 27                	ja     c0028b45 <heapify+0x4c>
c0028b1e:	83 ec 08             	sub    $0x8,%esp
c0028b21:	ff 75 1c             	pushl  0x1c(%ebp)
c0028b24:	ff 75 18             	pushl  0x18(%ebp)
c0028b27:	ff 75 14             	pushl  0x14(%ebp)
c0028b2a:	ff 75 f4             	pushl  -0xc(%ebp)
c0028b2d:	ff 75 f0             	pushl  -0x10(%ebp)
c0028b30:	ff 75 08             	pushl  0x8(%ebp)
c0028b33:	e8 8b ff ff ff       	call   c0028ac3 <do_compare>
c0028b38:	83 c4 20             	add    $0x20,%esp
c0028b3b:	85 c0                	test   %eax,%eax
c0028b3d:	7e 06                	jle    c0028b45 <heapify+0x4c>
        max = left;
c0028b3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b42:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c0028b45:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b48:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028b4b:	77 27                	ja     c0028b74 <heapify+0x7b>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028b4d:	83 ec 08             	sub    $0x8,%esp
c0028b50:	ff 75 1c             	pushl  0x1c(%ebp)
c0028b53:	ff 75 18             	pushl  0x18(%ebp)
c0028b56:	ff 75 14             	pushl  0x14(%ebp)
c0028b59:	ff 75 f4             	pushl  -0xc(%ebp)
c0028b5c:	ff 75 ec             	pushl  -0x14(%ebp)
c0028b5f:	ff 75 08             	pushl  0x8(%ebp)
c0028b62:	e8 5c ff ff ff       	call   c0028ac3 <do_compare>
c0028b67:	83 c4 20             	add    $0x20,%esp
c0028b6a:	85 c0                	test   %eax,%eax
c0028b6c:	7e 06                	jle    c0028b74 <heapify+0x7b>
        max = right;
c0028b6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b71:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0028b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b77:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028b7a:	74 1f                	je     c0028b9b <heapify+0xa2>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0028b7c:	ff 75 14             	pushl  0x14(%ebp)
c0028b7f:	ff 75 f4             	pushl  -0xc(%ebp)
c0028b82:	ff 75 0c             	pushl  0xc(%ebp)
c0028b85:	ff 75 08             	pushl  0x8(%ebp)
c0028b88:	e8 c7 fe ff ff       	call   c0028a54 <do_swap>
c0028b8d:	83 c4 10             	add    $0x10,%esp
      i = max;
c0028b90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b93:	89 45 0c             	mov    %eax,0xc(%ebp)
    {
c0028b96:	e9 64 ff ff ff       	jmp    c0028aff <heapify+0x6>
        break;
c0028b9b:	90                   	nop
    }
}
c0028b9c:	90                   	nop
c0028b9d:	c9                   	leave  
c0028b9e:	c3                   	ret    

c0028b9f <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0028b9f:	55                   	push   %ebp
c0028ba0:	89 e5                	mov    %esp,%ebp
c0028ba2:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0028ba5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028ba9:	75 27                	jne    c0028bd2 <sort+0x33>
c0028bab:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028baf:	74 21                	je     c0028bd2 <sort+0x33>
c0028bb1:	83 ec 0c             	sub    $0xc,%esp
c0028bb4:	68 a0 13 03 c0       	push   $0xc00313a0
c0028bb9:	68 76 13 03 c0       	push   $0xc0031376
c0028bbe:	68 dc 13 03 c0       	push   $0xc00313dc
c0028bc3:	68 8a 00 00 00       	push   $0x8a
c0028bc8:	68 8d 13 03 c0       	push   $0xc003138d
c0028bcd:	e8 50 14 00 00       	call   c002a022 <debug_panic>
  ASSERT (compare != NULL);
c0028bd2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0028bd6:	75 21                	jne    c0028bf9 <sort+0x5a>
c0028bd8:	83 ec 0c             	sub    $0xc,%esp
c0028bdb:	68 ba 13 03 c0       	push   $0xc00313ba
c0028be0:	68 76 13 03 c0       	push   $0xc0031376
c0028be5:	68 dc 13 03 c0       	push   $0xc00313dc
c0028bea:	68 8b 00 00 00       	push   $0x8b
c0028bef:	68 8d 13 03 c0       	push   $0xc003138d
c0028bf4:	e8 29 14 00 00       	call   c002a022 <debug_panic>
  ASSERT (size > 0);
c0028bf9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028bfd:	75 21                	jne    c0028c20 <sort+0x81>
c0028bff:	83 ec 0c             	sub    $0xc,%esp
c0028c02:	68 ca 13 03 c0       	push   $0xc00313ca
c0028c07:	68 76 13 03 c0       	push   $0xc0031376
c0028c0c:	68 dc 13 03 c0       	push   $0xc00313dc
c0028c11:	68 8c 00 00 00       	push   $0x8c
c0028c16:	68 8d 13 03 c0       	push   $0xc003138d
c0028c1b:	e8 02 14 00 00       	call   c002a022 <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028c20:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c23:	d1 e8                	shr    %eax
c0028c25:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028c28:	eb 20                	jmp    c0028c4a <sort+0xab>
    heapify (array, i, cnt, size, compare, aux);
c0028c2a:	83 ec 08             	sub    $0x8,%esp
c0028c2d:	ff 75 18             	pushl  0x18(%ebp)
c0028c30:	ff 75 14             	pushl  0x14(%ebp)
c0028c33:	ff 75 10             	pushl  0x10(%ebp)
c0028c36:	ff 75 0c             	pushl  0xc(%ebp)
c0028c39:	ff 75 f4             	pushl  -0xc(%ebp)
c0028c3c:	ff 75 08             	pushl  0x8(%ebp)
c0028c3f:	e8 b5 fe ff ff       	call   c0028af9 <heapify>
c0028c44:	83 c4 20             	add    $0x20,%esp
  for (i = cnt / 2; i > 0; i--)
c0028c47:	ff 4d f4             	decl   -0xc(%ebp)
c0028c4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028c4e:	75 da                	jne    c0028c2a <sort+0x8b>

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028c50:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c53:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028c56:	eb 34                	jmp    c0028c8c <sort+0xed>
    {
      do_swap (array, 1, i, size);
c0028c58:	ff 75 10             	pushl  0x10(%ebp)
c0028c5b:	ff 75 f4             	pushl  -0xc(%ebp)
c0028c5e:	6a 01                	push   $0x1
c0028c60:	ff 75 08             	pushl  0x8(%ebp)
c0028c63:	e8 ec fd ff ff       	call   c0028a54 <do_swap>
c0028c68:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c0028c6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c6e:	48                   	dec    %eax
c0028c6f:	83 ec 08             	sub    $0x8,%esp
c0028c72:	ff 75 18             	pushl  0x18(%ebp)
c0028c75:	ff 75 14             	pushl  0x14(%ebp)
c0028c78:	ff 75 10             	pushl  0x10(%ebp)
c0028c7b:	50                   	push   %eax
c0028c7c:	6a 01                	push   $0x1
c0028c7e:	ff 75 08             	pushl  0x8(%ebp)
c0028c81:	e8 73 fe ff ff       	call   c0028af9 <heapify>
c0028c86:	83 c4 20             	add    $0x20,%esp
  for (i = cnt; i > 1; i--) 
c0028c89:	ff 4d f4             	decl   -0xc(%ebp)
c0028c8c:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0028c90:	77 c6                	ja     c0028c58 <sort+0xb9>
    }
}
c0028c92:	90                   	nop
c0028c93:	c9                   	leave  
c0028c94:	c3                   	ret    

c0028c95 <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c0028c95:	55                   	push   %ebp
c0028c96:	89 e5                	mov    %esp,%ebp
c0028c98:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c0028c9b:	83 ec 08             	sub    $0x8,%esp
c0028c9e:	8d 45 18             	lea    0x18(%ebp),%eax
c0028ca1:	50                   	push   %eax
c0028ca2:	68 0d 8a 02 c0       	push   $0xc0028a0d
c0028ca7:	ff 75 14             	pushl  0x14(%ebp)
c0028caa:	ff 75 10             	pushl  0x10(%ebp)
c0028cad:	ff 75 0c             	pushl  0xc(%ebp)
c0028cb0:	ff 75 08             	pushl  0x8(%ebp)
c0028cb3:	e8 05 00 00 00       	call   c0028cbd <binary_search>
c0028cb8:	83 c4 20             	add    $0x20,%esp
}
c0028cbb:	c9                   	leave  
c0028cbc:	c3                   	ret    

c0028cbd <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c0028cbd:	55                   	push   %ebp
c0028cbe:	89 e5                	mov    %esp,%ebp
c0028cc0:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c0028cc3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028cc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c0028cc9:	8b 45 14             	mov    0x14(%ebp),%eax
c0028ccc:	0f af 45 10          	imul   0x10(%ebp),%eax
c0028cd0:	89 c2                	mov    %eax,%edx
c0028cd2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028cd5:	01 d0                	add    %edx,%eax
c0028cd7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c0028cda:	eb 65                	jmp    c0028d41 <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c0028cdc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028cdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ce2:	29 c2                	sub    %eax,%edx
c0028ce4:	89 d0                	mov    %edx,%eax
c0028ce6:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ceb:	f7 75 14             	divl   0x14(%ebp)
c0028cee:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c0028cf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028cf4:	d1 e8                	shr    %eax
c0028cf6:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028cfa:	89 c2                	mov    %eax,%edx
c0028cfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028cff:	01 d0                	add    %edx,%eax
c0028d01:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c0028d04:	83 ec 04             	sub    $0x4,%esp
c0028d07:	ff 75 1c             	pushl  0x1c(%ebp)
c0028d0a:	ff 75 e8             	pushl  -0x18(%ebp)
c0028d0d:	ff 75 08             	pushl  0x8(%ebp)
c0028d10:	8b 45 18             	mov    0x18(%ebp),%eax
c0028d13:	ff d0                	call   *%eax
c0028d15:	83 c4 10             	add    $0x10,%esp
c0028d18:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c0028d1b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028d1f:	79 08                	jns    c0028d29 <binary_search+0x6c>
        last = middle;
c0028d21:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028d24:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028d27:	eb 18                	jmp    c0028d41 <binary_search+0x84>
      else if (cmp > 0) 
c0028d29:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028d2d:	7e 0d                	jle    c0028d3c <binary_search+0x7f>
        first = middle + size;
c0028d2f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0028d32:	8b 45 14             	mov    0x14(%ebp),%eax
c0028d35:	01 d0                	add    %edx,%eax
c0028d37:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028d3a:	eb 05                	jmp    c0028d41 <binary_search+0x84>
      else
        return (void *) middle;
c0028d3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028d3f:	eb 0d                	jmp    c0028d4e <binary_search+0x91>
  while (first < last) 
c0028d41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028d44:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028d47:	72 93                	jb     c0028cdc <binary_search+0x1f>
    }
  
  return NULL;
c0028d49:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028d4e:	c9                   	leave  
c0028d4f:	c3                   	ret    

c0028d50 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0028d50:	55                   	push   %ebp
c0028d51:	89 e5                	mov    %esp,%ebp
c0028d53:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028d56:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d59:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028d5f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028d62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028d66:	75 24                	jne    c0028d8c <memcpy+0x3c>
c0028d68:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028d6c:	74 1e                	je     c0028d8c <memcpy+0x3c>
c0028d6e:	83 ec 0c             	sub    $0xc,%esp
c0028d71:	68 e4 13 03 c0       	push   $0xc00313e4
c0028d76:	68 fd 13 03 c0       	push   $0xc00313fd
c0028d7b:	68 f4 14 03 c0       	push   $0xc00314f4
c0028d80:	6a 0c                	push   $0xc
c0028d82:	68 14 14 03 c0       	push   $0xc0031414
c0028d87:	e8 96 12 00 00       	call   c002a022 <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028d8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028d90:	75 3a                	jne    c0028dcc <memcpy+0x7c>
c0028d92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028d96:	74 34                	je     c0028dcc <memcpy+0x7c>
c0028d98:	83 ec 0c             	sub    $0xc,%esp
c0028d9b:	68 27 14 03 c0       	push   $0xc0031427
c0028da0:	68 fd 13 03 c0       	push   $0xc00313fd
c0028da5:	68 f4 14 03 c0       	push   $0xc00314f4
c0028daa:	6a 0d                	push   $0xd
c0028dac:	68 14 14 03 c0       	push   $0xc0031414
c0028db1:	e8 6c 12 00 00       	call   c002a022 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c0028db6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028db9:	8d 50 01             	lea    0x1(%eax),%edx
c0028dbc:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028dbf:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028dc2:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028dc5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028dc8:	8a 12                	mov    (%edx),%dl
c0028dca:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0028dcc:	8b 45 10             	mov    0x10(%ebp),%eax
c0028dcf:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028dd2:	89 55 10             	mov    %edx,0x10(%ebp)
c0028dd5:	85 c0                	test   %eax,%eax
c0028dd7:	75 dd                	jne    c0028db6 <memcpy+0x66>

  return dst_;
c0028dd9:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028ddc:	c9                   	leave  
c0028ddd:	c3                   	ret    

c0028dde <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0028dde:	55                   	push   %ebp
c0028ddf:	89 e5                	mov    %esp,%ebp
c0028de1:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028de4:	8b 45 08             	mov    0x8(%ebp),%eax
c0028de7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028dea:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028ded:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028df0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028df4:	75 24                	jne    c0028e1a <memmove+0x3c>
c0028df6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028dfa:	74 1e                	je     c0028e1a <memmove+0x3c>
c0028dfc:	83 ec 0c             	sub    $0xc,%esp
c0028dff:	68 e4 13 03 c0       	push   $0xc00313e4
c0028e04:	68 fd 13 03 c0       	push   $0xc00313fd
c0028e09:	68 fc 14 03 c0       	push   $0xc00314fc
c0028e0e:	6a 1d                	push   $0x1d
c0028e10:	68 14 14 03 c0       	push   $0xc0031414
c0028e15:	e8 08 12 00 00       	call   c002a022 <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028e1e:	75 24                	jne    c0028e44 <memmove+0x66>
c0028e20:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028e24:	74 1e                	je     c0028e44 <memmove+0x66>
c0028e26:	83 ec 0c             	sub    $0xc,%esp
c0028e29:	68 27 14 03 c0       	push   $0xc0031427
c0028e2e:	68 fd 13 03 c0       	push   $0xc00313fd
c0028e33:	68 fc 14 03 c0       	push   $0xc00314fc
c0028e38:	6a 1e                	push   $0x1e
c0028e3a:	68 14 14 03 c0       	push   $0xc0031414
c0028e3f:	e8 de 11 00 00       	call   c002a022 <debug_panic>

  if (dst < src) 
c0028e44:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e47:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028e4a:	73 27                	jae    c0028e73 <memmove+0x95>
    {
      while (size-- > 0)
c0028e4c:	eb 16                	jmp    c0028e64 <memmove+0x86>
        *dst++ = *src++;
c0028e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e51:	8d 50 01             	lea    0x1(%eax),%edx
c0028e54:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028e57:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028e5a:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028e5d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028e60:	8a 12                	mov    (%edx),%dl
c0028e62:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c0028e64:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e67:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028e6a:	89 55 10             	mov    %edx,0x10(%ebp)
c0028e6d:	85 c0                	test   %eax,%eax
c0028e6f:	75 dd                	jne    c0028e4e <memmove+0x70>
c0028e71:	eb 2b                	jmp    c0028e9e <memmove+0xc0>
    }
  else 
    {
      dst += size;
c0028e73:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e76:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c0028e79:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e7c:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c0028e7f:	eb 10                	jmp    c0028e91 <memmove+0xb3>
        *--dst = *--src;
c0028e81:	ff 4d f4             	decl   -0xc(%ebp)
c0028e84:	ff 4d f0             	decl   -0x10(%ebp)
c0028e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028e8a:	8a 10                	mov    (%eax),%dl
c0028e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e8f:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c0028e91:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e94:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028e97:	89 55 10             	mov    %edx,0x10(%ebp)
c0028e9a:	85 c0                	test   %eax,%eax
c0028e9c:	75 e3                	jne    c0028e81 <memmove+0xa3>
    }

  return dst;
c0028e9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028ea1:	c9                   	leave  
c0028ea2:	c3                   	ret    

c0028ea3 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028ea3:	55                   	push   %ebp
c0028ea4:	89 e5                	mov    %esp,%ebp
c0028ea6:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c0028ea9:	8b 45 08             	mov    0x8(%ebp),%eax
c0028eac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c0028eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028eb2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c0028eb5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028eb9:	75 24                	jne    c0028edf <memcmp+0x3c>
c0028ebb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028ebf:	74 1e                	je     c0028edf <memcmp+0x3c>
c0028ec1:	83 ec 0c             	sub    $0xc,%esp
c0028ec4:	68 40 14 03 c0       	push   $0xc0031440
c0028ec9:	68 fd 13 03 c0       	push   $0xc00313fd
c0028ece:	68 04 15 03 c0       	push   $0xc0031504
c0028ed3:	6a 3a                	push   $0x3a
c0028ed5:	68 14 14 03 c0       	push   $0xc0031414
c0028eda:	e8 43 11 00 00       	call   c002a022 <debug_panic>
  ASSERT (b != NULL || size == 0);
c0028edf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028ee3:	75 54                	jne    c0028f39 <memcmp+0x96>
c0028ee5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028ee9:	74 4e                	je     c0028f39 <memcmp+0x96>
c0028eeb:	83 ec 0c             	sub    $0xc,%esp
c0028eee:	68 57 14 03 c0       	push   $0xc0031457
c0028ef3:	68 fd 13 03 c0       	push   $0xc00313fd
c0028ef8:	68 04 15 03 c0       	push   $0xc0031504
c0028efd:	6a 3b                	push   $0x3b
c0028eff:	68 14 14 03 c0       	push   $0xc0031414
c0028f04:	e8 19 11 00 00       	call   c002a022 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028f0c:	8a 10                	mov    (%eax),%dl
c0028f0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028f11:	8a 00                	mov    (%eax),%al
c0028f13:	38 c2                	cmp    %al,%dl
c0028f15:	74 1c                	je     c0028f33 <memcmp+0x90>
      return *a > *b ? +1 : -1;
c0028f17:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028f1a:	8a 10                	mov    (%eax),%dl
c0028f1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028f1f:	8a 00                	mov    (%eax),%al
c0028f21:	38 c2                	cmp    %al,%dl
c0028f23:	76 07                	jbe    c0028f2c <memcmp+0x89>
c0028f25:	b8 01 00 00 00       	mov    $0x1,%eax
c0028f2a:	eb 1f                	jmp    c0028f4b <memcmp+0xa8>
c0028f2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028f31:	eb 18                	jmp    c0028f4b <memcmp+0xa8>
  for (; size-- > 0; a++, b++)
c0028f33:	ff 45 f4             	incl   -0xc(%ebp)
c0028f36:	ff 45 f0             	incl   -0x10(%ebp)
c0028f39:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f3c:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028f3f:	89 55 10             	mov    %edx,0x10(%ebp)
c0028f42:	85 c0                	test   %eax,%eax
c0028f44:	75 c3                	jne    c0028f09 <memcmp+0x66>
  return 0;
c0028f46:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028f4b:	c9                   	leave  
c0028f4c:	c3                   	ret    

c0028f4d <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028f4d:	55                   	push   %ebp
c0028f4e:	89 e5                	mov    %esp,%ebp
c0028f50:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c0028f53:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f56:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c0028f59:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028f5c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c0028f5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028f63:	75 1e                	jne    c0028f83 <strcmp+0x36>
c0028f65:	83 ec 0c             	sub    $0xc,%esp
c0028f68:	68 6e 14 03 c0       	push   $0xc003146e
c0028f6d:	68 fd 13 03 c0       	push   $0xc00313fd
c0028f72:	68 0c 15 03 c0       	push   $0xc003150c
c0028f77:	6a 4e                	push   $0x4e
c0028f79:	68 14 14 03 c0       	push   $0xc0031414
c0028f7e:	e8 9f 10 00 00       	call   c002a022 <debug_panic>
  ASSERT (b != NULL);
c0028f83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028f87:	75 24                	jne    c0028fad <strcmp+0x60>
c0028f89:	83 ec 0c             	sub    $0xc,%esp
c0028f8c:	68 78 14 03 c0       	push   $0xc0031478
c0028f91:	68 fd 13 03 c0       	push   $0xc00313fd
c0028f96:	68 0c 15 03 c0       	push   $0xc003150c
c0028f9b:	6a 4f                	push   $0x4f
c0028f9d:	68 14 14 03 c0       	push   $0xc0031414
c0028fa2:	e8 7b 10 00 00       	call   c002a022 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c0028fa7:	ff 45 f4             	incl   -0xc(%ebp)
      b++;
c0028faa:	ff 45 f0             	incl   -0x10(%ebp)
  while (*a != '\0' && *a == *b) 
c0028fad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028fb0:	8a 00                	mov    (%eax),%al
c0028fb2:	84 c0                	test   %al,%al
c0028fb4:	74 0e                	je     c0028fc4 <strcmp+0x77>
c0028fb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028fb9:	8a 10                	mov    (%eax),%dl
c0028fbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028fbe:	8a 00                	mov    (%eax),%al
c0028fc0:	38 c2                	cmp    %al,%dl
c0028fc2:	74 e3                	je     c0028fa7 <strcmp+0x5a>
    }

  return *a < *b ? -1 : *a > *b;
c0028fc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028fc7:	8a 10                	mov    (%eax),%dl
c0028fc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028fcc:	8a 00                	mov    (%eax),%al
c0028fce:	38 c2                	cmp    %al,%dl
c0028fd0:	72 14                	jb     c0028fe6 <strcmp+0x99>
c0028fd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028fd5:	8a 10                	mov    (%eax),%dl
c0028fd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028fda:	8a 00                	mov    (%eax),%al
c0028fdc:	38 c2                	cmp    %al,%dl
c0028fde:	0f 97 c0             	seta   %al
c0028fe1:	0f b6 c0             	movzbl %al,%eax
c0028fe4:	eb 05                	jmp    c0028feb <strcmp+0x9e>
c0028fe6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028feb:	c9                   	leave  
c0028fec:	c3                   	ret    

c0028fed <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0028fed:	55                   	push   %ebp
c0028fee:	89 e5                	mov    %esp,%ebp
c0028ff0:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c0028ff3:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ff6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028ffc:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c0028fff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0029003:	75 36                	jne    c002903b <memchr+0x4e>
c0029005:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029009:	74 30                	je     c002903b <memchr+0x4e>
c002900b:	83 ec 0c             	sub    $0xc,%esp
c002900e:	68 82 14 03 c0       	push   $0xc0031482
c0029013:	68 fd 13 03 c0       	push   $0xc00313fd
c0029018:	68 14 15 03 c0       	push   $0xc0031514
c002901d:	6a 63                	push   $0x63
c002901f:	68 14 14 03 c0       	push   $0xc0031414
c0029024:	e8 f9 0f 00 00       	call   c002a022 <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0029029:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002902c:	8a 00                	mov    (%eax),%al
c002902e:	3a 45 f3             	cmp    -0xd(%ebp),%al
c0029031:	75 05                	jne    c0029038 <memchr+0x4b>
      return (void *) block;
c0029033:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029036:	eb 15                	jmp    c002904d <memchr+0x60>
  for (; size-- > 0; block++)
c0029038:	ff 45 f4             	incl   -0xc(%ebp)
c002903b:	8b 45 10             	mov    0x10(%ebp),%eax
c002903e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029041:	89 55 10             	mov    %edx,0x10(%ebp)
c0029044:	85 c0                	test   %eax,%eax
c0029046:	75 e1                	jne    c0029029 <memchr+0x3c>

  return NULL;
c0029048:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002904d:	c9                   	leave  
c002904e:	c3                   	ret    

c002904f <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c002904f:	55                   	push   %ebp
c0029050:	89 e5                	mov    %esp,%ebp
c0029052:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c0029055:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029058:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c002905b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002905f:	75 1e                	jne    c002907f <strchr+0x30>
c0029061:	83 ec 0c             	sub    $0xc,%esp
c0029064:	68 9d 14 03 c0       	push   $0xc003149d
c0029069:	68 fd 13 03 c0       	push   $0xc00313fd
c002906e:	68 1c 15 03 c0       	push   $0xc003151c
c0029073:	6a 75                	push   $0x75
c0029075:	68 14 14 03 c0       	push   $0xc0031414
c002907a:	e8 a3 0f 00 00       	call   c002a022 <debug_panic>

  for (;;) 
    if (*string == c)
c002907f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029082:	8a 00                	mov    (%eax),%al
c0029084:	3a 45 f7             	cmp    -0x9(%ebp),%al
c0029087:	75 05                	jne    c002908e <strchr+0x3f>
      return (char *) string;
c0029089:	8b 45 08             	mov    0x8(%ebp),%eax
c002908c:	eb 15                	jmp    c00290a3 <strchr+0x54>
    else if (*string == '\0')
c002908e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029091:	8a 00                	mov    (%eax),%al
c0029093:	84 c0                	test   %al,%al
c0029095:	75 07                	jne    c002909e <strchr+0x4f>
      return NULL;
c0029097:	b8 00 00 00 00       	mov    $0x0,%eax
c002909c:	eb 05                	jmp    c00290a3 <strchr+0x54>
    else
      string++;
c002909e:	ff 45 08             	incl   0x8(%ebp)
    if (*string == c)
c00290a1:	eb dc                	jmp    c002907f <strchr+0x30>
}
c00290a3:	c9                   	leave  
c00290a4:	c3                   	ret    

c00290a5 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00290a5:	55                   	push   %ebp
c00290a6:	89 e5                	mov    %esp,%ebp
c00290a8:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00290ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00290b2:	eb 23                	jmp    c00290d7 <strcspn+0x32>
    if (strchr (stop, string[length]) != NULL)
c00290b4:	8b 55 08             	mov    0x8(%ebp),%edx
c00290b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00290ba:	01 d0                	add    %edx,%eax
c00290bc:	8a 00                	mov    (%eax),%al
c00290be:	0f be c0             	movsbl %al,%eax
c00290c1:	83 ec 08             	sub    $0x8,%esp
c00290c4:	50                   	push   %eax
c00290c5:	ff 75 0c             	pushl  0xc(%ebp)
c00290c8:	e8 82 ff ff ff       	call   c002904f <strchr>
c00290cd:	83 c4 10             	add    $0x10,%esp
c00290d0:	85 c0                	test   %eax,%eax
c00290d2:	75 13                	jne    c00290e7 <strcspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c00290d4:	ff 45 f4             	incl   -0xc(%ebp)
c00290d7:	8b 55 08             	mov    0x8(%ebp),%edx
c00290da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00290dd:	01 d0                	add    %edx,%eax
c00290df:	8a 00                	mov    (%eax),%al
c00290e1:	84 c0                	test   %al,%al
c00290e3:	75 cf                	jne    c00290b4 <strcspn+0xf>
c00290e5:	eb 01                	jmp    c00290e8 <strcspn+0x43>
      break;
c00290e7:	90                   	nop
  return length;
c00290e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00290eb:	c9                   	leave  
c00290ec:	c3                   	ret    

c00290ed <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c00290ed:	55                   	push   %ebp
c00290ee:	89 e5                	mov    %esp,%ebp
c00290f0:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c00290f3:	eb 23                	jmp    c0029118 <strpbrk+0x2b>
    if (strchr (stop, *string) != NULL)
c00290f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00290f8:	8a 00                	mov    (%eax),%al
c00290fa:	0f be c0             	movsbl %al,%eax
c00290fd:	83 ec 08             	sub    $0x8,%esp
c0029100:	50                   	push   %eax
c0029101:	ff 75 0c             	pushl  0xc(%ebp)
c0029104:	e8 46 ff ff ff       	call   c002904f <strchr>
c0029109:	83 c4 10             	add    $0x10,%esp
c002910c:	85 c0                	test   %eax,%eax
c002910e:	74 05                	je     c0029115 <strpbrk+0x28>
      return (char *) string;
c0029110:	8b 45 08             	mov    0x8(%ebp),%eax
c0029113:	eb 11                	jmp    c0029126 <strpbrk+0x39>
  for (; *string != '\0'; string++)
c0029115:	ff 45 08             	incl   0x8(%ebp)
c0029118:	8b 45 08             	mov    0x8(%ebp),%eax
c002911b:	8a 00                	mov    (%eax),%al
c002911d:	84 c0                	test   %al,%al
c002911f:	75 d4                	jne    c00290f5 <strpbrk+0x8>
  return NULL;
c0029121:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029126:	c9                   	leave  
c0029127:	c3                   	ret    

c0029128 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0029128:	55                   	push   %ebp
c0029129:	89 e5                	mov    %esp,%ebp
c002912b:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c002912e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029131:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0029134:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c002913b:	eb 13                	jmp    c0029150 <strrchr+0x28>
    if (*string == c)
c002913d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029140:	8a 00                	mov    (%eax),%al
c0029142:	3a 45 fb             	cmp    -0x5(%ebp),%al
c0029145:	75 06                	jne    c002914d <strrchr+0x25>
      p = string;
c0029147:	8b 45 08             	mov    0x8(%ebp),%eax
c002914a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (; *string != '\0'; string++)
c002914d:	ff 45 08             	incl   0x8(%ebp)
c0029150:	8b 45 08             	mov    0x8(%ebp),%eax
c0029153:	8a 00                	mov    (%eax),%al
c0029155:	84 c0                	test   %al,%al
c0029157:	75 e4                	jne    c002913d <strrchr+0x15>
  return (char *) p;
c0029159:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002915c:	c9                   	leave  
c002915d:	c3                   	ret    

c002915e <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c002915e:	55                   	push   %ebp
c002915f:	89 e5                	mov    %esp,%ebp
c0029161:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0029164:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002916b:	eb 23                	jmp    c0029190 <strspn+0x32>
    if (strchr (skip, string[length]) == NULL)
c002916d:	8b 55 08             	mov    0x8(%ebp),%edx
c0029170:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029173:	01 d0                	add    %edx,%eax
c0029175:	8a 00                	mov    (%eax),%al
c0029177:	0f be c0             	movsbl %al,%eax
c002917a:	83 ec 08             	sub    $0x8,%esp
c002917d:	50                   	push   %eax
c002917e:	ff 75 0c             	pushl  0xc(%ebp)
c0029181:	e8 c9 fe ff ff       	call   c002904f <strchr>
c0029186:	83 c4 10             	add    $0x10,%esp
c0029189:	85 c0                	test   %eax,%eax
c002918b:	74 13                	je     c00291a0 <strspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c002918d:	ff 45 f4             	incl   -0xc(%ebp)
c0029190:	8b 55 08             	mov    0x8(%ebp),%edx
c0029193:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029196:	01 d0                	add    %edx,%eax
c0029198:	8a 00                	mov    (%eax),%al
c002919a:	84 c0                	test   %al,%al
c002919c:	75 cf                	jne    c002916d <strspn+0xf>
c002919e:	eb 01                	jmp    c00291a1 <strspn+0x43>
      break;
c00291a0:	90                   	nop
  return length;
c00291a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00291a4:	c9                   	leave  
c00291a5:	c3                   	ret    

c00291a6 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c00291a6:	55                   	push   %ebp
c00291a7:	89 e5                	mov    %esp,%ebp
c00291a9:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c00291ac:	83 ec 0c             	sub    $0xc,%esp
c00291af:	ff 75 08             	pushl  0x8(%ebp)
c00291b2:	e8 cc 01 00 00       	call   c0029383 <strlen>
c00291b7:	83 c4 10             	add    $0x10,%esp
c00291ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c00291bd:	83 ec 0c             	sub    $0xc,%esp
c00291c0:	ff 75 0c             	pushl  0xc(%ebp)
c00291c3:	e8 bb 01 00 00       	call   c0029383 <strlen>
c00291c8:	83 c4 10             	add    $0x10,%esp
c00291cb:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c00291ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00291d1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00291d4:	72 3f                	jb     c0029215 <strstr+0x6f>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c00291d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00291dd:	eb 2b                	jmp    c002920a <strstr+0x64>
        if (!memcmp (haystack + i, needle, needle_len))
c00291df:	8b 55 08             	mov    0x8(%ebp),%edx
c00291e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291e5:	01 d0                	add    %edx,%eax
c00291e7:	83 ec 04             	sub    $0x4,%esp
c00291ea:	ff 75 ec             	pushl  -0x14(%ebp)
c00291ed:	ff 75 0c             	pushl  0xc(%ebp)
c00291f0:	50                   	push   %eax
c00291f1:	e8 ad fc ff ff       	call   c0028ea3 <memcmp>
c00291f6:	83 c4 10             	add    $0x10,%esp
c00291f9:	85 c0                	test   %eax,%eax
c00291fb:	75 0a                	jne    c0029207 <strstr+0x61>
          return (char *) haystack + i;
c00291fd:	8b 55 08             	mov    0x8(%ebp),%edx
c0029200:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029203:	01 d0                	add    %edx,%eax
c0029205:	eb 13                	jmp    c002921a <strstr+0x74>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0029207:	ff 45 f4             	incl   -0xc(%ebp)
c002920a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002920d:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0029210:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029213:	73 ca                	jae    c00291df <strstr+0x39>
    }

  return NULL;
c0029215:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002921a:	c9                   	leave  
c002921b:	c3                   	ret    

c002921c <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c002921c:	55                   	push   %ebp
c002921d:	89 e5                	mov    %esp,%ebp
c002921f:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0029222:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029226:	75 21                	jne    c0029249 <strtok_r+0x2d>
c0029228:	83 ec 0c             	sub    $0xc,%esp
c002922b:	68 ac 14 03 c0       	push   $0xc00314ac
c0029230:	68 fd 13 03 c0       	push   $0xc00313fd
c0029235:	68 24 15 03 c0       	push   $0xc0031524
c002923a:	68 ef 00 00 00       	push   $0xef
c002923f:	68 14 14 03 c0       	push   $0xc0031414
c0029244:	e8 d9 0d 00 00       	call   c002a022 <debug_panic>
  ASSERT (save_ptr != NULL);
c0029249:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002924d:	75 21                	jne    c0029270 <strtok_r+0x54>
c002924f:	83 ec 0c             	sub    $0xc,%esp
c0029252:	68 bf 14 03 c0       	push   $0xc00314bf
c0029257:	68 fd 13 03 c0       	push   $0xc00313fd
c002925c:	68 24 15 03 c0       	push   $0xc0031524
c0029261:	68 f0 00 00 00       	push   $0xf0
c0029266:	68 14 14 03 c0       	push   $0xc0031414
c002926b:	e8 b2 0d 00 00       	call   c002a022 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0029270:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029274:	75 08                	jne    c002927e <strtok_r+0x62>
    s = *save_ptr;
c0029276:	8b 45 10             	mov    0x10(%ebp),%eax
c0029279:	8b 00                	mov    (%eax),%eax
c002927b:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c002927e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029282:	75 3c                	jne    c00292c0 <strtok_r+0xa4>
c0029284:	83 ec 0c             	sub    $0xc,%esp
c0029287:	68 d0 14 03 c0       	push   $0xc00314d0
c002928c:	68 fd 13 03 c0       	push   $0xc00313fd
c0029291:	68 24 15 03 c0       	push   $0xc0031524
c0029296:	68 f6 00 00 00       	push   $0xf6
c002929b:	68 14 14 03 c0       	push   $0xc0031414
c00292a0:	e8 7d 0d 00 00       	call   c002a022 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c00292a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00292a8:	8a 00                	mov    (%eax),%al
c00292aa:	84 c0                	test   %al,%al
c00292ac:	75 0f                	jne    c00292bd <strtok_r+0xa1>
        {
          *save_ptr = s;
c00292ae:	8b 45 10             	mov    0x10(%ebp),%eax
c00292b1:	8b 55 08             	mov    0x8(%ebp),%edx
c00292b4:	89 10                	mov    %edx,(%eax)
          return NULL;
c00292b6:	b8 00 00 00 00       	mov    $0x0,%eax
c00292bb:	eb 6b                	jmp    c0029328 <strtok_r+0x10c>
        }

      s++;
c00292bd:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) != NULL) 
c00292c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00292c3:	8a 00                	mov    (%eax),%al
c00292c5:	0f be c0             	movsbl %al,%eax
c00292c8:	83 ec 08             	sub    $0x8,%esp
c00292cb:	50                   	push   %eax
c00292cc:	ff 75 0c             	pushl  0xc(%ebp)
c00292cf:	e8 7b fd ff ff       	call   c002904f <strchr>
c00292d4:	83 c4 10             	add    $0x10,%esp
c00292d7:	85 c0                	test   %eax,%eax
c00292d9:	75 ca                	jne    c00292a5 <strtok_r+0x89>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c00292db:	8b 45 08             	mov    0x8(%ebp),%eax
c00292de:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c00292e1:	eb 03                	jmp    c00292e6 <strtok_r+0xca>
    s++;
c00292e3:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) == NULL)
c00292e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00292e9:	8a 00                	mov    (%eax),%al
c00292eb:	0f be c0             	movsbl %al,%eax
c00292ee:	83 ec 08             	sub    $0x8,%esp
c00292f1:	50                   	push   %eax
c00292f2:	ff 75 0c             	pushl  0xc(%ebp)
c00292f5:	e8 55 fd ff ff       	call   c002904f <strchr>
c00292fa:	83 c4 10             	add    $0x10,%esp
c00292fd:	85 c0                	test   %eax,%eax
c00292ff:	74 e2                	je     c00292e3 <strtok_r+0xc7>
  if (*s != '\0') 
c0029301:	8b 45 08             	mov    0x8(%ebp),%eax
c0029304:	8a 00                	mov    (%eax),%al
c0029306:	84 c0                	test   %al,%al
c0029308:	74 13                	je     c002931d <strtok_r+0x101>
    {
      *s = '\0';
c002930a:	8b 45 08             	mov    0x8(%ebp),%eax
c002930d:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0029310:	8b 45 08             	mov    0x8(%ebp),%eax
c0029313:	8d 50 01             	lea    0x1(%eax),%edx
c0029316:	8b 45 10             	mov    0x10(%ebp),%eax
c0029319:	89 10                	mov    %edx,(%eax)
c002931b:	eb 08                	jmp    c0029325 <strtok_r+0x109>
    }
  else 
    *save_ptr = s;
c002931d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029320:	8b 55 08             	mov    0x8(%ebp),%edx
c0029323:	89 10                	mov    %edx,(%eax)
  return token;
c0029325:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029328:	c9                   	leave  
c0029329:	c3                   	ret    

c002932a <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c002932a:	55                   	push   %ebp
c002932b:	89 e5                	mov    %esp,%ebp
c002932d:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0029330:	8b 45 08             	mov    0x8(%ebp),%eax
c0029333:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c0029336:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002933a:	75 35                	jne    c0029371 <memset+0x47>
c002933c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029340:	74 2f                	je     c0029371 <memset+0x47>
c0029342:	83 ec 0c             	sub    $0xc,%esp
c0029345:	68 e4 13 03 c0       	push   $0xc00313e4
c002934a:	68 fd 13 03 c0       	push   $0xc00313fd
c002934f:	68 30 15 03 c0       	push   $0xc0031530
c0029354:	68 1b 01 00 00       	push   $0x11b
c0029359:	68 14 14 03 c0       	push   $0xc0031414
c002935e:	e8 bf 0c 00 00       	call   c002a022 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0029363:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029366:	8d 50 01             	lea    0x1(%eax),%edx
c0029369:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002936c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002936f:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0029371:	8b 45 10             	mov    0x10(%ebp),%eax
c0029374:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029377:	89 55 10             	mov    %edx,0x10(%ebp)
c002937a:	85 c0                	test   %eax,%eax
c002937c:	75 e5                	jne    c0029363 <memset+0x39>

  return dst_;
c002937e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029381:	c9                   	leave  
c0029382:	c3                   	ret    

c0029383 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0029383:	55                   	push   %ebp
c0029384:	89 e5                	mov    %esp,%ebp
c0029386:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c0029389:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002938d:	75 21                	jne    c00293b0 <strlen+0x2d>
c002938f:	83 ec 0c             	sub    $0xc,%esp
c0029392:	68 9d 14 03 c0       	push   $0xc003149d
c0029397:	68 fd 13 03 c0       	push   $0xc00313fd
c002939c:	68 38 15 03 c0       	push   $0xc0031538
c00293a1:	68 29 01 00 00       	push   $0x129
c00293a6:	68 14 14 03 c0       	push   $0xc0031414
c00293ab:	e8 72 0c 00 00       	call   c002a022 <debug_panic>

  for (p = string; *p != '\0'; p++)
c00293b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00293b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00293b6:	eb 03                	jmp    c00293bb <strlen+0x38>
c00293b8:	ff 45 f4             	incl   -0xc(%ebp)
c00293bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293be:	8a 00                	mov    (%eax),%al
c00293c0:	84 c0                	test   %al,%al
c00293c2:	75 f4                	jne    c00293b8 <strlen+0x35>
    continue;
  return p - string;
c00293c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00293c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00293ca:	29 c2                	sub    %eax,%edx
c00293cc:	89 d0                	mov    %edx,%eax
}
c00293ce:	c9                   	leave  
c00293cf:	c3                   	ret    

c00293d0 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00293d0:	55                   	push   %ebp
c00293d1:	89 e5                	mov    %esp,%ebp
c00293d3:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00293d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00293dd:	eb 03                	jmp    c00293e2 <strnlen+0x12>
c00293df:	ff 45 fc             	incl   -0x4(%ebp)
c00293e2:	8b 55 08             	mov    0x8(%ebp),%edx
c00293e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00293e8:	01 d0                	add    %edx,%eax
c00293ea:	8a 00                	mov    (%eax),%al
c00293ec:	84 c0                	test   %al,%al
c00293ee:	74 08                	je     c00293f8 <strnlen+0x28>
c00293f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00293f3:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00293f6:	72 e7                	jb     c00293df <strnlen+0xf>
    continue;
  return length;
c00293f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00293fb:	c9                   	leave  
c00293fc:	c3                   	ret    

c00293fd <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c00293fd:	55                   	push   %ebp
c00293fe:	89 e5                	mov    %esp,%ebp
c0029400:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0029403:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029407:	75 21                	jne    c002942a <strlcpy+0x2d>
c0029409:	83 ec 0c             	sub    $0xc,%esp
c002940c:	68 da 14 03 c0       	push   $0xc00314da
c0029411:	68 fd 13 03 c0       	push   $0xc00313fd
c0029416:	68 40 15 03 c0       	push   $0xc0031540
c002941b:	68 4a 01 00 00       	push   $0x14a
c0029420:	68 14 14 03 c0       	push   $0xc0031414
c0029425:	e8 f8 0b 00 00       	call   c002a022 <debug_panic>
  ASSERT (src != NULL);
c002942a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002942e:	75 21                	jne    c0029451 <strlcpy+0x54>
c0029430:	83 ec 0c             	sub    $0xc,%esp
c0029433:	68 e6 14 03 c0       	push   $0xc00314e6
c0029438:	68 fd 13 03 c0       	push   $0xc00313fd
c002943d:	68 40 15 03 c0       	push   $0xc0031540
c0029442:	68 4b 01 00 00       	push   $0x14b
c0029447:	68 14 14 03 c0       	push   $0xc0031414
c002944c:	e8 d1 0b 00 00       	call   c002a022 <debug_panic>

  src_len = strlen (src);
c0029451:	83 ec 0c             	sub    $0xc,%esp
c0029454:	ff 75 0c             	pushl  0xc(%ebp)
c0029457:	e8 27 ff ff ff       	call   c0029383 <strlen>
c002945c:	83 c4 10             	add    $0x10,%esp
c002945f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c0029462:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029466:	74 34                	je     c002949c <strlcpy+0x9f>
    {
      size_t dst_len = size - 1;
c0029468:	8b 45 10             	mov    0x10(%ebp),%eax
c002946b:	48                   	dec    %eax
c002946c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c002946f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029472:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029475:	73 06                	jae    c002947d <strlcpy+0x80>
        dst_len = src_len;
c0029477:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002947a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c002947d:	83 ec 04             	sub    $0x4,%esp
c0029480:	ff 75 f4             	pushl  -0xc(%ebp)
c0029483:	ff 75 0c             	pushl  0xc(%ebp)
c0029486:	ff 75 08             	pushl  0x8(%ebp)
c0029489:	e8 c2 f8 ff ff       	call   c0028d50 <memcpy>
c002948e:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c0029491:	8b 55 08             	mov    0x8(%ebp),%edx
c0029494:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029497:	01 d0                	add    %edx,%eax
c0029499:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c002949c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002949f:	c9                   	leave  
c00294a0:	c3                   	ret    

c00294a1 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c00294a1:	55                   	push   %ebp
c00294a2:	89 e5                	mov    %esp,%ebp
c00294a4:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c00294a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00294ab:	75 21                	jne    c00294ce <strlcat+0x2d>
c00294ad:	83 ec 0c             	sub    $0xc,%esp
c00294b0:	68 da 14 03 c0       	push   $0xc00314da
c00294b5:	68 fd 13 03 c0       	push   $0xc00313fd
c00294ba:	68 48 15 03 c0       	push   $0xc0031548
c00294bf:	68 68 01 00 00       	push   $0x168
c00294c4:	68 14 14 03 c0       	push   $0xc0031414
c00294c9:	e8 54 0b 00 00       	call   c002a022 <debug_panic>
  ASSERT (src != NULL);
c00294ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00294d2:	75 21                	jne    c00294f5 <strlcat+0x54>
c00294d4:	83 ec 0c             	sub    $0xc,%esp
c00294d7:	68 e6 14 03 c0       	push   $0xc00314e6
c00294dc:	68 fd 13 03 c0       	push   $0xc00313fd
c00294e1:	68 48 15 03 c0       	push   $0xc0031548
c00294e6:	68 69 01 00 00       	push   $0x169
c00294eb:	68 14 14 03 c0       	push   $0xc0031414
c00294f0:	e8 2d 0b 00 00       	call   c002a022 <debug_panic>

  src_len = strlen (src);
c00294f5:	83 ec 0c             	sub    $0xc,%esp
c00294f8:	ff 75 0c             	pushl  0xc(%ebp)
c00294fb:	e8 83 fe ff ff       	call   c0029383 <strlen>
c0029500:	83 c4 10             	add    $0x10,%esp
c0029503:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0029506:	83 ec 0c             	sub    $0xc,%esp
c0029509:	ff 75 08             	pushl  0x8(%ebp)
c002950c:	e8 72 fe ff ff       	call   c0029383 <strlen>
c0029511:	83 c4 10             	add    $0x10,%esp
c0029514:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0029517:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002951b:	74 4a                	je     c0029567 <strlcat+0xc6>
c002951d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029520:	3b 45 10             	cmp    0x10(%ebp),%eax
c0029523:	73 42                	jae    c0029567 <strlcat+0xc6>
    {
      size_t copy_cnt = size - dst_len - 1;
c0029525:	8b 45 10             	mov    0x10(%ebp),%eax
c0029528:	2b 45 ec             	sub    -0x14(%ebp),%eax
c002952b:	48                   	dec    %eax
c002952c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c002952f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029532:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029535:	73 06                	jae    c002953d <strlcat+0x9c>
        copy_cnt = src_len;
c0029537:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002953a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c002953d:	8b 55 08             	mov    0x8(%ebp),%edx
c0029540:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029543:	01 d0                	add    %edx,%eax
c0029545:	83 ec 04             	sub    $0x4,%esp
c0029548:	ff 75 f4             	pushl  -0xc(%ebp)
c002954b:	ff 75 0c             	pushl  0xc(%ebp)
c002954e:	50                   	push   %eax
c002954f:	e8 fc f7 ff ff       	call   c0028d50 <memcpy>
c0029554:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0029557:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002955a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002955d:	01 c2                	add    %eax,%edx
c002955f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029562:	01 d0                	add    %edx,%eax
c0029564:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0029567:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002956a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002956d:	01 d0                	add    %edx,%eax
}
c002956f:	c9                   	leave  
c0029570:	c3                   	ret    

c0029571 <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c0029571:	55                   	push   %ebp
c0029572:	89 e5                	mov    %esp,%ebp
c0029574:	83 ec 18             	sub    $0x18,%esp
c0029577:	8b 45 08             	mov    0x8(%ebp),%eax
c002957a:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002957d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029580:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0029583:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029586:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029589:	89 d0                	mov    %edx,%eax
c002958b:	31 d2                	xor    %edx,%edx
c002958d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c0029590:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029593:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0029596:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029599:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002959c:	f7 75 10             	divl   0x10(%ebp)
c002959f:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00295a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c00295a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00295a8:	c9                   	leave  
c00295a9:	c3                   	ret    

c00295aa <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c00295aa:	55                   	push   %ebp
c00295ab:	89 e5                	mov    %esp,%ebp
c00295ad:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c00295b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c00295b7:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c00295be:	77 08                	ja     c00295c8 <nlz+0x1e>
    {
      n += 16;
c00295c0:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c00295c4:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c00295c8:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c00295cf:	77 08                	ja     c00295d9 <nlz+0x2f>
    {
      n += 8;
c00295d1:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c00295d5:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c00295d9:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c00295e0:	77 08                	ja     c00295ea <nlz+0x40>
    {
      n += 4;
c00295e2:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c00295e6:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c00295ea:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c00295f1:	77 08                	ja     c00295fb <nlz+0x51>
    {
      n += 2;
c00295f3:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c00295f7:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c00295fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00295fe:	85 c0                	test   %eax,%eax
c0029600:	78 03                	js     c0029605 <nlz+0x5b>
    n++;
c0029602:	ff 45 fc             	incl   -0x4(%ebp)
  return n;
c0029605:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0029608:	c9                   	leave  
c0029609:	c3                   	ret    

c002960a <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c002960a:	55                   	push   %ebp
c002960b:	89 e5                	mov    %esp,%ebp
c002960d:	57                   	push   %edi
c002960e:	56                   	push   %esi
c002960f:	53                   	push   %ebx
c0029610:	83 ec 44             	sub    $0x44,%esp
c0029613:	8b 45 08             	mov    0x8(%ebp),%eax
c0029616:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0029619:	8b 45 0c             	mov    0xc(%ebp),%eax
c002961c:	89 45 bc             	mov    %eax,-0x44(%ebp)
c002961f:	8b 45 10             	mov    0x10(%ebp),%eax
c0029622:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0029625:	8b 45 14             	mov    0x14(%ebp),%eax
c0029628:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c002962b:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002962e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0029631:	89 d0                	mov    %edx,%eax
c0029633:	31 d2                	xor    %edx,%edx
c0029635:	89 c7                	mov    %eax,%edi
c0029637:	83 f7 00             	xor    $0x0,%edi
c002963a:	89 f9                	mov    %edi,%ecx
c002963c:	89 d0                	mov    %edx,%eax
c002963e:	80 f4 00             	xor    $0x0,%ah
c0029641:	89 c3                	mov    %eax,%ebx
c0029643:	89 d8                	mov    %ebx,%eax
c0029645:	09 c8                	or     %ecx,%eax
c0029647:	85 c0                	test   %eax,%eax
c0029649:	0f 85 a3 00 00 00    	jne    c00296f2 <udiv64+0xe8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c002964f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0029656:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c002965d:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0029660:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0029663:	89 d0                	mov    %edx,%eax
c0029665:	31 d2                	xor    %edx,%edx
c0029667:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c002966a:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002966d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c0029670:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0029673:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0029676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0029679:	ba 00 00 00 00       	mov    $0x0,%edx
c002967e:	f7 75 dc             	divl   -0x24(%ebp)
c0029681:	89 d0                	mov    %edx,%eax
c0029683:	ba 00 00 00 00       	mov    $0x0,%edx
c0029688:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002968b:	89 cb                	mov    %ecx,%ebx
c002968d:	0f af da             	imul   %edx,%ebx
c0029690:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0029693:	0f af c8             	imul   %eax,%ecx
c0029696:	01 d9                	add    %ebx,%ecx
c0029698:	f7 65 e8             	mull   -0x18(%ebp)
c002969b:	01 d1                	add    %edx,%ecx
c002969d:	89 ca                	mov    %ecx,%edx
c002969f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c00296a2:	bb 00 00 00 00       	mov    $0x0,%ebx
c00296a7:	01 c8                	add    %ecx,%eax
c00296a9:	11 da                	adc    %ebx,%edx
c00296ab:	83 ec 04             	sub    $0x4,%esp
c00296ae:	ff 75 dc             	pushl  -0x24(%ebp)
c00296b1:	52                   	push   %edx
c00296b2:	50                   	push   %eax
c00296b3:	e8 b9 fe ff ff       	call   c0029571 <divl>
c00296b8:	83 c4 10             	add    $0x10,%esp
c00296bb:	89 c1                	mov    %eax,%ecx
c00296bd:	bb 00 00 00 00       	mov    $0x0,%ebx
c00296c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00296c5:	ba 00 00 00 00       	mov    $0x0,%edx
c00296ca:	f7 75 dc             	divl   -0x24(%ebp)
c00296cd:	ba 00 00 00 00       	mov    $0x0,%edx
c00296d2:	8b 75 e8             	mov    -0x18(%ebp),%esi
c00296d5:	89 f7                	mov    %esi,%edi
c00296d7:	0f af fa             	imul   %edx,%edi
c00296da:	8b 75 ec             	mov    -0x14(%ebp),%esi
c00296dd:	0f af f0             	imul   %eax,%esi
c00296e0:	01 fe                	add    %edi,%esi
c00296e2:	f7 65 e8             	mull   -0x18(%ebp)
c00296e5:	01 d6                	add    %edx,%esi
c00296e7:	89 f2                	mov    %esi,%edx
c00296e9:	01 c8                	add    %ecx,%eax
c00296eb:	11 da                	adc    %ebx,%edx
c00296ed:	e9 e7 00 00 00       	jmp    c00297d9 <udiv64+0x1cf>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c00296f2:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00296f5:	8b 55 bc             	mov    -0x44(%ebp),%edx
c00296f8:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c00296fb:	77 19                	ja     c0029716 <udiv64+0x10c>
c00296fd:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0029700:	72 05                	jb     c0029707 <udiv64+0xfd>
c0029702:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0029705:	73 0f                	jae    c0029716 <udiv64+0x10c>
        return 0;
c0029707:	b8 00 00 00 00       	mov    $0x0,%eax
c002970c:	ba 00 00 00 00       	mov    $0x0,%edx
c0029711:	e9 c3 00 00 00       	jmp    c00297d9 <udiv64+0x1cf>
      else 
        {
          uint32_t d1 = d >> 32;
c0029716:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0029719:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002971c:	89 d0                	mov    %edx,%eax
c002971e:	31 d2                	xor    %edx,%edx
c0029720:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c0029723:	83 ec 04             	sub    $0x4,%esp
c0029726:	ff 75 d8             	pushl  -0x28(%ebp)
c0029729:	e8 7c fe ff ff       	call   c00295aa <nlz>
c002972e:	83 c4 08             	add    $0x8,%esp
c0029731:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0029734:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0029737:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002973a:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002973d:	0f a5 c2             	shld   %cl,%eax,%edx
c0029740:	d3 e0                	shl    %cl,%eax
c0029742:	f6 c1 20             	test   $0x20,%cl
c0029745:	74 04                	je     c002974b <udiv64+0x141>
c0029747:	89 c2                	mov    %eax,%edx
c0029749:	31 c0                	xor    %eax,%eax
c002974b:	89 d0                	mov    %edx,%eax
c002974d:	31 d2                	xor    %edx,%edx
c002974f:	89 c1                	mov    %eax,%ecx
c0029751:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0029754:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0029757:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c002975b:	d1 ea                	shr    %edx
c002975d:	83 ec 04             	sub    $0x4,%esp
c0029760:	51                   	push   %ecx
c0029761:	52                   	push   %edx
c0029762:	50                   	push   %eax
c0029763:	e8 09 fe ff ff       	call   c0029571 <divl>
c0029768:	83 c4 10             	add    $0x10,%esp
c002976b:	89 c2                	mov    %eax,%edx
c002976d:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0029772:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0029775:	88 c1                	mov    %al,%cl
c0029777:	d3 ea                	shr    %cl,%edx
c0029779:	89 d0                	mov    %edx,%eax
c002977b:	89 45 c8             	mov    %eax,-0x38(%ebp)
c002977e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0029785:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029788:	8b 55 cc             	mov    -0x34(%ebp),%edx
c002978b:	83 c0 ff             	add    $0xffffffff,%eax
c002978e:	83 d2 ff             	adc    $0xffffffff,%edx
c0029791:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0029794:	89 cb                	mov    %ecx,%ebx
c0029796:	0f af da             	imul   %edx,%ebx
c0029799:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c002979c:	0f af c8             	imul   %eax,%ecx
c002979f:	01 d9                	add    %ebx,%ecx
c00297a1:	f7 65 b0             	mull   -0x50(%ebp)
c00297a4:	01 d1                	add    %edx,%ecx
c00297a6:	89 ca                	mov    %ecx,%edx
c00297a8:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c00297ab:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c00297ae:	29 c1                	sub    %eax,%ecx
c00297b0:	19 d3                	sbb    %edx,%ebx
c00297b2:	89 c8                	mov    %ecx,%eax
c00297b4:	89 da                	mov    %ebx,%edx
c00297b6:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c00297b9:	77 18                	ja     c00297d3 <udiv64+0x1c9>
c00297bb:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c00297be:	72 05                	jb     c00297c5 <udiv64+0x1bb>
c00297c0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c00297c3:	73 0e                	jae    c00297d3 <udiv64+0x1c9>
c00297c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00297c8:	8b 55 cc             	mov    -0x34(%ebp),%edx
c00297cb:	83 c0 ff             	add    $0xffffffff,%eax
c00297ce:	83 d2 ff             	adc    $0xffffffff,%edx
c00297d1:	eb 06                	jmp    c00297d9 <udiv64+0x1cf>
c00297d3:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00297d6:	8b 55 cc             	mov    -0x34(%ebp),%edx
        }
    }
}
c00297d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00297dc:	5b                   	pop    %ebx
c00297dd:	5e                   	pop    %esi
c00297de:	5f                   	pop    %edi
c00297df:	5d                   	pop    %ebp
c00297e0:	c3                   	ret    

c00297e1 <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c00297e1:	55                   	push   %ebp
c00297e2:	89 e5                	mov    %esp,%ebp
c00297e4:	53                   	push   %ebx
c00297e5:	83 ec 14             	sub    $0x14,%esp
c00297e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00297eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00297ee:	8b 45 0c             	mov    0xc(%ebp),%eax
c00297f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00297f4:	8b 45 10             	mov    0x10(%ebp),%eax
c00297f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00297fa:	8b 45 14             	mov    0x14(%ebp),%eax
c00297fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c0029800:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0029803:	ff 75 ec             	pushl  -0x14(%ebp)
c0029806:	ff 75 e8             	pushl  -0x18(%ebp)
c0029809:	ff 75 f4             	pushl  -0xc(%ebp)
c002980c:	ff 75 f0             	pushl  -0x10(%ebp)
c002980f:	e8 f6 fd ff ff       	call   c002960a <udiv64>
c0029814:	83 c4 10             	add    $0x10,%esp
c0029817:	89 c2                	mov    %eax,%edx
c0029819:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002981c:	0f af c2             	imul   %edx,%eax
c002981f:	29 c3                	sub    %eax,%ebx
c0029821:	89 d8                	mov    %ebx,%eax
}
c0029823:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029826:	c9                   	leave  
c0029827:	c3                   	ret    

c0029828 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0029828:	55                   	push   %ebp
c0029829:	89 e5                	mov    %esp,%ebp
c002982b:	83 ec 30             	sub    $0x30,%esp
c002982e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029831:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0029834:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029837:	89 45 dc             	mov    %eax,-0x24(%ebp)
c002983a:	8b 45 10             	mov    0x10(%ebp),%eax
c002983d:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0029840:	8b 45 14             	mov    0x14(%ebp),%eax
c0029843:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0029846:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c002984a:	79 0f                	jns    c002985b <sdiv64+0x33>
c002984c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002984f:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0029852:	f7 d8                	neg    %eax
c0029854:	83 d2 00             	adc    $0x0,%edx
c0029857:	f7 da                	neg    %edx
c0029859:	eb 06                	jmp    c0029861 <sdiv64+0x39>
c002985b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002985e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0029861:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029864:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0029867:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002986b:	79 0f                	jns    c002987c <sdiv64+0x54>
c002986d:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0029870:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0029873:	f7 d8                	neg    %eax
c0029875:	83 d2 00             	adc    $0x0,%edx
c0029878:	f7 da                	neg    %edx
c002987a:	eb 06                	jmp    c0029882 <sdiv64+0x5a>
c002987c:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002987f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0029882:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029885:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0029888:	ff 75 f4             	pushl  -0xc(%ebp)
c002988b:	ff 75 f0             	pushl  -0x10(%ebp)
c002988e:	ff 75 fc             	pushl  -0x4(%ebp)
c0029891:	ff 75 f8             	pushl  -0x8(%ebp)
c0029894:	e8 71 fd ff ff       	call   c002960a <udiv64>
c0029899:	83 c4 10             	add    $0x10,%esp
c002989c:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002989f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c00298a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00298a5:	f7 d0                	not    %eax
c00298a7:	c1 e8 1f             	shr    $0x1f,%eax
c00298aa:	88 c2                	mov    %al,%dl
c00298ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00298af:	c1 e8 1f             	shr    $0x1f,%eax
c00298b2:	31 d0                	xor    %edx,%eax
c00298b4:	84 c0                	test   %al,%al
c00298b6:	74 08                	je     c00298c0 <sdiv64+0x98>
c00298b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00298be:	eb 0d                	jmp    c00298cd <sdiv64+0xa5>
c00298c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00298c6:	f7 d8                	neg    %eax
c00298c8:	83 d2 00             	adc    $0x0,%edx
c00298cb:	f7 da                	neg    %edx
}
c00298cd:	c9                   	leave  
c00298ce:	c3                   	ret    

c00298cf <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c00298cf:	55                   	push   %ebp
c00298d0:	89 e5                	mov    %esp,%ebp
c00298d2:	53                   	push   %ebx
c00298d3:	83 ec 14             	sub    $0x14,%esp
c00298d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00298d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00298dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00298df:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00298e2:	8b 45 10             	mov    0x10(%ebp),%eax
c00298e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00298e8:	8b 45 14             	mov    0x14(%ebp),%eax
c00298eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c00298ee:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c00298f1:	ff 75 ec             	pushl  -0x14(%ebp)
c00298f4:	ff 75 e8             	pushl  -0x18(%ebp)
c00298f7:	ff 75 f4             	pushl  -0xc(%ebp)
c00298fa:	ff 75 f0             	pushl  -0x10(%ebp)
c00298fd:	e8 26 ff ff ff       	call   c0029828 <sdiv64>
c0029902:	83 c4 10             	add    $0x10,%esp
c0029905:	89 c2                	mov    %eax,%edx
c0029907:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002990a:	0f af c2             	imul   %edx,%eax
c002990d:	29 c3                	sub    %eax,%ebx
c002990f:	89 d8                	mov    %ebx,%eax
}
c0029911:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029914:	c9                   	leave  
c0029915:	c3                   	ret    

c0029916 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0029916:	55                   	push   %ebp
c0029917:	89 e5                	mov    %esp,%ebp
c0029919:	83 ec 10             	sub    $0x10,%esp
c002991c:	8b 45 08             	mov    0x8(%ebp),%eax
c002991f:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029922:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029925:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029928:	8b 45 10             	mov    0x10(%ebp),%eax
c002992b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002992e:	8b 45 14             	mov    0x14(%ebp),%eax
c0029931:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0029934:	ff 75 f4             	pushl  -0xc(%ebp)
c0029937:	ff 75 f0             	pushl  -0x10(%ebp)
c002993a:	ff 75 fc             	pushl  -0x4(%ebp)
c002993d:	ff 75 f8             	pushl  -0x8(%ebp)
c0029940:	e8 e3 fe ff ff       	call   c0029828 <sdiv64>
c0029945:	83 c4 10             	add    $0x10,%esp
}
c0029948:	c9                   	leave  
c0029949:	c3                   	ret    

c002994a <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c002994a:	55                   	push   %ebp
c002994b:	89 e5                	mov    %esp,%ebp
c002994d:	83 ec 10             	sub    $0x10,%esp
c0029950:	8b 45 08             	mov    0x8(%ebp),%eax
c0029953:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029956:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029959:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002995c:	8b 45 10             	mov    0x10(%ebp),%eax
c002995f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029962:	8b 45 14             	mov    0x14(%ebp),%eax
c0029965:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c0029968:	ff 75 f4             	pushl  -0xc(%ebp)
c002996b:	ff 75 f0             	pushl  -0x10(%ebp)
c002996e:	ff 75 fc             	pushl  -0x4(%ebp)
c0029971:	ff 75 f8             	pushl  -0x8(%ebp)
c0029974:	e8 56 ff ff ff       	call   c00298cf <smod64>
c0029979:	83 c4 10             	add    $0x10,%esp
c002997c:	99                   	cltd   
}
c002997d:	c9                   	leave  
c002997e:	c3                   	ret    

c002997f <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c002997f:	55                   	push   %ebp
c0029980:	89 e5                	mov    %esp,%ebp
c0029982:	83 ec 10             	sub    $0x10,%esp
c0029985:	8b 45 08             	mov    0x8(%ebp),%eax
c0029988:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002998b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002998e:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029991:	8b 45 10             	mov    0x10(%ebp),%eax
c0029994:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029997:	8b 45 14             	mov    0x14(%ebp),%eax
c002999a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c002999d:	ff 75 f4             	pushl  -0xc(%ebp)
c00299a0:	ff 75 f0             	pushl  -0x10(%ebp)
c00299a3:	ff 75 fc             	pushl  -0x4(%ebp)
c00299a6:	ff 75 f8             	pushl  -0x8(%ebp)
c00299a9:	e8 5c fc ff ff       	call   c002960a <udiv64>
c00299ae:	83 c4 10             	add    $0x10,%esp
}
c00299b1:	c9                   	leave  
c00299b2:	c3                   	ret    

c00299b3 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c00299b3:	55                   	push   %ebp
c00299b4:	89 e5                	mov    %esp,%ebp
c00299b6:	83 ec 10             	sub    $0x10,%esp
c00299b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00299bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00299bf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00299c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00299c5:	8b 45 10             	mov    0x10(%ebp),%eax
c00299c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00299cb:	8b 45 14             	mov    0x14(%ebp),%eax
c00299ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c00299d1:	ff 75 f4             	pushl  -0xc(%ebp)
c00299d4:	ff 75 f0             	pushl  -0x10(%ebp)
c00299d7:	ff 75 fc             	pushl  -0x4(%ebp)
c00299da:	ff 75 f8             	pushl  -0x8(%ebp)
c00299dd:	e8 ff fd ff ff       	call   c00297e1 <umod64>
c00299e2:	83 c4 10             	add    $0x10,%esp
c00299e5:	ba 00 00 00 00       	mov    $0x0,%edx
}
c00299ea:	c9                   	leave  
c00299eb:	c3                   	ret    

c00299ec <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c00299ec:	55                   	push   %ebp
c00299ed:	89 e5                	mov    %esp,%ebp
c00299ef:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c00299f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00299f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c00299f8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c00299ff:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0029a06:	eb 57                	jmp    c0029a5f <calculate_chksum+0x73>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c0029a08:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c0029a0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029a12:	83 c0 08             	add    $0x8,%eax
c0029a15:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c0029a18:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029a1b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0029a1e:	72 0f                	jb     c0029a2f <calculate_chksum+0x43>
c0029a20:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029a23:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0029a26:	73 07                	jae    c0029a2f <calculate_chksum+0x43>
c0029a28:	b8 01 00 00 00       	mov    $0x1,%eax
c0029a2d:	eb 05                	jmp    c0029a34 <calculate_chksum+0x48>
c0029a2f:	b8 00 00 00 00       	mov    $0x0,%eax
c0029a34:	88 45 eb             	mov    %al,-0x15(%ebp)
c0029a37:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c0029a3b:	8a 45 eb             	mov    -0x15(%ebp),%al
c0029a3e:	83 f0 01             	xor    $0x1,%eax
c0029a41:	84 c0                	test   %al,%al
c0029a43:	74 0f                	je     c0029a54 <calculate_chksum+0x68>
c0029a45:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029a48:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029a4b:	01 d0                	add    %edx,%eax
c0029a4d:	8a 00                	mov    (%eax),%al
c0029a4f:	0f b6 c0             	movzbl %al,%eax
c0029a52:	eb 05                	jmp    c0029a59 <calculate_chksum+0x6d>
c0029a54:	b8 20 00 00 00       	mov    $0x20,%eax
c0029a59:	01 45 fc             	add    %eax,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029a5c:	ff 45 f8             	incl   -0x8(%ebp)
c0029a5f:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c0029a66:	76 a0                	jbe    c0029a08 <calculate_chksum+0x1c>
    }
  return chksum;
c0029a68:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0029a6b:	c9                   	leave  
c0029a6c:	c3                   	ret    

c0029a6d <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c0029a6d:	55                   	push   %ebp
c0029a6e:	89 e5                	mov    %esp,%ebp
c0029a70:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c0029a73:	eb 14                	jmp    c0029a89 <strip_antisocial_prefixes+0x1c>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c0029a75:	83 ec 08             	sub    $0x8,%esp
c0029a78:	6a 2f                	push   $0x2f
c0029a7a:	ff 75 08             	pushl  0x8(%ebp)
c0029a7d:	e8 cd f5 ff ff       	call   c002904f <strchr>
c0029a82:	83 c4 10             	add    $0x10,%esp
c0029a85:	40                   	inc    %eax
c0029a86:	89 45 08             	mov    %eax,0x8(%ebp)
  while (*file_name == '/'
c0029a89:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a8c:	8a 00                	mov    (%eax),%al
c0029a8e:	3c 2f                	cmp    $0x2f,%al
c0029a90:	74 e3                	je     c0029a75 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c0029a92:	83 ec 04             	sub    $0x4,%esp
c0029a95:	6a 02                	push   $0x2
c0029a97:	68 50 15 03 c0       	push   $0xc0031550
c0029a9c:	ff 75 08             	pushl  0x8(%ebp)
c0029a9f:	e8 ff f3 ff ff       	call   c0028ea3 <memcmp>
c0029aa4:	83 c4 10             	add    $0x10,%esp
c0029aa7:	85 c0                	test   %eax,%eax
c0029aa9:	74 ca                	je     c0029a75 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c0029aab:	83 ec 04             	sub    $0x4,%esp
c0029aae:	6a 03                	push   $0x3
c0029ab0:	68 53 15 03 c0       	push   $0xc0031553
c0029ab5:	ff 75 08             	pushl  0x8(%ebp)
c0029ab8:	e8 e6 f3 ff ff       	call   c0028ea3 <memcmp>
c0029abd:	83 c4 10             	add    $0x10,%esp
c0029ac0:	85 c0                	test   %eax,%eax
c0029ac2:	74 b1                	je     c0029a75 <strip_antisocial_prefixes+0x8>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0029ac4:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ac7:	8a 00                	mov    (%eax),%al
c0029ac9:	84 c0                	test   %al,%al
c0029acb:	74 1c                	je     c0029ae9 <strip_antisocial_prefixes+0x7c>
c0029acd:	83 ec 08             	sub    $0x8,%esp
c0029ad0:	68 57 15 03 c0       	push   $0xc0031557
c0029ad5:	ff 75 08             	pushl  0x8(%ebp)
c0029ad8:	e8 70 f4 ff ff       	call   c0028f4d <strcmp>
c0029add:	83 c4 10             	add    $0x10,%esp
c0029ae0:	85 c0                	test   %eax,%eax
c0029ae2:	74 05                	je     c0029ae9 <strip_antisocial_prefixes+0x7c>
c0029ae4:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ae7:	eb 05                	jmp    c0029aee <strip_antisocial_prefixes+0x81>
c0029ae9:	b8 5a 15 03 c0       	mov    $0xc003155a,%eax
}
c0029aee:	c9                   	leave  
c0029aef:	c3                   	ret    

c0029af0 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c0029af0:	55                   	push   %ebp
c0029af1:	89 e5                	mov    %esp,%ebp
c0029af3:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c0029af6:	8b 45 14             	mov    0x14(%ebp),%eax
c0029af9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0029afc:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c0029b00:	74 24                	je     c0029b26 <ustar_make_header+0x36>
c0029b02:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c0029b06:	74 1e                	je     c0029b26 <ustar_make_header+0x36>
c0029b08:	83 ec 0c             	sub    $0xc,%esp
c0029b0b:	68 5c 15 03 c0       	push   $0xc003155c
c0029b10:	68 8d 15 03 c0       	push   $0xc003158d
c0029b15:	68 90 16 03 c0       	push   $0xc0031690
c0029b1a:	6a 59                	push   $0x59
c0029b1c:	68 a4 15 03 c0       	push   $0xc00315a4
c0029b21:	e8 fc 04 00 00       	call   c002a022 <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c0029b26:	83 ec 0c             	sub    $0xc,%esp
c0029b29:	ff 75 08             	pushl  0x8(%ebp)
c0029b2c:	e8 3c ff ff ff       	call   c0029a6d <strip_antisocial_prefixes>
c0029b31:	83 c4 10             	add    $0x10,%esp
c0029b34:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c0029b37:	83 ec 0c             	sub    $0xc,%esp
c0029b3a:	ff 75 08             	pushl  0x8(%ebp)
c0029b3d:	e8 41 f8 ff ff       	call   c0029383 <strlen>
c0029b42:	83 c4 10             	add    $0x10,%esp
c0029b45:	83 f8 63             	cmp    $0x63,%eax
c0029b48:	76 1a                	jbe    c0029b64 <ustar_make_header+0x74>
    {
      printf ("%s: file name too long\n", file_name);
c0029b4a:	83 ec 08             	sub    $0x8,%esp
c0029b4d:	ff 75 08             	pushl  0x8(%ebp)
c0029b50:	68 b6 15 03 c0       	push   $0xc00315b6
c0029b55:	e8 f7 df ff ff       	call   c0027b51 <printf>
c0029b5a:	83 c4 10             	add    $0x10,%esp
      return false;
c0029b5d:	b0 00                	mov    $0x0,%al
c0029b5f:	e9 5f 01 00 00       	jmp    c0029cc3 <ustar_make_header+0x1d3>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c0029b64:	83 ec 04             	sub    $0x4,%esp
c0029b67:	68 00 02 00 00       	push   $0x200
c0029b6c:	6a 00                	push   $0x0
c0029b6e:	ff 75 f4             	pushl  -0xc(%ebp)
c0029b71:	e8 b4 f7 ff ff       	call   c002932a <memset>
c0029b76:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c0029b79:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b7c:	83 ec 04             	sub    $0x4,%esp
c0029b7f:	6a 64                	push   $0x64
c0029b81:	ff 75 08             	pushl  0x8(%ebp)
c0029b84:	50                   	push   %eax
c0029b85:	e8 73 f8 ff ff       	call   c00293fd <strlcpy>
c0029b8a:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c0029b8d:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c0029b91:	75 07                	jne    c0029b9a <ustar_make_header+0xaa>
c0029b93:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0029b98:	eb 05                	jmp    c0029b9f <ustar_make_header+0xaf>
c0029b9a:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c0029b9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029ba2:	83 c2 64             	add    $0x64,%edx
c0029ba5:	50                   	push   %eax
c0029ba6:	68 ce 15 03 c0       	push   $0xc00315ce
c0029bab:	6a 08                	push   $0x8
c0029bad:	52                   	push   %edx
c0029bae:	e8 75 df ff ff       	call   c0027b28 <snprintf>
c0029bb3:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0029bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029bb9:	83 c0 6c             	add    $0x6c,%eax
c0029bbc:	83 ec 04             	sub    $0x4,%esp
c0029bbf:	6a 08                	push   $0x8
c0029bc1:	68 d3 15 03 c0       	push   $0xc00315d3
c0029bc6:	50                   	push   %eax
c0029bc7:	e8 31 f8 ff ff       	call   c00293fd <strlcpy>
c0029bcc:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0029bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029bd2:	83 c0 74             	add    $0x74,%eax
c0029bd5:	83 ec 04             	sub    $0x4,%esp
c0029bd8:	6a 08                	push   $0x8
c0029bda:	68 d3 15 03 c0       	push   $0xc00315d3
c0029bdf:	50                   	push   %eax
c0029be0:	e8 18 f8 ff ff       	call   c00293fd <strlcpy>
c0029be5:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c0029be8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029beb:	83 c0 7c             	add    $0x7c,%eax
c0029bee:	ff 75 10             	pushl  0x10(%ebp)
c0029bf1:	68 db 15 03 c0       	push   $0xc00315db
c0029bf6:	6a 0c                	push   $0xc
c0029bf8:	50                   	push   %eax
c0029bf9:	e8 2a df ff ff       	call   c0027b28 <snprintf>
c0029bfe:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0029c01:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c04:	05 88 00 00 00       	add    $0x88,%eax
c0029c09:	68 00 8c b7 43       	push   $0x43b78c00
c0029c0e:	68 db 15 03 c0       	push   $0xc00315db
c0029c13:	6a 0c                	push   $0xc
c0029c15:	50                   	push   %eax
c0029c16:	e8 0d df ff ff       	call   c0027b28 <snprintf>
c0029c1b:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c0029c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c21:	88 c2                	mov    %al,%dl
c0029c23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c26:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0029c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c2f:	05 01 01 00 00       	add    $0x101,%eax
c0029c34:	83 ec 04             	sub    $0x4,%esp
c0029c37:	6a 06                	push   $0x6
c0029c39:	68 e1 15 03 c0       	push   $0xc00315e1
c0029c3e:	50                   	push   %eax
c0029c3f:	e8 b9 f7 ff ff       	call   c00293fd <strlcpy>
c0029c44:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c0029c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c4a:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c0029c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c54:	8a 90 08 01 00 00    	mov    0x108(%eax),%dl
c0029c5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c5d:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c0029c63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c66:	05 29 01 00 00       	add    $0x129,%eax
c0029c6b:	83 ec 04             	sub    $0x4,%esp
c0029c6e:	6a 20                	push   $0x20
c0029c70:	68 e7 15 03 c0       	push   $0xc00315e7
c0029c75:	50                   	push   %eax
c0029c76:	e8 82 f7 ff ff       	call   c00293fd <strlcpy>
c0029c7b:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c0029c7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c81:	05 09 01 00 00       	add    $0x109,%eax
c0029c86:	83 ec 04             	sub    $0x4,%esp
c0029c89:	6a 20                	push   $0x20
c0029c8b:	68 e7 15 03 c0       	push   $0xc00315e7
c0029c90:	50                   	push   %eax
c0029c91:	e8 67 f7 ff ff       	call   c00293fd <strlcpy>
c0029c96:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0029c99:	83 ec 0c             	sub    $0xc,%esp
c0029c9c:	ff 75 f4             	pushl  -0xc(%ebp)
c0029c9f:	e8 48 fd ff ff       	call   c00299ec <calculate_chksum>
c0029ca4:	83 c4 10             	add    $0x10,%esp
c0029ca7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029caa:	81 c2 94 00 00 00    	add    $0x94,%edx
c0029cb0:	50                   	push   %eax
c0029cb1:	68 ce 15 03 c0       	push   $0xc00315ce
c0029cb6:	6a 08                	push   $0x8
c0029cb8:	52                   	push   %edx
c0029cb9:	e8 6a de ff ff       	call   c0027b28 <snprintf>
c0029cbe:	83 c4 10             	add    $0x10,%esp

  return true;
c0029cc1:	b0 01                	mov    $0x1,%al
}
c0029cc3:	c9                   	leave  
c0029cc4:	c3                   	ret    

c0029cc5 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0029cc5:	55                   	push   %ebp
c0029cc6:	89 e5                	mov    %esp,%ebp
c0029cc8:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c0029ccb:	8b 45 10             	mov    0x10(%ebp),%eax
c0029cce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c0029cd4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0029cdb:	eb 5d                	jmp    c0029d3a <parse_octal_field+0x75>
    {
      char c = s[ofs];
c0029cdd:	8b 55 08             	mov    0x8(%ebp),%edx
c0029ce0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029ce3:	01 d0                	add    %edx,%eax
c0029ce5:	8a 00                	mov    (%eax),%al
c0029ce7:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c0029cea:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c0029cee:	7e 31                	jle    c0029d21 <parse_octal_field+0x5c>
c0029cf0:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c0029cf4:	7f 2b                	jg     c0029d21 <parse_octal_field+0x5c>
        {
          if (*value > ULONG_MAX / 8)
c0029cf6:	8b 45 10             	mov    0x10(%ebp),%eax
c0029cf9:	8b 00                	mov    (%eax),%eax
c0029cfb:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c0029d00:	76 04                	jbe    c0029d06 <parse_octal_field+0x41>
            {
              /* Overflow. */
              return false;
c0029d02:	b0 00                	mov    $0x0,%al
c0029d04:	eb 3e                	jmp    c0029d44 <parse_octal_field+0x7f>
            }
          *value = c - '0' + *value * 8;
c0029d06:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c0029d0a:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d0d:	8b 00                	mov    (%eax),%eax
c0029d0f:	c1 e0 03             	shl    $0x3,%eax
c0029d12:	01 d0                	add    %edx,%eax
c0029d14:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029d17:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d1a:	89 10                	mov    %edx,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c0029d1c:	ff 45 fc             	incl   -0x4(%ebp)
c0029d1f:	eb 19                	jmp    c0029d3a <parse_octal_field+0x75>
        }
      else if (c == ' ' || c == '\0')
c0029d21:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c0029d25:	74 06                	je     c0029d2d <parse_octal_field+0x68>
c0029d27:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0029d2b:	75 09                	jne    c0029d36 <parse_octal_field+0x71>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c0029d2d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0029d31:	0f 95 c0             	setne  %al
c0029d34:	eb 0e                	jmp    c0029d44 <parse_octal_field+0x7f>
        }
      else
        {
          /* Bad character. */
          return false;
c0029d36:	b0 00                	mov    $0x0,%al
c0029d38:	eb 0a                	jmp    c0029d44 <parse_octal_field+0x7f>
  for (ofs = 0; ofs < size; ofs++)
c0029d3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029d3d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029d40:	72 9b                	jb     c0029cdd <parse_octal_field+0x18>
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0029d42:	b0 00                	mov    $0x0,%al
}
c0029d44:	c9                   	leave  
c0029d45:	c3                   	ret    

c0029d46 <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c0029d46:	55                   	push   %ebp
c0029d47:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c0029d49:	eb 13                	jmp    c0029d5e <is_all_zeros+0x18>
    if (*block++ != 0)
c0029d4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d4e:	8d 50 01             	lea    0x1(%eax),%edx
c0029d51:	89 55 08             	mov    %edx,0x8(%ebp)
c0029d54:	8a 00                	mov    (%eax),%al
c0029d56:	84 c0                	test   %al,%al
c0029d58:	74 04                	je     c0029d5e <is_all_zeros+0x18>
      return false;
c0029d5a:	b0 00                	mov    $0x0,%al
c0029d5c:	eb 0f                	jmp    c0029d6d <is_all_zeros+0x27>
  while (cnt-- > 0)
c0029d5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d61:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029d64:	89 55 0c             	mov    %edx,0xc(%ebp)
c0029d67:	85 c0                	test   %eax,%eax
c0029d69:	75 e0                	jne    c0029d4b <is_all_zeros+0x5>
  return true;
c0029d6b:	b0 01                	mov    $0x1,%al
}
c0029d6d:	5d                   	pop    %ebp
c0029d6e:	c3                   	ret    

c0029d6f <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0029d6f:	55                   	push   %ebp
c0029d70:	89 e5                	mov    %esp,%ebp
c0029d72:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c0029d75:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d78:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c0029d7b:	68 00 02 00 00       	push   $0x200
c0029d80:	ff 75 08             	pushl  0x8(%ebp)
c0029d83:	e8 be ff ff ff       	call   c0029d46 <is_all_zeros>
c0029d88:	83 c4 08             	add    $0x8,%esp
c0029d8b:	84 c0                	test   %al,%al
c0029d8d:	74 25                	je     c0029db4 <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c0029d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d92:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0029d98:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d9b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0029da1:	8b 45 14             	mov    0x14(%ebp),%eax
c0029da4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0029daa:	b8 00 00 00 00       	mov    $0x0,%eax
c0029daf:	e9 5a 01 00 00       	jmp    c0029f0e <ustar_parse_header+0x19f>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0029db4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029db7:	05 01 01 00 00       	add    $0x101,%eax
c0029dbc:	83 ec 04             	sub    $0x4,%esp
c0029dbf:	6a 06                	push   $0x6
c0029dc1:	68 e1 15 03 c0       	push   $0xc00315e1
c0029dc6:	50                   	push   %eax
c0029dc7:	e8 d7 f0 ff ff       	call   c0028ea3 <memcmp>
c0029dcc:	83 c4 10             	add    $0x10,%esp
c0029dcf:	85 c0                	test   %eax,%eax
c0029dd1:	74 0a                	je     c0029ddd <ustar_parse_header+0x6e>
    return "not a ustar archive";
c0029dd3:	b8 ec 15 03 c0       	mov    $0xc00315ec,%eax
c0029dd8:	e9 31 01 00 00       	jmp    c0029f0e <ustar_parse_header+0x19f>
  else if (h->version[0] != '0' || h->version[1] != '0')
c0029ddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029de0:	8a 80 07 01 00 00    	mov    0x107(%eax),%al
c0029de6:	3c 30                	cmp    $0x30,%al
c0029de8:	75 0d                	jne    c0029df7 <ustar_parse_header+0x88>
c0029dea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ded:	8a 80 08 01 00 00    	mov    0x108(%eax),%al
c0029df3:	3c 30                	cmp    $0x30,%al
c0029df5:	74 0a                	je     c0029e01 <ustar_parse_header+0x92>
    return "invalid ustar version";
c0029df7:	b8 00 16 03 c0       	mov    $0xc0031600,%eax
c0029dfc:	e9 0d 01 00 00       	jmp    c0029f0e <ustar_parse_header+0x19f>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029e01:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029e04:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029e0a:	83 ec 04             	sub    $0x4,%esp
c0029e0d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0029e10:	50                   	push   %eax
c0029e11:	6a 08                	push   $0x8
c0029e13:	52                   	push   %edx
c0029e14:	e8 ac fe ff ff       	call   c0029cc5 <parse_octal_field>
c0029e19:	83 c4 10             	add    $0x10,%esp
c0029e1c:	83 f0 01             	xor    $0x1,%eax
c0029e1f:	84 c0                	test   %al,%al
c0029e21:	74 0a                	je     c0029e2d <ustar_parse_header+0xbe>
    return "corrupt chksum field";
c0029e23:	b8 16 16 03 c0       	mov    $0xc0031616,%eax
c0029e28:	e9 e1 00 00 00       	jmp    c0029f0e <ustar_parse_header+0x19f>
  else if (chksum != calculate_chksum (h))
c0029e2d:	83 ec 0c             	sub    $0xc,%esp
c0029e30:	ff 75 f4             	pushl  -0xc(%ebp)
c0029e33:	e8 b4 fb ff ff       	call   c00299ec <calculate_chksum>
c0029e38:	83 c4 10             	add    $0x10,%esp
c0029e3b:	89 c2                	mov    %eax,%edx
c0029e3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029e40:	39 c2                	cmp    %eax,%edx
c0029e42:	74 0a                	je     c0029e4e <ustar_parse_header+0xdf>
    return "checksum mismatch";
c0029e44:	b8 2b 16 03 c0       	mov    $0xc003162b,%eax
c0029e49:	e9 c0 00 00 00       	jmp    c0029f0e <ustar_parse_header+0x19f>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029e51:	8a 40 63             	mov    0x63(%eax),%al
c0029e54:	84 c0                	test   %al,%al
c0029e56:	75 0d                	jne    c0029e65 <ustar_parse_header+0xf6>
c0029e58:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029e5b:	8a 80 59 01 00 00    	mov    0x159(%eax),%al
c0029e61:	84 c0                	test   %al,%al
c0029e63:	74 0a                	je     c0029e6f <ustar_parse_header+0x100>
    return "file name too long";
c0029e65:	b8 3d 16 03 c0       	mov    $0xc003163d,%eax
c0029e6a:	e9 9f 00 00 00       	jmp    c0029f0e <ustar_parse_header+0x19f>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029e6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029e72:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029e78:	3c 30                	cmp    $0x30,%al
c0029e7a:	74 14                	je     c0029e90 <ustar_parse_header+0x121>
c0029e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029e7f:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029e85:	3c 35                	cmp    $0x35,%al
c0029e87:	74 07                	je     c0029e90 <ustar_parse_header+0x121>
    return "unimplemented file type";
c0029e89:	b8 50 16 03 c0       	mov    $0xc0031650,%eax
c0029e8e:	eb 7e                	jmp    c0029f0e <ustar_parse_header+0x19f>
  if (h->typeflag == USTAR_REGULAR)
c0029e90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029e93:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029e99:	3c 30                	cmp    $0x30,%al
c0029e9b:	75 34                	jne    c0029ed1 <ustar_parse_header+0x162>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0029e9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ea0:	8d 50 7c             	lea    0x7c(%eax),%edx
c0029ea3:	83 ec 04             	sub    $0x4,%esp
c0029ea6:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0029ea9:	50                   	push   %eax
c0029eaa:	6a 0c                	push   $0xc
c0029eac:	52                   	push   %edx
c0029ead:	e8 13 fe ff ff       	call   c0029cc5 <parse_octal_field>
c0029eb2:	83 c4 10             	add    $0x10,%esp
c0029eb5:	83 f0 01             	xor    $0x1,%eax
c0029eb8:	84 c0                	test   %al,%al
c0029eba:	74 07                	je     c0029ec3 <ustar_parse_header+0x154>
        return "corrupt file size field";
c0029ebc:	b8 68 16 03 c0       	mov    $0xc0031668,%eax
c0029ec1:	eb 4b                	jmp    c0029f0e <ustar_parse_header+0x19f>
      else if (size_ul > INT_MAX)
c0029ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029ec6:	85 c0                	test   %eax,%eax
c0029ec8:	79 0e                	jns    c0029ed8 <ustar_parse_header+0x169>
        return "file too large";
c0029eca:	b8 80 16 03 c0       	mov    $0xc0031680,%eax
c0029ecf:	eb 3d                	jmp    c0029f0e <ustar_parse_header+0x19f>
    }
  else
    size_ul = 0;
c0029ed1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0029ed8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029edb:	83 ec 0c             	sub    $0xc,%esp
c0029ede:	50                   	push   %eax
c0029edf:	e8 89 fb ff ff       	call   c0029a6d <strip_antisocial_prefixes>
c0029ee4:	83 c4 10             	add    $0x10,%esp
c0029ee7:	89 c2                	mov    %eax,%edx
c0029ee9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029eec:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c0029eee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ef1:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029ef7:	0f be d0             	movsbl %al,%edx
c0029efa:	8b 45 10             	mov    0x10(%ebp),%eax
c0029efd:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c0029eff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029f02:	89 c2                	mov    %eax,%edx
c0029f04:	8b 45 14             	mov    0x14(%ebp),%eax
c0029f07:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029f09:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029f0e:	c9                   	leave  
c0029f0f:	c3                   	ret    

c0029f10 <convert_to_fixed_point>:
#include "lib/fixed_point.h"
#include "lib/stdint.h"

int convert_to_fixed_point(int n) 
{
c0029f10:	55                   	push   %ebp
c0029f11:	89 e5                	mov    %esp,%ebp
    return n * CONST_F;
c0029f13:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f16:	c1 e0 10             	shl    $0x10,%eax
}
c0029f19:	5d                   	pop    %ebp
c0029f1a:	c3                   	ret    

c0029f1b <convert_to_int_tozero>:

int convert_to_int_tozero(int f)
{
c0029f1b:	55                   	push   %ebp
c0029f1c:	89 e5                	mov    %esp,%ebp
    return f / CONST_F;
c0029f1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f21:	85 c0                	test   %eax,%eax
c0029f23:	79 05                	jns    c0029f2a <convert_to_int_tozero+0xf>
c0029f25:	05 ff ff 00 00       	add    $0xffff,%eax
c0029f2a:	c1 f8 10             	sar    $0x10,%eax
}
c0029f2d:	5d                   	pop    %ebp
c0029f2e:	c3                   	ret    

c0029f2f <convert_to_int_round>:

int convert_to_int_round(int f) 
{
c0029f2f:	55                   	push   %ebp
c0029f30:	89 e5                	mov    %esp,%ebp
    if (f >= 0) 
c0029f32:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f36:	78 16                	js     c0029f4e <convert_to_int_round+0x1f>
        return (f + CONST_F / 2) / CONST_F;
c0029f38:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f3b:	05 00 80 00 00       	add    $0x8000,%eax
c0029f40:	85 c0                	test   %eax,%eax
c0029f42:	79 05                	jns    c0029f49 <convert_to_int_round+0x1a>
c0029f44:	05 ff ff 00 00       	add    $0xffff,%eax
c0029f49:	c1 f8 10             	sar    $0x10,%eax
c0029f4c:	eb 14                	jmp    c0029f62 <convert_to_int_round+0x33>
    else
        return (f - CONST_F / 2) / CONST_F;
c0029f4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f51:	2d 00 80 00 00       	sub    $0x8000,%eax
c0029f56:	85 c0                	test   %eax,%eax
c0029f58:	79 05                	jns    c0029f5f <convert_to_int_round+0x30>
c0029f5a:	05 ff ff 00 00       	add    $0xffff,%eax
c0029f5f:	c1 f8 10             	sar    $0x10,%eax
}
c0029f62:	5d                   	pop    %ebp
c0029f63:	c3                   	ret    

c0029f64 <ff_add>:

int ff_add(int f1, int f2)
{
c0029f64:	55                   	push   %ebp
c0029f65:	89 e5                	mov    %esp,%ebp
    return f1 + f2;
c0029f67:	8b 55 08             	mov    0x8(%ebp),%edx
c0029f6a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029f6d:	01 d0                	add    %edx,%eax
}
c0029f6f:	5d                   	pop    %ebp
c0029f70:	c3                   	ret    

c0029f71 <ff_sub>:

int ff_sub(int f1, int f2)
{
c0029f71:	55                   	push   %ebp
c0029f72:	89 e5                	mov    %esp,%ebp
    return f1 - f2;
c0029f74:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f77:	2b 45 0c             	sub    0xc(%ebp),%eax
}
c0029f7a:	5d                   	pop    %ebp
c0029f7b:	c3                   	ret    

c0029f7c <ff_add_with_int>:

int ff_add_with_int(int f, int n)
{
c0029f7c:	55                   	push   %ebp
c0029f7d:	89 e5                	mov    %esp,%ebp
    return f + n * CONST_F;
c0029f7f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029f82:	c1 e0 10             	shl    $0x10,%eax
c0029f85:	89 c2                	mov    %eax,%edx
c0029f87:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f8a:	01 d0                	add    %edx,%eax
}
c0029f8c:	5d                   	pop    %ebp
c0029f8d:	c3                   	ret    

c0029f8e <ff_sub_with_int>:

int ff_sub_with_int(int f, int n)
{
c0029f8e:	55                   	push   %ebp
c0029f8f:	89 e5                	mov    %esp,%ebp
    return f - n * CONST_F;
c0029f91:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029f94:	c1 e0 10             	shl    $0x10,%eax
c0029f97:	89 c2                	mov    %eax,%edx
c0029f99:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f9c:	29 d0                	sub    %edx,%eax
}
c0029f9e:	5d                   	pop    %ebp
c0029f9f:	c3                   	ret    

c0029fa0 <ff_mul>:

int ff_mul(int f1, int f2)
{
c0029fa0:	55                   	push   %ebp
c0029fa1:	89 e5                	mov    %esp,%ebp
c0029fa3:	57                   	push   %edi
c0029fa4:	56                   	push   %esi
c0029fa5:	53                   	push   %ebx
    return ((int64_t) f1) * f2 / CONST_F;
c0029fa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fa9:	89 c1                	mov    %eax,%ecx
c0029fab:	89 c3                	mov    %eax,%ebx
c0029fad:	c1 fb 1f             	sar    $0x1f,%ebx
c0029fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029fb3:	99                   	cltd   
c0029fb4:	89 df                	mov    %ebx,%edi
c0029fb6:	0f af f8             	imul   %eax,%edi
c0029fb9:	89 d6                	mov    %edx,%esi
c0029fbb:	0f af f1             	imul   %ecx,%esi
c0029fbe:	01 fe                	add    %edi,%esi
c0029fc0:	f7 e1                	mul    %ecx
c0029fc2:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
c0029fc5:	89 ca                	mov    %ecx,%edx
c0029fc7:	85 d2                	test   %edx,%edx
c0029fc9:	79 08                	jns    c0029fd3 <ff_mul+0x33>
c0029fcb:	05 ff ff 00 00       	add    $0xffff,%eax
c0029fd0:	83 d2 00             	adc    $0x0,%edx
c0029fd3:	0f ac d0 10          	shrd   $0x10,%edx,%eax
c0029fd7:	c1 fa 10             	sar    $0x10,%edx
} 
c0029fda:	5b                   	pop    %ebx
c0029fdb:	5e                   	pop    %esi
c0029fdc:	5f                   	pop    %edi
c0029fdd:	5d                   	pop    %ebp
c0029fde:	c3                   	ret    

c0029fdf <ff_mul_with_int>:

int ff_mul_with_int(int f, int n)
{
c0029fdf:	55                   	push   %ebp
c0029fe0:	89 e5                	mov    %esp,%ebp
    return f * n;
c0029fe2:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fe5:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
c0029fe9:	5d                   	pop    %ebp
c0029fea:	c3                   	ret    

c0029feb <ff_div>:

int ff_div(int f1, int f2)
{
c0029feb:	55                   	push   %ebp
c0029fec:	89 e5                	mov    %esp,%ebp
c0029fee:	53                   	push   %ebx
c0029fef:	83 ec 04             	sub    $0x4,%esp
    return ((int64_t) f1) * CONST_F / f2;
c0029ff2:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ff5:	99                   	cltd   
c0029ff6:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0029ffa:	c1 e0 10             	shl    $0x10,%eax
c0029ffd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002a000:	89 cb                	mov    %ecx,%ebx
c002a002:	c1 fb 1f             	sar    $0x1f,%ebx
c002a005:	53                   	push   %ebx
c002a006:	51                   	push   %ecx
c002a007:	52                   	push   %edx
c002a008:	50                   	push   %eax
c002a009:	e8 08 f9 ff ff       	call   c0029916 <__divdi3>
c002a00e:	83 c4 10             	add    $0x10,%esp
}
c002a011:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a014:	c9                   	leave  
c002a015:	c3                   	ret    

c002a016 <ff_div_with_int>:

int ff_div_with_int(int f, int n)
{
c002a016:	55                   	push   %ebp
c002a017:	89 e5                	mov    %esp,%ebp
    return f / n;
c002a019:	8b 45 08             	mov    0x8(%ebp),%eax
c002a01c:	99                   	cltd   
c002a01d:	f7 7d 0c             	idivl  0xc(%ebp)
}
c002a020:	5d                   	pop    %ebp
c002a021:	c3                   	ret    

c002a022 <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c002a022:	55                   	push   %ebp
c002a023:	89 e5                	mov    %esp,%ebp
c002a025:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c002a028:	e8 50 79 ff ff       	call   c002197d <intr_disable>
  console_panic ();
c002a02d:	e8 78 20 00 00       	call   c002c0aa <console_panic>

  level++;
c002a032:	a1 44 a0 03 c0       	mov    0xc003a044,%eax
c002a037:	40                   	inc    %eax
c002a038:	a3 44 a0 03 c0       	mov    %eax,0xc003a044
  if (level == 1) 
c002a03d:	a1 44 a0 03 c0       	mov    0xc003a044,%eax
c002a042:	83 f8 01             	cmp    $0x1,%eax
c002a045:	75 42                	jne    c002a089 <debug_panic+0x67>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c002a047:	ff 75 10             	pushl  0x10(%ebp)
c002a04a:	ff 75 0c             	pushl  0xc(%ebp)
c002a04d:	ff 75 08             	pushl  0x8(%ebp)
c002a050:	68 a4 16 03 c0       	push   $0xc00316a4
c002a055:	e8 f7 da ff ff       	call   c0027b51 <printf>
c002a05a:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c002a05d:	8d 45 18             	lea    0x18(%ebp),%eax
c002a060:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c002a063:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a066:	83 ec 08             	sub    $0x8,%esp
c002a069:	50                   	push   %eax
c002a06a:	ff 75 14             	pushl  0x14(%ebp)
c002a06d:	e8 3e 21 00 00       	call   c002c1b0 <vprintf>
c002a072:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c002a075:	83 ec 0c             	sub    $0xc,%esp
c002a078:	6a 0a                	push   $0xa
c002a07a:	e8 e9 21 00 00       	call   c002c268 <putchar>
c002a07f:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c002a082:	e8 bd d7 ff ff       	call   c0027844 <debug_backtrace>
c002a087:	eb 20                	jmp    c002a0a9 <debug_panic+0x87>
    }
  else if (level == 2)
c002a089:	a1 44 a0 03 c0       	mov    0xc003a044,%eax
c002a08e:	83 f8 02             	cmp    $0x2,%eax
c002a091:	75 16                	jne    c002a0a9 <debug_panic+0x87>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c002a093:	ff 75 10             	pushl  0x10(%ebp)
c002a096:	ff 75 0c             	pushl  0xc(%ebp)
c002a099:	ff 75 08             	pushl  0x8(%ebp)
c002a09c:	68 c4 16 03 c0       	push   $0xc00316c4
c002a0a1:	e8 ab da ff ff       	call   c0027b51 <printf>
c002a0a6:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c002a0a9:	e8 74 b3 ff ff       	call   c0025422 <serial_flush>
  shutdown ();
c002a0ae:	e8 00 d5 ff ff       	call   c00275b3 <shutdown>
  for (;;);
c002a0b3:	eb fe                	jmp    c002a0b3 <debug_panic+0x91>

c002a0b5 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c002a0b5:	55                   	push   %ebp
c002a0b6:	89 e5                	mov    %esp,%ebp
c002a0b8:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c002a0bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002a0c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c002a0c9:	c7 45 ec ee 16 03 c0 	movl   $0xc00316ee,-0x14(%ebp)

  switch (t->status) {
c002a0d0:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0d3:	8b 40 04             	mov    0x4(%eax),%eax
c002a0d6:	83 f8 01             	cmp    $0x1,%eax
c002a0d9:	74 15                	je     c002a0f0 <print_stacktrace+0x3b>
c002a0db:	83 f8 01             	cmp    $0x1,%eax
c002a0de:	72 07                	jb     c002a0e7 <print_stacktrace+0x32>
c002a0e0:	83 f8 02             	cmp    $0x2,%eax
c002a0e3:	74 14                	je     c002a0f9 <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c002a0e5:	eb 1a                	jmp    c002a101 <print_stacktrace+0x4c>
      status = "RUNNING";
c002a0e7:	c7 45 ec f6 16 03 c0 	movl   $0xc00316f6,-0x14(%ebp)
      break;
c002a0ee:	eb 11                	jmp    c002a101 <print_stacktrace+0x4c>
      status = "READY";
c002a0f0:	c7 45 ec fe 16 03 c0 	movl   $0xc00316fe,-0x14(%ebp)
      break;
c002a0f7:	eb 08                	jmp    c002a101 <print_stacktrace+0x4c>
      status = "BLOCKED";
c002a0f9:	c7 45 ec 04 17 03 c0 	movl   $0xc0031704,-0x14(%ebp)
      break;
c002a100:	90                   	nop
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c002a101:	8b 45 08             	mov    0x8(%ebp),%eax
c002a104:	83 c0 08             	add    $0x8,%eax
c002a107:	83 ec 04             	sub    $0x4,%esp
c002a10a:	ff 75 ec             	pushl  -0x14(%ebp)
c002a10d:	50                   	push   %eax
c002a10e:	68 0c 17 03 c0       	push   $0xc003170c
c002a113:	e8 39 da ff ff       	call   c0027b51 <printf>
c002a118:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c002a11b:	e8 6b 6b ff ff       	call   c0020c8b <thread_current>
c002a120:	3b 45 08             	cmp    0x8(%ebp),%eax
c002a123:	75 0e                	jne    c002a133 <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c002a125:	8b 45 00             	mov    0x0(%ebp),%eax
c002a128:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c002a12b:	8b 45 04             	mov    0x4(%ebp),%eax
c002a12e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a131:	eb 4d                	jmp    c002a180 <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c002a133:	8b 45 08             	mov    0x8(%ebp),%eax
c002a136:	8b 40 18             	mov    0x18(%eax),%eax
c002a139:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c002a13c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a13f:	8b 40 18             	mov    0x18(%eax),%eax
c002a142:	8b 55 08             	mov    0x8(%ebp),%edx
c002a145:	81 c2 00 10 00 00    	add    $0x1000,%edx
c002a14b:	39 d0                	cmp    %edx,%eax
c002a14d:	74 0d                	je     c002a15c <print_stacktrace+0xa7>
c002a14f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a152:	8b 40 10             	mov    0x10(%eax),%eax
c002a155:	3d de 18 02 c0       	cmp    $0xc00218de,%eax
c002a15a:	75 12                	jne    c002a16e <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c002a15c:	83 ec 0c             	sub    $0xc,%esp
c002a15f:	68 33 17 03 c0       	push   $0xc0031733
c002a164:	e8 7a 20 00 00       	call   c002c1e3 <puts>
c002a169:	83 c4 10             	add    $0x10,%esp
          return;
c002a16c:	eb 6b                	jmp    c002a1d9 <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c002a16e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a171:	8b 40 08             	mov    0x8(%eax),%eax
c002a174:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c002a177:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a17a:	8b 40 10             	mov    0x10(%eax),%eax
c002a17d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c002a180:	83 ec 08             	sub    $0x8,%esp
c002a183:	ff 75 f4             	pushl  -0xc(%ebp)
c002a186:	68 50 17 03 c0       	push   $0xc0031750
c002a18b:	e8 c1 d9 ff ff       	call   c0027b51 <printf>
c002a190:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002a193:	eb 21                	jmp    c002a1b6 <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c002a195:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a198:	83 c0 04             	add    $0x4,%eax
c002a19b:	8b 00                	mov    (%eax),%eax
c002a19d:	83 ec 08             	sub    $0x8,%esp
c002a1a0:	50                   	push   %eax
c002a1a1:	68 50 17 03 c0       	push   $0xc0031750
c002a1a6:	e8 a6 d9 ff ff       	call   c0027b51 <printf>
c002a1ab:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002a1ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a1b1:	8b 00                	mov    (%eax),%eax
c002a1b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a1b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a1b9:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002a1be:	76 09                	jbe    c002a1c9 <print_stacktrace+0x114>
c002a1c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a1c3:	8b 00                	mov    (%eax),%eax
c002a1c5:	85 c0                	test   %eax,%eax
c002a1c7:	75 cc                	jne    c002a195 <print_stacktrace+0xe0>
  printf (".\n");
c002a1c9:	83 ec 0c             	sub    $0xc,%esp
c002a1cc:	68 54 17 03 c0       	push   $0xc0031754
c002a1d1:	e8 0d 20 00 00       	call   c002c1e3 <puts>
c002a1d6:	83 c4 10             	add    $0x10,%esp
}
c002a1d9:	c9                   	leave  
c002a1da:	c3                   	ret    

c002a1db <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c002a1db:	55                   	push   %ebp
c002a1dc:	89 e5                	mov    %esp,%ebp
c002a1de:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c002a1e1:	e8 97 77 ff ff       	call   c002197d <intr_disable>
c002a1e6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c002a1e9:	83 ec 08             	sub    $0x8,%esp
c002a1ec:	6a 00                	push   $0x0
c002a1ee:	68 b5 a0 02 c0       	push   $0xc002a0b5
c002a1f3:	e8 11 6c ff ff       	call   c0020e09 <thread_foreach>
c002a1f8:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c002a1fb:	83 ec 0c             	sub    $0xc,%esp
c002a1fe:	ff 75 f4             	pushl  -0xc(%ebp)
c002a201:	e8 1f 77 ff ff       	call   c0021925 <intr_set_level>
c002a206:	83 c4 10             	add    $0x10,%esp
}
c002a209:	90                   	nop
c002a20a:	c9                   	leave  
c002a20b:	c3                   	ret    

c002a20c <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c002a20c:	55                   	push   %ebp
c002a20d:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002a20f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a213:	74 1a                	je     c002a22f <is_head+0x23>
c002a215:	8b 45 08             	mov    0x8(%ebp),%eax
c002a218:	8b 00                	mov    (%eax),%eax
c002a21a:	85 c0                	test   %eax,%eax
c002a21c:	75 11                	jne    c002a22f <is_head+0x23>
c002a21e:	8b 45 08             	mov    0x8(%ebp),%eax
c002a221:	8b 40 04             	mov    0x4(%eax),%eax
c002a224:	85 c0                	test   %eax,%eax
c002a226:	74 07                	je     c002a22f <is_head+0x23>
c002a228:	b8 01 00 00 00       	mov    $0x1,%eax
c002a22d:	eb 05                	jmp    c002a234 <is_head+0x28>
c002a22f:	b8 00 00 00 00       	mov    $0x0,%eax
c002a234:	83 e0 01             	and    $0x1,%eax
}
c002a237:	5d                   	pop    %ebp
c002a238:	c3                   	ret    

c002a239 <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c002a239:	55                   	push   %ebp
c002a23a:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002a23c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a240:	74 1a                	je     c002a25c <is_interior+0x23>
c002a242:	8b 45 08             	mov    0x8(%ebp),%eax
c002a245:	8b 00                	mov    (%eax),%eax
c002a247:	85 c0                	test   %eax,%eax
c002a249:	74 11                	je     c002a25c <is_interior+0x23>
c002a24b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a24e:	8b 40 04             	mov    0x4(%eax),%eax
c002a251:	85 c0                	test   %eax,%eax
c002a253:	74 07                	je     c002a25c <is_interior+0x23>
c002a255:	b8 01 00 00 00       	mov    $0x1,%eax
c002a25a:	eb 05                	jmp    c002a261 <is_interior+0x28>
c002a25c:	b8 00 00 00 00       	mov    $0x0,%eax
c002a261:	83 e0 01             	and    $0x1,%eax
}
c002a264:	5d                   	pop    %ebp
c002a265:	c3                   	ret    

c002a266 <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c002a266:	55                   	push   %ebp
c002a267:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002a269:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a26d:	74 1a                	je     c002a289 <is_tail+0x23>
c002a26f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a272:	8b 00                	mov    (%eax),%eax
c002a274:	85 c0                	test   %eax,%eax
c002a276:	74 11                	je     c002a289 <is_tail+0x23>
c002a278:	8b 45 08             	mov    0x8(%ebp),%eax
c002a27b:	8b 40 04             	mov    0x4(%eax),%eax
c002a27e:	85 c0                	test   %eax,%eax
c002a280:	75 07                	jne    c002a289 <is_tail+0x23>
c002a282:	b8 01 00 00 00       	mov    $0x1,%eax
c002a287:	eb 05                	jmp    c002a28e <is_tail+0x28>
c002a289:	b8 00 00 00 00       	mov    $0x0,%eax
c002a28e:	83 e0 01             	and    $0x1,%eax
}
c002a291:	5d                   	pop    %ebp
c002a292:	c3                   	ret    

c002a293 <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c002a293:	55                   	push   %ebp
c002a294:	89 e5                	mov    %esp,%ebp
c002a296:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a299:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a29d:	75 1e                	jne    c002a2bd <list_init+0x2a>
c002a29f:	83 ec 0c             	sub    $0xc,%esp
c002a2a2:	68 58 17 03 c0       	push   $0xc0031758
c002a2a7:	68 65 17 03 c0       	push   $0xc0031765
c002a2ac:	68 30 19 03 c0       	push   $0xc0031930
c002a2b1:	6a 3f                	push   $0x3f
c002a2b3:	68 7c 17 03 c0       	push   $0xc003177c
c002a2b8:	e8 65 fd ff ff       	call   c002a022 <debug_panic>
  list->head.prev = NULL;
c002a2bd:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c002a2c6:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2c9:	8d 50 08             	lea    0x8(%eax),%edx
c002a2cc:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2cf:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c002a2d2:	8b 55 08             	mov    0x8(%ebp),%edx
c002a2d5:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2d8:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c002a2db:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2de:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c002a2e5:	90                   	nop
c002a2e6:	c9                   	leave  
c002a2e7:	c3                   	ret    

c002a2e8 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c002a2e8:	55                   	push   %ebp
c002a2e9:	89 e5                	mov    %esp,%ebp
c002a2eb:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a2ee:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a2f2:	75 1e                	jne    c002a312 <list_begin+0x2a>
c002a2f4:	83 ec 0c             	sub    $0xc,%esp
c002a2f7:	68 58 17 03 c0       	push   $0xc0031758
c002a2fc:	68 65 17 03 c0       	push   $0xc0031765
c002a301:	68 3c 19 03 c0       	push   $0xc003193c
c002a306:	6a 4a                	push   $0x4a
c002a308:	68 7c 17 03 c0       	push   $0xc003177c
c002a30d:	e8 10 fd ff ff       	call   c002a022 <debug_panic>
  return list->head.next;
c002a312:	8b 45 08             	mov    0x8(%ebp),%eax
c002a315:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a318:	c9                   	leave  
c002a319:	c3                   	ret    

c002a31a <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c002a31a:	55                   	push   %ebp
c002a31b:	89 e5                	mov    %esp,%ebp
c002a31d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c002a320:	ff 75 08             	pushl  0x8(%ebp)
c002a323:	e8 e4 fe ff ff       	call   c002a20c <is_head>
c002a328:	83 c4 04             	add    $0x4,%esp
c002a32b:	84 c0                	test   %al,%al
c002a32d:	75 2d                	jne    c002a35c <list_next+0x42>
c002a32f:	ff 75 08             	pushl  0x8(%ebp)
c002a332:	e8 02 ff ff ff       	call   c002a239 <is_interior>
c002a337:	83 c4 04             	add    $0x4,%esp
c002a33a:	84 c0                	test   %al,%al
c002a33c:	75 1e                	jne    c002a35c <list_next+0x42>
c002a33e:	83 ec 0c             	sub    $0xc,%esp
c002a341:	68 94 17 03 c0       	push   $0xc0031794
c002a346:	68 65 17 03 c0       	push   $0xc0031765
c002a34b:	68 48 19 03 c0       	push   $0xc0031948
c002a350:	6a 54                	push   $0x54
c002a352:	68 7c 17 03 c0       	push   $0xc003177c
c002a357:	e8 c6 fc ff ff       	call   c002a022 <debug_panic>
  return elem->next;
c002a35c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a35f:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a362:	c9                   	leave  
c002a363:	c3                   	ret    

c002a364 <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c002a364:	55                   	push   %ebp
c002a365:	89 e5                	mov    %esp,%ebp
c002a367:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a36a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a36e:	75 1e                	jne    c002a38e <list_end+0x2a>
c002a370:	83 ec 0c             	sub    $0xc,%esp
c002a373:	68 58 17 03 c0       	push   $0xc0031758
c002a378:	68 65 17 03 c0       	push   $0xc0031765
c002a37d:	68 54 19 03 c0       	push   $0xc0031954
c002a382:	6a 60                	push   $0x60
c002a384:	68 7c 17 03 c0       	push   $0xc003177c
c002a389:	e8 94 fc ff ff       	call   c002a022 <debug_panic>
  return &list->tail;
c002a38e:	8b 45 08             	mov    0x8(%ebp),%eax
c002a391:	83 c0 08             	add    $0x8,%eax
}
c002a394:	c9                   	leave  
c002a395:	c3                   	ret    

c002a396 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c002a396:	55                   	push   %ebp
c002a397:	89 e5                	mov    %esp,%ebp
c002a399:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a39c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a3a0:	75 1e                	jne    c002a3c0 <list_rbegin+0x2a>
c002a3a2:	83 ec 0c             	sub    $0xc,%esp
c002a3a5:	68 58 17 03 c0       	push   $0xc0031758
c002a3aa:	68 65 17 03 c0       	push   $0xc0031765
c002a3af:	68 60 19 03 c0       	push   $0xc0031960
c002a3b4:	6a 69                	push   $0x69
c002a3b6:	68 7c 17 03 c0       	push   $0xc003177c
c002a3bb:	e8 62 fc ff ff       	call   c002a022 <debug_panic>
  return list->tail.prev;
c002a3c0:	8b 45 08             	mov    0x8(%ebp),%eax
c002a3c3:	8b 40 08             	mov    0x8(%eax),%eax
}
c002a3c6:	c9                   	leave  
c002a3c7:	c3                   	ret    

c002a3c8 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c002a3c8:	55                   	push   %ebp
c002a3c9:	89 e5                	mov    %esp,%ebp
c002a3cb:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c002a3ce:	ff 75 08             	pushl  0x8(%ebp)
c002a3d1:	e8 63 fe ff ff       	call   c002a239 <is_interior>
c002a3d6:	83 c4 04             	add    $0x4,%esp
c002a3d9:	84 c0                	test   %al,%al
c002a3db:	75 2d                	jne    c002a40a <list_prev+0x42>
c002a3dd:	ff 75 08             	pushl  0x8(%ebp)
c002a3e0:	e8 81 fe ff ff       	call   c002a266 <is_tail>
c002a3e5:	83 c4 04             	add    $0x4,%esp
c002a3e8:	84 c0                	test   %al,%al
c002a3ea:	75 1e                	jne    c002a40a <list_prev+0x42>
c002a3ec:	83 ec 0c             	sub    $0xc,%esp
c002a3ef:	68 bc 17 03 c0       	push   $0xc00317bc
c002a3f4:	68 65 17 03 c0       	push   $0xc0031765
c002a3f9:	68 6c 19 03 c0       	push   $0xc003196c
c002a3fe:	6a 73                	push   $0x73
c002a400:	68 7c 17 03 c0       	push   $0xc003177c
c002a405:	e8 18 fc ff ff       	call   c002a022 <debug_panic>
  return elem->prev;
c002a40a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a40d:	8b 00                	mov    (%eax),%eax
}
c002a40f:	c9                   	leave  
c002a410:	c3                   	ret    

c002a411 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c002a411:	55                   	push   %ebp
c002a412:	89 e5                	mov    %esp,%ebp
c002a414:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a417:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a41b:	75 21                	jne    c002a43e <list_rend+0x2d>
c002a41d:	83 ec 0c             	sub    $0xc,%esp
c002a420:	68 58 17 03 c0       	push   $0xc0031758
c002a425:	68 65 17 03 c0       	push   $0xc0031765
c002a42a:	68 78 19 03 c0       	push   $0xc0031978
c002a42f:	68 87 00 00 00       	push   $0x87
c002a434:	68 7c 17 03 c0       	push   $0xc003177c
c002a439:	e8 e4 fb ff ff       	call   c002a022 <debug_panic>
  return &list->head;
c002a43e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a441:	c9                   	leave  
c002a442:	c3                   	ret    

c002a443 <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c002a443:	55                   	push   %ebp
c002a444:	89 e5                	mov    %esp,%ebp
c002a446:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a449:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a44d:	75 21                	jne    c002a470 <list_head+0x2d>
c002a44f:	83 ec 0c             	sub    $0xc,%esp
c002a452:	68 58 17 03 c0       	push   $0xc0031758
c002a457:	68 65 17 03 c0       	push   $0xc0031765
c002a45c:	68 84 19 03 c0       	push   $0xc0031984
c002a461:	68 99 00 00 00       	push   $0x99
c002a466:	68 7c 17 03 c0       	push   $0xc003177c
c002a46b:	e8 b2 fb ff ff       	call   c002a022 <debug_panic>
  return &list->head;
c002a470:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a473:	c9                   	leave  
c002a474:	c3                   	ret    

c002a475 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c002a475:	55                   	push   %ebp
c002a476:	89 e5                	mov    %esp,%ebp
c002a478:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a47b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a47f:	75 21                	jne    c002a4a2 <list_tail+0x2d>
c002a481:	83 ec 0c             	sub    $0xc,%esp
c002a484:	68 58 17 03 c0       	push   $0xc0031758
c002a489:	68 65 17 03 c0       	push   $0xc0031765
c002a48e:	68 90 19 03 c0       	push   $0xc0031990
c002a493:	68 a1 00 00 00       	push   $0xa1
c002a498:	68 7c 17 03 c0       	push   $0xc003177c
c002a49d:	e8 80 fb ff ff       	call   c002a022 <debug_panic>
  return &list->tail;
c002a4a2:	8b 45 08             	mov    0x8(%ebp),%eax
c002a4a5:	83 c0 08             	add    $0x8,%eax
}
c002a4a8:	c9                   	leave  
c002a4a9:	c3                   	ret    

c002a4aa <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c002a4aa:	55                   	push   %ebp
c002a4ab:	89 e5                	mov    %esp,%ebp
c002a4ad:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c002a4b0:	ff 75 08             	pushl  0x8(%ebp)
c002a4b3:	e8 81 fd ff ff       	call   c002a239 <is_interior>
c002a4b8:	83 c4 04             	add    $0x4,%esp
c002a4bb:	84 c0                	test   %al,%al
c002a4bd:	75 30                	jne    c002a4ef <list_insert+0x45>
c002a4bf:	ff 75 08             	pushl  0x8(%ebp)
c002a4c2:	e8 9f fd ff ff       	call   c002a266 <is_tail>
c002a4c7:	83 c4 04             	add    $0x4,%esp
c002a4ca:	84 c0                	test   %al,%al
c002a4cc:	75 21                	jne    c002a4ef <list_insert+0x45>
c002a4ce:	83 ec 0c             	sub    $0xc,%esp
c002a4d1:	68 e4 17 03 c0       	push   $0xc00317e4
c002a4d6:	68 65 17 03 c0       	push   $0xc0031765
c002a4db:	68 9c 19 03 c0       	push   $0xc003199c
c002a4e0:	68 ab 00 00 00       	push   $0xab
c002a4e5:	68 7c 17 03 c0       	push   $0xc003177c
c002a4ea:	e8 33 fb ff ff       	call   c002a022 <debug_panic>
  ASSERT (elem != NULL);
c002a4ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a4f3:	75 21                	jne    c002a516 <list_insert+0x6c>
c002a4f5:	83 ec 0c             	sub    $0xc,%esp
c002a4f8:	68 0d 18 03 c0       	push   $0xc003180d
c002a4fd:	68 65 17 03 c0       	push   $0xc0031765
c002a502:	68 9c 19 03 c0       	push   $0xc003199c
c002a507:	68 ac 00 00 00       	push   $0xac
c002a50c:	68 7c 17 03 c0       	push   $0xc003177c
c002a511:	e8 0c fb ff ff       	call   c002a022 <debug_panic>

  elem->prev = before->prev;
c002a516:	8b 45 08             	mov    0x8(%ebp),%eax
c002a519:	8b 10                	mov    (%eax),%edx
c002a51b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a51e:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c002a520:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a523:	8b 55 08             	mov    0x8(%ebp),%edx
c002a526:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c002a529:	8b 45 08             	mov    0x8(%ebp),%eax
c002a52c:	8b 00                	mov    (%eax),%eax
c002a52e:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a531:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c002a534:	8b 45 08             	mov    0x8(%ebp),%eax
c002a537:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a53a:	89 10                	mov    %edx,(%eax)
}
c002a53c:	90                   	nop
c002a53d:	c9                   	leave  
c002a53e:	c3                   	ret    

c002a53f <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c002a53f:	55                   	push   %ebp
c002a540:	89 e5                	mov    %esp,%ebp
c002a542:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c002a545:	ff 75 08             	pushl  0x8(%ebp)
c002a548:	e8 ec fc ff ff       	call   c002a239 <is_interior>
c002a54d:	83 c4 04             	add    $0x4,%esp
c002a550:	84 c0                	test   %al,%al
c002a552:	75 30                	jne    c002a584 <list_splice+0x45>
c002a554:	ff 75 08             	pushl  0x8(%ebp)
c002a557:	e8 0a fd ff ff       	call   c002a266 <is_tail>
c002a55c:	83 c4 04             	add    $0x4,%esp
c002a55f:	84 c0                	test   %al,%al
c002a561:	75 21                	jne    c002a584 <list_splice+0x45>
c002a563:	83 ec 0c             	sub    $0xc,%esp
c002a566:	68 e4 17 03 c0       	push   $0xc00317e4
c002a56b:	68 65 17 03 c0       	push   $0xc0031765
c002a570:	68 a8 19 03 c0       	push   $0xc00319a8
c002a575:	68 bb 00 00 00       	push   $0xbb
c002a57a:	68 7c 17 03 c0       	push   $0xc003177c
c002a57f:	e8 9e fa ff ff       	call   c002a022 <debug_panic>
  if (first == last)
c002a584:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a587:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a58a:	0f 84 ba 00 00 00    	je     c002a64a <list_splice+0x10b>
    return;
  last = list_prev (last);
c002a590:	83 ec 0c             	sub    $0xc,%esp
c002a593:	ff 75 10             	pushl  0x10(%ebp)
c002a596:	e8 2d fe ff ff       	call   c002a3c8 <list_prev>
c002a59b:	83 c4 10             	add    $0x10,%esp
c002a59e:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c002a5a1:	83 ec 0c             	sub    $0xc,%esp
c002a5a4:	ff 75 0c             	pushl  0xc(%ebp)
c002a5a7:	e8 8d fc ff ff       	call   c002a239 <is_interior>
c002a5ac:	83 c4 10             	add    $0x10,%esp
c002a5af:	84 c0                	test   %al,%al
c002a5b1:	75 21                	jne    c002a5d4 <list_splice+0x95>
c002a5b3:	83 ec 0c             	sub    $0xc,%esp
c002a5b6:	68 1a 18 03 c0       	push   $0xc003181a
c002a5bb:	68 65 17 03 c0       	push   $0xc0031765
c002a5c0:	68 a8 19 03 c0       	push   $0xc00319a8
c002a5c5:	68 c0 00 00 00       	push   $0xc0
c002a5ca:	68 7c 17 03 c0       	push   $0xc003177c
c002a5cf:	e8 4e fa ff ff       	call   c002a022 <debug_panic>
  ASSERT (is_interior (last));
c002a5d4:	83 ec 0c             	sub    $0xc,%esp
c002a5d7:	ff 75 10             	pushl  0x10(%ebp)
c002a5da:	e8 5a fc ff ff       	call   c002a239 <is_interior>
c002a5df:	83 c4 10             	add    $0x10,%esp
c002a5e2:	84 c0                	test   %al,%al
c002a5e4:	75 21                	jne    c002a607 <list_splice+0xc8>
c002a5e6:	83 ec 0c             	sub    $0xc,%esp
c002a5e9:	68 2e 18 03 c0       	push   $0xc003182e
c002a5ee:	68 65 17 03 c0       	push   $0xc0031765
c002a5f3:	68 a8 19 03 c0       	push   $0xc00319a8
c002a5f8:	68 c1 00 00 00       	push   $0xc1
c002a5fd:	68 7c 17 03 c0       	push   $0xc003177c
c002a602:	e8 1b fa ff ff       	call   c002a022 <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c002a607:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a60a:	8b 00                	mov    (%eax),%eax
c002a60c:	8b 55 10             	mov    0x10(%ebp),%edx
c002a60f:	8b 52 04             	mov    0x4(%edx),%edx
c002a612:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c002a615:	8b 45 10             	mov    0x10(%ebp),%eax
c002a618:	8b 40 04             	mov    0x4(%eax),%eax
c002a61b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a61e:	8b 12                	mov    (%edx),%edx
c002a620:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c002a622:	8b 45 08             	mov    0x8(%ebp),%eax
c002a625:	8b 10                	mov    (%eax),%edx
c002a627:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a62a:	89 10                	mov    %edx,(%eax)
  last->next = before;
c002a62c:	8b 45 10             	mov    0x10(%ebp),%eax
c002a62f:	8b 55 08             	mov    0x8(%ebp),%edx
c002a632:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c002a635:	8b 45 08             	mov    0x8(%ebp),%eax
c002a638:	8b 00                	mov    (%eax),%eax
c002a63a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a63d:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c002a640:	8b 45 08             	mov    0x8(%ebp),%eax
c002a643:	8b 55 10             	mov    0x10(%ebp),%edx
c002a646:	89 10                	mov    %edx,(%eax)
c002a648:	eb 01                	jmp    c002a64b <list_splice+0x10c>
    return;
c002a64a:	90                   	nop
}
c002a64b:	c9                   	leave  
c002a64c:	c3                   	ret    

c002a64d <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c002a64d:	55                   	push   %ebp
c002a64e:	89 e5                	mov    %esp,%ebp
c002a650:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c002a653:	83 ec 0c             	sub    $0xc,%esp
c002a656:	ff 75 08             	pushl  0x8(%ebp)
c002a659:	e8 8a fc ff ff       	call   c002a2e8 <list_begin>
c002a65e:	83 c4 10             	add    $0x10,%esp
c002a661:	83 ec 08             	sub    $0x8,%esp
c002a664:	ff 75 0c             	pushl  0xc(%ebp)
c002a667:	50                   	push   %eax
c002a668:	e8 3d fe ff ff       	call   c002a4aa <list_insert>
c002a66d:	83 c4 10             	add    $0x10,%esp
}
c002a670:	90                   	nop
c002a671:	c9                   	leave  
c002a672:	c3                   	ret    

c002a673 <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c002a673:	55                   	push   %ebp
c002a674:	89 e5                	mov    %esp,%ebp
c002a676:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c002a679:	83 ec 0c             	sub    $0xc,%esp
c002a67c:	ff 75 08             	pushl  0x8(%ebp)
c002a67f:	e8 e0 fc ff ff       	call   c002a364 <list_end>
c002a684:	83 c4 10             	add    $0x10,%esp
c002a687:	83 ec 08             	sub    $0x8,%esp
c002a68a:	ff 75 0c             	pushl  0xc(%ebp)
c002a68d:	50                   	push   %eax
c002a68e:	e8 17 fe ff ff       	call   c002a4aa <list_insert>
c002a693:	83 c4 10             	add    $0x10,%esp
}
c002a696:	90                   	nop
c002a697:	c9                   	leave  
c002a698:	c3                   	ret    

c002a699 <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c002a699:	55                   	push   %ebp
c002a69a:	89 e5                	mov    %esp,%ebp
c002a69c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c002a69f:	ff 75 08             	pushl  0x8(%ebp)
c002a6a2:	e8 92 fb ff ff       	call   c002a239 <is_interior>
c002a6a7:	83 c4 04             	add    $0x4,%esp
c002a6aa:	84 c0                	test   %al,%al
c002a6ac:	75 21                	jne    c002a6cf <list_remove+0x36>
c002a6ae:	83 ec 0c             	sub    $0xc,%esp
c002a6b1:	68 41 18 03 c0       	push   $0xc0031841
c002a6b6:	68 65 17 03 c0       	push   $0xc0031765
c002a6bb:	68 b4 19 03 c0       	push   $0xc00319b4
c002a6c0:	68 fb 00 00 00       	push   $0xfb
c002a6c5:	68 7c 17 03 c0       	push   $0xc003177c
c002a6ca:	e8 53 f9 ff ff       	call   c002a022 <debug_panic>
  elem->prev->next = elem->next;
c002a6cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6d2:	8b 00                	mov    (%eax),%eax
c002a6d4:	8b 55 08             	mov    0x8(%ebp),%edx
c002a6d7:	8b 52 04             	mov    0x4(%edx),%edx
c002a6da:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c002a6dd:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6e0:	8b 40 04             	mov    0x4(%eax),%eax
c002a6e3:	8b 55 08             	mov    0x8(%ebp),%edx
c002a6e6:	8b 12                	mov    (%edx),%edx
c002a6e8:	89 10                	mov    %edx,(%eax)
  return elem->next;
c002a6ea:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6ed:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a6f0:	c9                   	leave  
c002a6f1:	c3                   	ret    

c002a6f2 <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c002a6f2:	55                   	push   %ebp
c002a6f3:	89 e5                	mov    %esp,%ebp
c002a6f5:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c002a6f8:	83 ec 0c             	sub    $0xc,%esp
c002a6fb:	ff 75 08             	pushl  0x8(%ebp)
c002a6fe:	e8 43 00 00 00       	call   c002a746 <list_front>
c002a703:	83 c4 10             	add    $0x10,%esp
c002a706:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c002a709:	83 ec 0c             	sub    $0xc,%esp
c002a70c:	ff 75 f4             	pushl  -0xc(%ebp)
c002a70f:	e8 85 ff ff ff       	call   c002a699 <list_remove>
c002a714:	83 c4 10             	add    $0x10,%esp
  return front;
c002a717:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a71a:	c9                   	leave  
c002a71b:	c3                   	ret    

c002a71c <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c002a71c:	55                   	push   %ebp
c002a71d:	89 e5                	mov    %esp,%ebp
c002a71f:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c002a722:	83 ec 0c             	sub    $0xc,%esp
c002a725:	ff 75 08             	pushl  0x8(%ebp)
c002a728:	e8 5d 00 00 00       	call   c002a78a <list_back>
c002a72d:	83 c4 10             	add    $0x10,%esp
c002a730:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c002a733:	83 ec 0c             	sub    $0xc,%esp
c002a736:	ff 75 f4             	pushl  -0xc(%ebp)
c002a739:	e8 5b ff ff ff       	call   c002a699 <list_remove>
c002a73e:	83 c4 10             	add    $0x10,%esp
  return back;
c002a741:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a744:	c9                   	leave  
c002a745:	c3                   	ret    

c002a746 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c002a746:	55                   	push   %ebp
c002a747:	89 e5                	mov    %esp,%ebp
c002a749:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c002a74c:	83 ec 0c             	sub    $0xc,%esp
c002a74f:	ff 75 08             	pushl  0x8(%ebp)
c002a752:	e8 c3 00 00 00       	call   c002a81a <list_empty>
c002a757:	83 c4 10             	add    $0x10,%esp
c002a75a:	83 f0 01             	xor    $0x1,%eax
c002a75d:	84 c0                	test   %al,%al
c002a75f:	75 21                	jne    c002a782 <list_front+0x3c>
c002a761:	83 ec 0c             	sub    $0xc,%esp
c002a764:	68 54 18 03 c0       	push   $0xc0031854
c002a769:	68 65 17 03 c0       	push   $0xc0031765
c002a76e:	68 c0 19 03 c0       	push   $0xc00319c0
c002a773:	68 1a 01 00 00       	push   $0x11a
c002a778:	68 7c 17 03 c0       	push   $0xc003177c
c002a77d:	e8 a0 f8 ff ff       	call   c002a022 <debug_panic>
  return list->head.next;
c002a782:	8b 45 08             	mov    0x8(%ebp),%eax
c002a785:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a788:	c9                   	leave  
c002a789:	c3                   	ret    

c002a78a <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c002a78a:	55                   	push   %ebp
c002a78b:	89 e5                	mov    %esp,%ebp
c002a78d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c002a790:	83 ec 0c             	sub    $0xc,%esp
c002a793:	ff 75 08             	pushl  0x8(%ebp)
c002a796:	e8 7f 00 00 00       	call   c002a81a <list_empty>
c002a79b:	83 c4 10             	add    $0x10,%esp
c002a79e:	83 f0 01             	xor    $0x1,%eax
c002a7a1:	84 c0                	test   %al,%al
c002a7a3:	75 21                	jne    c002a7c6 <list_back+0x3c>
c002a7a5:	83 ec 0c             	sub    $0xc,%esp
c002a7a8:	68 54 18 03 c0       	push   $0xc0031854
c002a7ad:	68 65 17 03 c0       	push   $0xc0031765
c002a7b2:	68 cc 19 03 c0       	push   $0xc00319cc
c002a7b7:	68 23 01 00 00       	push   $0x123
c002a7bc:	68 7c 17 03 c0       	push   $0xc003177c
c002a7c1:	e8 5c f8 ff ff       	call   c002a022 <debug_panic>
  return list->tail.prev;
c002a7c6:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7c9:	8b 40 08             	mov    0x8(%eax),%eax
}
c002a7cc:	c9                   	leave  
c002a7cd:	c3                   	ret    

c002a7ce <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c002a7ce:	55                   	push   %ebp
c002a7cf:	89 e5                	mov    %esp,%ebp
c002a7d1:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c002a7d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a7db:	83 ec 0c             	sub    $0xc,%esp
c002a7de:	ff 75 08             	pushl  0x8(%ebp)
c002a7e1:	e8 02 fb ff ff       	call   c002a2e8 <list_begin>
c002a7e6:	83 c4 10             	add    $0x10,%esp
c002a7e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a7ec:	eb 14                	jmp    c002a802 <list_size+0x34>
    cnt++;
c002a7ee:	ff 45 f0             	incl   -0x10(%ebp)
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a7f1:	83 ec 0c             	sub    $0xc,%esp
c002a7f4:	ff 75 f4             	pushl  -0xc(%ebp)
c002a7f7:	e8 1e fb ff ff       	call   c002a31a <list_next>
c002a7fc:	83 c4 10             	add    $0x10,%esp
c002a7ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a802:	83 ec 0c             	sub    $0xc,%esp
c002a805:	ff 75 08             	pushl  0x8(%ebp)
c002a808:	e8 57 fb ff ff       	call   c002a364 <list_end>
c002a80d:	83 c4 10             	add    $0x10,%esp
c002a810:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a813:	75 d9                	jne    c002a7ee <list_size+0x20>
  return cnt;
c002a815:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002a818:	c9                   	leave  
c002a819:	c3                   	ret    

c002a81a <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c002a81a:	55                   	push   %ebp
c002a81b:	89 e5                	mov    %esp,%ebp
c002a81d:	53                   	push   %ebx
c002a81e:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c002a821:	83 ec 0c             	sub    $0xc,%esp
c002a824:	ff 75 08             	pushl  0x8(%ebp)
c002a827:	e8 bc fa ff ff       	call   c002a2e8 <list_begin>
c002a82c:	83 c4 10             	add    $0x10,%esp
c002a82f:	89 c3                	mov    %eax,%ebx
c002a831:	83 ec 0c             	sub    $0xc,%esp
c002a834:	ff 75 08             	pushl  0x8(%ebp)
c002a837:	e8 28 fb ff ff       	call   c002a364 <list_end>
c002a83c:	83 c4 10             	add    $0x10,%esp
c002a83f:	39 c3                	cmp    %eax,%ebx
c002a841:	0f 94 c0             	sete   %al
}
c002a844:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a847:	c9                   	leave  
c002a848:	c3                   	ret    

c002a849 <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c002a849:	55                   	push   %ebp
c002a84a:	89 e5                	mov    %esp,%ebp
c002a84c:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c002a84f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a852:	8b 00                	mov    (%eax),%eax
c002a854:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c002a857:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a85a:	8b 10                	mov    (%eax),%edx
c002a85c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a85f:	89 10                	mov    %edx,(%eax)
  *b = t;
c002a861:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a864:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a867:	89 10                	mov    %edx,(%eax)
}
c002a869:	90                   	nop
c002a86a:	c9                   	leave  
c002a86b:	c3                   	ret    

c002a86c <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c002a86c:	55                   	push   %ebp
c002a86d:	89 e5                	mov    %esp,%ebp
c002a86f:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c002a872:	83 ec 0c             	sub    $0xc,%esp
c002a875:	ff 75 08             	pushl  0x8(%ebp)
c002a878:	e8 9d ff ff ff       	call   c002a81a <list_empty>
c002a87d:	83 c4 10             	add    $0x10,%esp
c002a880:	83 f0 01             	xor    $0x1,%eax
c002a883:	84 c0                	test   %al,%al
c002a885:	74 79                	je     c002a900 <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a887:	83 ec 0c             	sub    $0xc,%esp
c002a88a:	ff 75 08             	pushl  0x8(%ebp)
c002a88d:	e8 56 fa ff ff       	call   c002a2e8 <list_begin>
c002a892:	83 c4 10             	add    $0x10,%esp
c002a895:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a898:	eb 1e                	jmp    c002a8b8 <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c002a89a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a89d:	8d 50 04             	lea    0x4(%eax),%edx
c002a8a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a8a3:	83 ec 08             	sub    $0x8,%esp
c002a8a6:	52                   	push   %edx
c002a8a7:	50                   	push   %eax
c002a8a8:	e8 9c ff ff ff       	call   c002a849 <swap>
c002a8ad:	83 c4 10             	add    $0x10,%esp
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a8b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a8b3:	8b 00                	mov    (%eax),%eax
c002a8b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a8b8:	83 ec 0c             	sub    $0xc,%esp
c002a8bb:	ff 75 08             	pushl  0x8(%ebp)
c002a8be:	e8 a1 fa ff ff       	call   c002a364 <list_end>
c002a8c3:	83 c4 10             	add    $0x10,%esp
c002a8c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a8c9:	75 cf                	jne    c002a89a <list_reverse+0x2e>
      swap (&list->head.next, &list->tail.prev);
c002a8cb:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8ce:	8d 50 08             	lea    0x8(%eax),%edx
c002a8d1:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8d4:	83 c0 04             	add    $0x4,%eax
c002a8d7:	83 ec 08             	sub    $0x8,%esp
c002a8da:	52                   	push   %edx
c002a8db:	50                   	push   %eax
c002a8dc:	e8 68 ff ff ff       	call   c002a849 <swap>
c002a8e1:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c002a8e4:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8e7:	8b 40 08             	mov    0x8(%eax),%eax
c002a8ea:	8d 50 04             	lea    0x4(%eax),%edx
c002a8ed:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8f0:	8b 40 04             	mov    0x4(%eax),%eax
c002a8f3:	83 ec 08             	sub    $0x8,%esp
c002a8f6:	52                   	push   %edx
c002a8f7:	50                   	push   %eax
c002a8f8:	e8 4c ff ff ff       	call   c002a849 <swap>
c002a8fd:	83 c4 10             	add    $0x10,%esp
    }
}
c002a900:	90                   	nop
c002a901:	c9                   	leave  
c002a902:	c3                   	ret    

c002a903 <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c002a903:	55                   	push   %ebp
c002a904:	89 e5                	mov    %esp,%ebp
c002a906:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c002a909:	8b 45 08             	mov    0x8(%ebp),%eax
c002a90c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a90f:	74 43                	je     c002a954 <is_sorted+0x51>
    while ((a = list_next (a)) != b) 
c002a911:	eb 28                	jmp    c002a93b <is_sorted+0x38>
      if (less (a, list_prev (a), aux))
c002a913:	83 ec 0c             	sub    $0xc,%esp
c002a916:	ff 75 08             	pushl  0x8(%ebp)
c002a919:	e8 aa fa ff ff       	call   c002a3c8 <list_prev>
c002a91e:	83 c4 10             	add    $0x10,%esp
c002a921:	83 ec 04             	sub    $0x4,%esp
c002a924:	ff 75 14             	pushl  0x14(%ebp)
c002a927:	50                   	push   %eax
c002a928:	ff 75 08             	pushl  0x8(%ebp)
c002a92b:	8b 45 10             	mov    0x10(%ebp),%eax
c002a92e:	ff d0                	call   *%eax
c002a930:	83 c4 10             	add    $0x10,%esp
c002a933:	84 c0                	test   %al,%al
c002a935:	74 04                	je     c002a93b <is_sorted+0x38>
        return false;
c002a937:	b0 00                	mov    $0x0,%al
c002a939:	eb 1b                	jmp    c002a956 <is_sorted+0x53>
    while ((a = list_next (a)) != b) 
c002a93b:	83 ec 0c             	sub    $0xc,%esp
c002a93e:	ff 75 08             	pushl  0x8(%ebp)
c002a941:	e8 d4 f9 ff ff       	call   c002a31a <list_next>
c002a946:	83 c4 10             	add    $0x10,%esp
c002a949:	89 45 08             	mov    %eax,0x8(%ebp)
c002a94c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a94f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a952:	75 bf                	jne    c002a913 <is_sorted+0x10>
  return true;
c002a954:	b0 01                	mov    $0x1,%al
}
c002a956:	c9                   	leave  
c002a957:	c3                   	ret    

c002a958 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002a958:	55                   	push   %ebp
c002a959:	89 e5                	mov    %esp,%ebp
c002a95b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c002a95e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a962:	75 21                	jne    c002a985 <find_end_of_run+0x2d>
c002a964:	83 ec 0c             	sub    $0xc,%esp
c002a967:	68 67 18 03 c0       	push   $0xc0031867
c002a96c:	68 65 17 03 c0       	push   $0xc0031765
c002a971:	68 d8 19 03 c0       	push   $0xc00319d8
c002a976:	68 69 01 00 00       	push   $0x169
c002a97b:	68 7c 17 03 c0       	push   $0xc003177c
c002a980:	e8 9d f6 ff ff       	call   c002a022 <debug_panic>
  ASSERT (b != NULL);
c002a985:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a989:	75 21                	jne    c002a9ac <find_end_of_run+0x54>
c002a98b:	83 ec 0c             	sub    $0xc,%esp
c002a98e:	68 71 18 03 c0       	push   $0xc0031871
c002a993:	68 65 17 03 c0       	push   $0xc0031765
c002a998:	68 d8 19 03 c0       	push   $0xc00319d8
c002a99d:	68 6a 01 00 00       	push   $0x16a
c002a9a2:	68 7c 17 03 c0       	push   $0xc003177c
c002a9a7:	e8 76 f6 ff ff       	call   c002a022 <debug_panic>
  ASSERT (less != NULL);
c002a9ac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a9b0:	75 21                	jne    c002a9d3 <find_end_of_run+0x7b>
c002a9b2:	83 ec 0c             	sub    $0xc,%esp
c002a9b5:	68 7b 18 03 c0       	push   $0xc003187b
c002a9ba:	68 65 17 03 c0       	push   $0xc0031765
c002a9bf:	68 d8 19 03 c0       	push   $0xc00319d8
c002a9c4:	68 6b 01 00 00       	push   $0x16b
c002a9c9:	68 7c 17 03 c0       	push   $0xc003177c
c002a9ce:	e8 4f f6 ff ff       	call   c002a022 <debug_panic>
  ASSERT (a != b);
c002a9d3:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a9d9:	75 21                	jne    c002a9fc <find_end_of_run+0xa4>
c002a9db:	83 ec 0c             	sub    $0xc,%esp
c002a9de:	68 88 18 03 c0       	push   $0xc0031888
c002a9e3:	68 65 17 03 c0       	push   $0xc0031765
c002a9e8:	68 d8 19 03 c0       	push   $0xc00319d8
c002a9ed:	68 6c 01 00 00       	push   $0x16c
c002a9f2:	68 7c 17 03 c0       	push   $0xc003177c
c002a9f7:	e8 26 f6 ff ff       	call   c002a022 <debug_panic>
  
  do 
    {
      a = list_next (a);
c002a9fc:	83 ec 0c             	sub    $0xc,%esp
c002a9ff:	ff 75 08             	pushl  0x8(%ebp)
c002aa02:	e8 13 f9 ff ff       	call   c002a31a <list_next>
c002aa07:	83 c4 10             	add    $0x10,%esp
c002aa0a:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002aa0d:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa10:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aa13:	74 27                	je     c002aa3c <find_end_of_run+0xe4>
c002aa15:	83 ec 0c             	sub    $0xc,%esp
c002aa18:	ff 75 08             	pushl  0x8(%ebp)
c002aa1b:	e8 a8 f9 ff ff       	call   c002a3c8 <list_prev>
c002aa20:	83 c4 10             	add    $0x10,%esp
c002aa23:	83 ec 04             	sub    $0x4,%esp
c002aa26:	ff 75 14             	pushl  0x14(%ebp)
c002aa29:	50                   	push   %eax
c002aa2a:	ff 75 08             	pushl  0x8(%ebp)
c002aa2d:	8b 45 10             	mov    0x10(%ebp),%eax
c002aa30:	ff d0                	call   *%eax
c002aa32:	83 c4 10             	add    $0x10,%esp
c002aa35:	83 f0 01             	xor    $0x1,%eax
c002aa38:	84 c0                	test   %al,%al
c002aa3a:	75 c0                	jne    c002a9fc <find_end_of_run+0xa4>
  return a;
c002aa3c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002aa3f:	c9                   	leave  
c002aa40:	c3                   	ret    

c002aa41 <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002aa41:	55                   	push   %ebp
c002aa42:	89 e5                	mov    %esp,%ebp
c002aa44:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c002aa47:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa4b:	75 21                	jne    c002aa6e <inplace_merge+0x2d>
c002aa4d:	83 ec 0c             	sub    $0xc,%esp
c002aa50:	68 8f 18 03 c0       	push   $0xc003188f
c002aa55:	68 65 17 03 c0       	push   $0xc0031765
c002aa5a:	68 e8 19 03 c0       	push   $0xc00319e8
c002aa5f:	68 80 01 00 00       	push   $0x180
c002aa64:	68 7c 17 03 c0       	push   $0xc003177c
c002aa69:	e8 b4 f5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (a1b0 != NULL);
c002aa6e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002aa72:	75 21                	jne    c002aa95 <inplace_merge+0x54>
c002aa74:	83 ec 0c             	sub    $0xc,%esp
c002aa77:	68 9a 18 03 c0       	push   $0xc003189a
c002aa7c:	68 65 17 03 c0       	push   $0xc0031765
c002aa81:	68 e8 19 03 c0       	push   $0xc00319e8
c002aa86:	68 81 01 00 00       	push   $0x181
c002aa8b:	68 7c 17 03 c0       	push   $0xc003177c
c002aa90:	e8 8d f5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (b1 != NULL);
c002aa95:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002aa99:	75 21                	jne    c002aabc <inplace_merge+0x7b>
c002aa9b:	83 ec 0c             	sub    $0xc,%esp
c002aa9e:	68 a7 18 03 c0       	push   $0xc00318a7
c002aaa3:	68 65 17 03 c0       	push   $0xc0031765
c002aaa8:	68 e8 19 03 c0       	push   $0xc00319e8
c002aaad:	68 82 01 00 00       	push   $0x182
c002aab2:	68 7c 17 03 c0       	push   $0xc003177c
c002aab7:	e8 66 f5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (less != NULL);
c002aabc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002aac0:	75 21                	jne    c002aae3 <inplace_merge+0xa2>
c002aac2:	83 ec 0c             	sub    $0xc,%esp
c002aac5:	68 7b 18 03 c0       	push   $0xc003187b
c002aaca:	68 65 17 03 c0       	push   $0xc0031765
c002aacf:	68 e8 19 03 c0       	push   $0xc00319e8
c002aad4:	68 83 01 00 00       	push   $0x183
c002aad9:	68 7c 17 03 c0       	push   $0xc003177c
c002aade:	e8 3f f5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002aae3:	ff 75 18             	pushl  0x18(%ebp)
c002aae6:	ff 75 14             	pushl  0x14(%ebp)
c002aae9:	ff 75 0c             	pushl  0xc(%ebp)
c002aaec:	ff 75 08             	pushl  0x8(%ebp)
c002aaef:	e8 0f fe ff ff       	call   c002a903 <is_sorted>
c002aaf4:	83 c4 10             	add    $0x10,%esp
c002aaf7:	84 c0                	test   %al,%al
c002aaf9:	75 21                	jne    c002ab1c <inplace_merge+0xdb>
c002aafb:	83 ec 0c             	sub    $0xc,%esp
c002aafe:	68 b4 18 03 c0       	push   $0xc00318b4
c002ab03:	68 65 17 03 c0       	push   $0xc0031765
c002ab08:	68 e8 19 03 c0       	push   $0xc00319e8
c002ab0d:	68 84 01 00 00       	push   $0x184
c002ab12:	68 7c 17 03 c0       	push   $0xc003177c
c002ab17:	e8 06 f5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002ab1c:	ff 75 18             	pushl  0x18(%ebp)
c002ab1f:	ff 75 14             	pushl  0x14(%ebp)
c002ab22:	ff 75 10             	pushl  0x10(%ebp)
c002ab25:	ff 75 0c             	pushl  0xc(%ebp)
c002ab28:	e8 d6 fd ff ff       	call   c002a903 <is_sorted>
c002ab2d:	83 c4 10             	add    $0x10,%esp
c002ab30:	84 c0                	test   %al,%al
c002ab32:	0f 85 80 00 00 00    	jne    c002abb8 <inplace_merge+0x177>
c002ab38:	83 ec 0c             	sub    $0xc,%esp
c002ab3b:	68 d4 18 03 c0       	push   $0xc00318d4
c002ab40:	68 65 17 03 c0       	push   $0xc0031765
c002ab45:	68 e8 19 03 c0       	push   $0xc00319e8
c002ab4a:	68 85 01 00 00       	push   $0x185
c002ab4f:	68 7c 17 03 c0       	push   $0xc003177c
c002ab54:	e8 c9 f4 ff ff       	call   c002a022 <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002ab59:	83 ec 04             	sub    $0x4,%esp
c002ab5c:	ff 75 18             	pushl  0x18(%ebp)
c002ab5f:	ff 75 08             	pushl  0x8(%ebp)
c002ab62:	ff 75 0c             	pushl  0xc(%ebp)
c002ab65:	8b 45 14             	mov    0x14(%ebp),%eax
c002ab68:	ff d0                	call   *%eax
c002ab6a:	83 c4 10             	add    $0x10,%esp
c002ab6d:	83 f0 01             	xor    $0x1,%eax
c002ab70:	84 c0                	test   %al,%al
c002ab72:	74 13                	je     c002ab87 <inplace_merge+0x146>
      a0 = list_next (a0);
c002ab74:	83 ec 0c             	sub    $0xc,%esp
c002ab77:	ff 75 08             	pushl  0x8(%ebp)
c002ab7a:	e8 9b f7 ff ff       	call   c002a31a <list_next>
c002ab7f:	83 c4 10             	add    $0x10,%esp
c002ab82:	89 45 08             	mov    %eax,0x8(%ebp)
c002ab85:	eb 31                	jmp    c002abb8 <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002ab87:	83 ec 0c             	sub    $0xc,%esp
c002ab8a:	ff 75 0c             	pushl  0xc(%ebp)
c002ab8d:	e8 88 f7 ff ff       	call   c002a31a <list_next>
c002ab92:	83 c4 10             	add    $0x10,%esp
c002ab95:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002ab98:	83 ec 0c             	sub    $0xc,%esp
c002ab9b:	ff 75 0c             	pushl  0xc(%ebp)
c002ab9e:	e8 25 f8 ff ff       	call   c002a3c8 <list_prev>
c002aba3:	83 c4 10             	add    $0x10,%esp
c002aba6:	83 ec 04             	sub    $0x4,%esp
c002aba9:	ff 75 0c             	pushl  0xc(%ebp)
c002abac:	50                   	push   %eax
c002abad:	ff 75 08             	pushl  0x8(%ebp)
c002abb0:	e8 8a f9 ff ff       	call   c002a53f <list_splice>
c002abb5:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002abb8:	8b 45 08             	mov    0x8(%ebp),%eax
c002abbb:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002abbe:	74 08                	je     c002abc8 <inplace_merge+0x187>
c002abc0:	8b 45 0c             	mov    0xc(%ebp),%eax
c002abc3:	3b 45 10             	cmp    0x10(%ebp),%eax
c002abc6:	75 91                	jne    c002ab59 <inplace_merge+0x118>
      }
}
c002abc8:	90                   	nop
c002abc9:	c9                   	leave  
c002abca:	c3                   	ret    

c002abcb <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002abcb:	55                   	push   %ebp
c002abcc:	89 e5                	mov    %esp,%ebp
c002abce:	53                   	push   %ebx
c002abcf:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002abd2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002abd6:	75 21                	jne    c002abf9 <list_sort+0x2e>
c002abd8:	83 ec 0c             	sub    $0xc,%esp
c002abdb:	68 58 17 03 c0       	push   $0xc0031758
c002abe0:	68 65 17 03 c0       	push   $0xc0031765
c002abe5:	68 f8 19 03 c0       	push   $0xc00319f8
c002abea:	68 99 01 00 00       	push   $0x199
c002abef:	68 7c 17 03 c0       	push   $0xc003177c
c002abf4:	e8 29 f4 ff ff       	call   c002a022 <debug_panic>
  ASSERT (less != NULL);
c002abf9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002abfd:	75 21                	jne    c002ac20 <list_sort+0x55>
c002abff:	83 ec 0c             	sub    $0xc,%esp
c002ac02:	68 7b 18 03 c0       	push   $0xc003187b
c002ac07:	68 65 17 03 c0       	push   $0xc0031765
c002ac0c:	68 f8 19 03 c0       	push   $0xc00319f8
c002ac11:	68 9a 01 00 00       	push   $0x19a
c002ac16:	68 7c 17 03 c0       	push   $0xc003177c
c002ac1b:	e8 02 f4 ff ff       	call   c002a022 <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002ac20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002ac27:	83 ec 0c             	sub    $0xc,%esp
c002ac2a:	ff 75 08             	pushl  0x8(%ebp)
c002ac2d:	e8 b6 f6 ff ff       	call   c002a2e8 <list_begin>
c002ac32:	83 c4 10             	add    $0x10,%esp
c002ac35:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ac38:	eb 7c                	jmp    c002acb6 <list_sort+0xeb>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002ac3a:	ff 45 f4             	incl   -0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002ac3d:	83 ec 0c             	sub    $0xc,%esp
c002ac40:	ff 75 08             	pushl  0x8(%ebp)
c002ac43:	e8 1c f7 ff ff       	call   c002a364 <list_end>
c002ac48:	83 c4 10             	add    $0x10,%esp
c002ac4b:	ff 75 10             	pushl  0x10(%ebp)
c002ac4e:	ff 75 0c             	pushl  0xc(%ebp)
c002ac51:	50                   	push   %eax
c002ac52:	ff 75 f0             	pushl  -0x10(%ebp)
c002ac55:	e8 fe fc ff ff       	call   c002a958 <find_end_of_run>
c002ac5a:	83 c4 10             	add    $0x10,%esp
c002ac5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002ac60:	83 ec 0c             	sub    $0xc,%esp
c002ac63:	ff 75 08             	pushl  0x8(%ebp)
c002ac66:	e8 f9 f6 ff ff       	call   c002a364 <list_end>
c002ac6b:	83 c4 10             	add    $0x10,%esp
c002ac6e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002ac71:	74 5c                	je     c002accf <list_sort+0x104>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002ac73:	83 ec 0c             	sub    $0xc,%esp
c002ac76:	ff 75 08             	pushl  0x8(%ebp)
c002ac79:	e8 e6 f6 ff ff       	call   c002a364 <list_end>
c002ac7e:	83 c4 10             	add    $0x10,%esp
c002ac81:	ff 75 10             	pushl  0x10(%ebp)
c002ac84:	ff 75 0c             	pushl  0xc(%ebp)
c002ac87:	50                   	push   %eax
c002ac88:	ff 75 ec             	pushl  -0x14(%ebp)
c002ac8b:	e8 c8 fc ff ff       	call   c002a958 <find_end_of_run>
c002ac90:	83 c4 10             	add    $0x10,%esp
c002ac93:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002ac96:	83 ec 0c             	sub    $0xc,%esp
c002ac99:	ff 75 10             	pushl  0x10(%ebp)
c002ac9c:	ff 75 0c             	pushl  0xc(%ebp)
c002ac9f:	ff 75 e8             	pushl  -0x18(%ebp)
c002aca2:	ff 75 ec             	pushl  -0x14(%ebp)
c002aca5:	ff 75 f0             	pushl  -0x10(%ebp)
c002aca8:	e8 94 fd ff ff       	call   c002aa41 <inplace_merge>
c002acad:	83 c4 20             	add    $0x20,%esp
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002acb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002acb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002acb6:	83 ec 0c             	sub    $0xc,%esp
c002acb9:	ff 75 08             	pushl  0x8(%ebp)
c002acbc:	e8 a3 f6 ff ff       	call   c002a364 <list_end>
c002acc1:	83 c4 10             	add    $0x10,%esp
c002acc4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002acc7:	0f 85 6d ff ff ff    	jne    c002ac3a <list_sort+0x6f>
c002accd:	eb 01                	jmp    c002acd0 <list_sort+0x105>
            break;
c002accf:	90                   	nop
        }
    }
  while (output_run_cnt > 1);
c002acd0:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002acd4:	0f 87 46 ff ff ff    	ja     c002ac20 <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002acda:	83 ec 0c             	sub    $0xc,%esp
c002acdd:	ff 75 08             	pushl  0x8(%ebp)
c002ace0:	e8 7f f6 ff ff       	call   c002a364 <list_end>
c002ace5:	83 c4 10             	add    $0x10,%esp
c002ace8:	89 c3                	mov    %eax,%ebx
c002acea:	83 ec 0c             	sub    $0xc,%esp
c002aced:	ff 75 08             	pushl  0x8(%ebp)
c002acf0:	e8 f3 f5 ff ff       	call   c002a2e8 <list_begin>
c002acf5:	83 c4 10             	add    $0x10,%esp
c002acf8:	ff 75 10             	pushl  0x10(%ebp)
c002acfb:	ff 75 0c             	pushl  0xc(%ebp)
c002acfe:	53                   	push   %ebx
c002acff:	50                   	push   %eax
c002ad00:	e8 fe fb ff ff       	call   c002a903 <is_sorted>
c002ad05:	83 c4 10             	add    $0x10,%esp
c002ad08:	84 c0                	test   %al,%al
c002ad0a:	75 21                	jne    c002ad2d <list_sort+0x162>
c002ad0c:	83 ec 0c             	sub    $0xc,%esp
c002ad0f:	68 f4 18 03 c0       	push   $0xc00318f4
c002ad14:	68 65 17 03 c0       	push   $0xc0031765
c002ad19:	68 f8 19 03 c0       	push   $0xc00319f8
c002ad1e:	68 b7 01 00 00       	push   $0x1b7
c002ad23:	68 7c 17 03 c0       	push   $0xc003177c
c002ad28:	e8 f5 f2 ff ff       	call   c002a022 <debug_panic>
}
c002ad2d:	90                   	nop
c002ad2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ad31:	c9                   	leave  
c002ad32:	c3                   	ret    

c002ad33 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002ad33:	55                   	push   %ebp
c002ad34:	89 e5                	mov    %esp,%ebp
c002ad36:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002ad39:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ad3d:	75 21                	jne    c002ad60 <list_insert_ordered+0x2d>
c002ad3f:	83 ec 0c             	sub    $0xc,%esp
c002ad42:	68 58 17 03 c0       	push   $0xc0031758
c002ad47:	68 65 17 03 c0       	push   $0xc0031765
c002ad4c:	68 04 1a 03 c0       	push   $0xc0031a04
c002ad51:	68 c3 01 00 00       	push   $0x1c3
c002ad56:	68 7c 17 03 c0       	push   $0xc003177c
c002ad5b:	e8 c2 f2 ff ff       	call   c002a022 <debug_panic>
  ASSERT (elem != NULL);
c002ad60:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ad64:	75 21                	jne    c002ad87 <list_insert_ordered+0x54>
c002ad66:	83 ec 0c             	sub    $0xc,%esp
c002ad69:	68 0d 18 03 c0       	push   $0xc003180d
c002ad6e:	68 65 17 03 c0       	push   $0xc0031765
c002ad73:	68 04 1a 03 c0       	push   $0xc0031a04
c002ad78:	68 c4 01 00 00       	push   $0x1c4
c002ad7d:	68 7c 17 03 c0       	push   $0xc003177c
c002ad82:	e8 9b f2 ff ff       	call   c002a022 <debug_panic>
  ASSERT (less != NULL);
c002ad87:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002ad8b:	75 21                	jne    c002adae <list_insert_ordered+0x7b>
c002ad8d:	83 ec 0c             	sub    $0xc,%esp
c002ad90:	68 7b 18 03 c0       	push   $0xc003187b
c002ad95:	68 65 17 03 c0       	push   $0xc0031765
c002ad9a:	68 04 1a 03 c0       	push   $0xc0031a04
c002ad9f:	68 c5 01 00 00       	push   $0x1c5
c002ada4:	68 7c 17 03 c0       	push   $0xc003177c
c002ada9:	e8 74 f2 ff ff       	call   c002a022 <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002adae:	83 ec 0c             	sub    $0xc,%esp
c002adb1:	ff 75 08             	pushl  0x8(%ebp)
c002adb4:	e8 2f f5 ff ff       	call   c002a2e8 <list_begin>
c002adb9:	83 c4 10             	add    $0x10,%esp
c002adbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002adbf:	eb 29                	jmp    c002adea <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002adc1:	83 ec 04             	sub    $0x4,%esp
c002adc4:	ff 75 14             	pushl  0x14(%ebp)
c002adc7:	ff 75 f4             	pushl  -0xc(%ebp)
c002adca:	ff 75 0c             	pushl  0xc(%ebp)
c002adcd:	8b 45 10             	mov    0x10(%ebp),%eax
c002add0:	ff d0                	call   *%eax
c002add2:	83 c4 10             	add    $0x10,%esp
c002add5:	84 c0                	test   %al,%al
c002add7:	75 26                	jne    c002adff <list_insert_ordered+0xcc>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002add9:	83 ec 0c             	sub    $0xc,%esp
c002addc:	ff 75 f4             	pushl  -0xc(%ebp)
c002addf:	e8 36 f5 ff ff       	call   c002a31a <list_next>
c002ade4:	83 c4 10             	add    $0x10,%esp
c002ade7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002adea:	83 ec 0c             	sub    $0xc,%esp
c002aded:	ff 75 08             	pushl  0x8(%ebp)
c002adf0:	e8 6f f5 ff ff       	call   c002a364 <list_end>
c002adf5:	83 c4 10             	add    $0x10,%esp
c002adf8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002adfb:	75 c4                	jne    c002adc1 <list_insert_ordered+0x8e>
c002adfd:	eb 01                	jmp    c002ae00 <list_insert_ordered+0xcd>
      break;
c002adff:	90                   	nop
  return list_insert (e, elem);
c002ae00:	83 ec 08             	sub    $0x8,%esp
c002ae03:	ff 75 0c             	pushl  0xc(%ebp)
c002ae06:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae09:	e8 9c f6 ff ff       	call   c002a4aa <list_insert>
c002ae0e:	83 c4 10             	add    $0x10,%esp
}
c002ae11:	c9                   	leave  
c002ae12:	c3                   	ret    

c002ae13 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002ae13:	55                   	push   %ebp
c002ae14:	89 e5                	mov    %esp,%ebp
c002ae16:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002ae19:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ae1d:	75 21                	jne    c002ae40 <list_unique+0x2d>
c002ae1f:	83 ec 0c             	sub    $0xc,%esp
c002ae22:	68 58 17 03 c0       	push   $0xc0031758
c002ae27:	68 65 17 03 c0       	push   $0xc0031765
c002ae2c:	68 18 1a 03 c0       	push   $0xc0031a18
c002ae31:	68 d7 01 00 00       	push   $0x1d7
c002ae36:	68 7c 17 03 c0       	push   $0xc003177c
c002ae3b:	e8 e2 f1 ff ff       	call   c002a022 <debug_panic>
  ASSERT (less != NULL);
c002ae40:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002ae44:	75 21                	jne    c002ae67 <list_unique+0x54>
c002ae46:	83 ec 0c             	sub    $0xc,%esp
c002ae49:	68 7b 18 03 c0       	push   $0xc003187b
c002ae4e:	68 65 17 03 c0       	push   $0xc0031765
c002ae53:	68 18 1a 03 c0       	push   $0xc0031a18
c002ae58:	68 d8 01 00 00       	push   $0x1d8
c002ae5d:	68 7c 17 03 c0       	push   $0xc003177c
c002ae62:	e8 bb f1 ff ff       	call   c002a022 <debug_panic>
  if (list_empty (list))
c002ae67:	83 ec 0c             	sub    $0xc,%esp
c002ae6a:	ff 75 08             	pushl  0x8(%ebp)
c002ae6d:	e8 a8 f9 ff ff       	call   c002a81a <list_empty>
c002ae72:	83 c4 10             	add    $0x10,%esp
c002ae75:	84 c0                	test   %al,%al
c002ae77:	0f 85 a0 00 00 00    	jne    c002af1d <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002ae7d:	83 ec 0c             	sub    $0xc,%esp
c002ae80:	ff 75 08             	pushl  0x8(%ebp)
c002ae83:	e8 60 f4 ff ff       	call   c002a2e8 <list_begin>
c002ae88:	83 c4 10             	add    $0x10,%esp
c002ae8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002ae8e:	eb 63                	jmp    c002aef3 <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002ae90:	83 ec 04             	sub    $0x4,%esp
c002ae93:	ff 75 14             	pushl  0x14(%ebp)
c002ae96:	ff 75 f0             	pushl  -0x10(%ebp)
c002ae99:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae9c:	8b 45 10             	mov    0x10(%ebp),%eax
c002ae9f:	ff d0                	call   *%eax
c002aea1:	83 c4 10             	add    $0x10,%esp
c002aea4:	83 f0 01             	xor    $0x1,%eax
c002aea7:	84 c0                	test   %al,%al
c002aea9:	74 42                	je     c002aeed <list_unique+0xda>
c002aeab:	83 ec 04             	sub    $0x4,%esp
c002aeae:	ff 75 14             	pushl  0x14(%ebp)
c002aeb1:	ff 75 f4             	pushl  -0xc(%ebp)
c002aeb4:	ff 75 f0             	pushl  -0x10(%ebp)
c002aeb7:	8b 45 10             	mov    0x10(%ebp),%eax
c002aeba:	ff d0                	call   *%eax
c002aebc:	83 c4 10             	add    $0x10,%esp
c002aebf:	83 f0 01             	xor    $0x1,%eax
c002aec2:	84 c0                	test   %al,%al
c002aec4:	74 27                	je     c002aeed <list_unique+0xda>
      {
        list_remove (next);
c002aec6:	83 ec 0c             	sub    $0xc,%esp
c002aec9:	ff 75 f0             	pushl  -0x10(%ebp)
c002aecc:	e8 c8 f7 ff ff       	call   c002a699 <list_remove>
c002aed1:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002aed4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002aed8:	74 19                	je     c002aef3 <list_unique+0xe0>
          list_push_back (duplicates, next);
c002aeda:	83 ec 08             	sub    $0x8,%esp
c002aedd:	ff 75 f0             	pushl  -0x10(%ebp)
c002aee0:	ff 75 0c             	pushl  0xc(%ebp)
c002aee3:	e8 8b f7 ff ff       	call   c002a673 <list_push_back>
c002aee8:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002aeeb:	eb 06                	jmp    c002aef3 <list_unique+0xe0>
      }
    else
      elem = next;
c002aeed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002aef0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002aef3:	83 ec 0c             	sub    $0xc,%esp
c002aef6:	ff 75 f4             	pushl  -0xc(%ebp)
c002aef9:	e8 1c f4 ff ff       	call   c002a31a <list_next>
c002aefe:	83 c4 10             	add    $0x10,%esp
c002af01:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002af04:	83 ec 0c             	sub    $0xc,%esp
c002af07:	ff 75 08             	pushl  0x8(%ebp)
c002af0a:	e8 55 f4 ff ff       	call   c002a364 <list_end>
c002af0f:	83 c4 10             	add    $0x10,%esp
c002af12:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002af15:	0f 85 75 ff ff ff    	jne    c002ae90 <list_unique+0x7d>
c002af1b:	eb 01                	jmp    c002af1e <list_unique+0x10b>
    return;
c002af1d:	90                   	nop
}
c002af1e:	c9                   	leave  
c002af1f:	c3                   	ret    

c002af20 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002af20:	55                   	push   %ebp
c002af21:	89 e5                	mov    %esp,%ebp
c002af23:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002af26:	83 ec 0c             	sub    $0xc,%esp
c002af29:	ff 75 08             	pushl  0x8(%ebp)
c002af2c:	e8 b7 f3 ff ff       	call   c002a2e8 <list_begin>
c002af31:	83 c4 10             	add    $0x10,%esp
c002af34:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002af37:	83 ec 0c             	sub    $0xc,%esp
c002af3a:	ff 75 08             	pushl  0x8(%ebp)
c002af3d:	e8 22 f4 ff ff       	call   c002a364 <list_end>
c002af42:	83 c4 10             	add    $0x10,%esp
c002af45:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002af48:	74 55                	je     c002af9f <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002af4a:	83 ec 0c             	sub    $0xc,%esp
c002af4d:	ff 75 f4             	pushl  -0xc(%ebp)
c002af50:	e8 c5 f3 ff ff       	call   c002a31a <list_next>
c002af55:	83 c4 10             	add    $0x10,%esp
c002af58:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002af5b:	eb 2f                	jmp    c002af8c <list_max+0x6c>
        if (less (max, e, aux))
c002af5d:	83 ec 04             	sub    $0x4,%esp
c002af60:	ff 75 10             	pushl  0x10(%ebp)
c002af63:	ff 75 f0             	pushl  -0x10(%ebp)
c002af66:	ff 75 f4             	pushl  -0xc(%ebp)
c002af69:	8b 45 0c             	mov    0xc(%ebp),%eax
c002af6c:	ff d0                	call   *%eax
c002af6e:	83 c4 10             	add    $0x10,%esp
c002af71:	84 c0                	test   %al,%al
c002af73:	74 06                	je     c002af7b <list_max+0x5b>
          max = e; 
c002af75:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002af78:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002af7b:	83 ec 0c             	sub    $0xc,%esp
c002af7e:	ff 75 f0             	pushl  -0x10(%ebp)
c002af81:	e8 94 f3 ff ff       	call   c002a31a <list_next>
c002af86:	83 c4 10             	add    $0x10,%esp
c002af89:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002af8c:	83 ec 0c             	sub    $0xc,%esp
c002af8f:	ff 75 08             	pushl  0x8(%ebp)
c002af92:	e8 cd f3 ff ff       	call   c002a364 <list_end>
c002af97:	83 c4 10             	add    $0x10,%esp
c002af9a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002af9d:	75 be                	jne    c002af5d <list_max+0x3d>
    }
  return max;
c002af9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002afa2:	c9                   	leave  
c002afa3:	c3                   	ret    

c002afa4 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002afa4:	55                   	push   %ebp
c002afa5:	89 e5                	mov    %esp,%ebp
c002afa7:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002afaa:	83 ec 0c             	sub    $0xc,%esp
c002afad:	ff 75 08             	pushl  0x8(%ebp)
c002afb0:	e8 33 f3 ff ff       	call   c002a2e8 <list_begin>
c002afb5:	83 c4 10             	add    $0x10,%esp
c002afb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002afbb:	83 ec 0c             	sub    $0xc,%esp
c002afbe:	ff 75 08             	pushl  0x8(%ebp)
c002afc1:	e8 9e f3 ff ff       	call   c002a364 <list_end>
c002afc6:	83 c4 10             	add    $0x10,%esp
c002afc9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002afcc:	74 55                	je     c002b023 <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002afce:	83 ec 0c             	sub    $0xc,%esp
c002afd1:	ff 75 f4             	pushl  -0xc(%ebp)
c002afd4:	e8 41 f3 ff ff       	call   c002a31a <list_next>
c002afd9:	83 c4 10             	add    $0x10,%esp
c002afdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002afdf:	eb 2f                	jmp    c002b010 <list_min+0x6c>
        if (less (e, min, aux))
c002afe1:	83 ec 04             	sub    $0x4,%esp
c002afe4:	ff 75 10             	pushl  0x10(%ebp)
c002afe7:	ff 75 f4             	pushl  -0xc(%ebp)
c002afea:	ff 75 f0             	pushl  -0x10(%ebp)
c002afed:	8b 45 0c             	mov    0xc(%ebp),%eax
c002aff0:	ff d0                	call   *%eax
c002aff2:	83 c4 10             	add    $0x10,%esp
c002aff5:	84 c0                	test   %al,%al
c002aff7:	74 06                	je     c002afff <list_min+0x5b>
          min = e; 
c002aff9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002affc:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002afff:	83 ec 0c             	sub    $0xc,%esp
c002b002:	ff 75 f0             	pushl  -0x10(%ebp)
c002b005:	e8 10 f3 ff ff       	call   c002a31a <list_next>
c002b00a:	83 c4 10             	add    $0x10,%esp
c002b00d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b010:	83 ec 0c             	sub    $0xc,%esp
c002b013:	ff 75 08             	pushl  0x8(%ebp)
c002b016:	e8 49 f3 ff ff       	call   c002a364 <list_end>
c002b01b:	83 c4 10             	add    $0x10,%esp
c002b01e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b021:	75 be                	jne    c002afe1 <list_min+0x3d>
    }
  return min;
c002b023:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b026:	c9                   	leave  
c002b027:	c3                   	ret    

c002b028 <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002b028:	55                   	push   %ebp
c002b029:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002b02b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b02e:	c1 e8 05             	shr    $0x5,%eax
}
c002b031:	5d                   	pop    %ebp
c002b032:	c3                   	ret    

c002b033 <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002b033:	55                   	push   %ebp
c002b034:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002b036:	8b 45 08             	mov    0x8(%ebp),%eax
c002b039:	83 e0 1f             	and    $0x1f,%eax
c002b03c:	ba 01 00 00 00       	mov    $0x1,%edx
c002b041:	88 c1                	mov    %al,%cl
c002b043:	d3 e2                	shl    %cl,%edx
c002b045:	89 d0                	mov    %edx,%eax
}
c002b047:	5d                   	pop    %ebp
c002b048:	c3                   	ret    

c002b049 <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002b049:	55                   	push   %ebp
c002b04a:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002b04c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b04f:	83 c0 1f             	add    $0x1f,%eax
c002b052:	c1 e8 05             	shr    $0x5,%eax
}
c002b055:	5d                   	pop    %ebp
c002b056:	c3                   	ret    

c002b057 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002b057:	55                   	push   %ebp
c002b058:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002b05a:	ff 75 08             	pushl  0x8(%ebp)
c002b05d:	e8 e7 ff ff ff       	call   c002b049 <elem_cnt>
c002b062:	83 c4 04             	add    $0x4,%esp
c002b065:	c1 e0 02             	shl    $0x2,%eax
}
c002b068:	c9                   	leave  
c002b069:	c3                   	ret    

c002b06a <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002b06a:	55                   	push   %ebp
c002b06b:	89 e5                	mov    %esp,%ebp
c002b06d:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002b070:	83 ec 0c             	sub    $0xc,%esp
c002b073:	6a 08                	push   $0x8
c002b075:	e8 4b 8c ff ff       	call   c0023cc5 <malloc>
c002b07a:	83 c4 10             	add    $0x10,%esp
c002b07d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002b080:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b084:	74 5d                	je     c002b0e3 <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002b086:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b089:	8b 55 08             	mov    0x8(%ebp),%edx
c002b08c:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002b08e:	83 ec 0c             	sub    $0xc,%esp
c002b091:	ff 75 08             	pushl  0x8(%ebp)
c002b094:	e8 be ff ff ff       	call   c002b057 <byte_cnt>
c002b099:	83 c4 10             	add    $0x10,%esp
c002b09c:	83 ec 0c             	sub    $0xc,%esp
c002b09f:	50                   	push   %eax
c002b0a0:	e8 20 8c ff ff       	call   c0023cc5 <malloc>
c002b0a5:	83 c4 10             	add    $0x10,%esp
c002b0a8:	89 c2                	mov    %eax,%edx
c002b0aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b0ad:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002b0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b0b3:	8b 40 04             	mov    0x4(%eax),%eax
c002b0b6:	85 c0                	test   %eax,%eax
c002b0b8:	75 06                	jne    c002b0c0 <bitmap_create+0x56>
c002b0ba:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b0be:	75 15                	jne    c002b0d5 <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002b0c0:	83 ec 08             	sub    $0x8,%esp
c002b0c3:	6a 00                	push   $0x0
c002b0c5:	ff 75 f4             	pushl  -0xc(%ebp)
c002b0c8:	e8 92 02 00 00       	call   c002b35f <bitmap_set_all>
c002b0cd:	83 c4 10             	add    $0x10,%esp
          return b;
c002b0d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b0d3:	eb 13                	jmp    c002b0e8 <bitmap_create+0x7e>
        }
      free (b);
c002b0d5:	83 ec 0c             	sub    $0xc,%esp
c002b0d8:	ff 75 f4             	pushl  -0xc(%ebp)
c002b0db:	e8 f1 8e ff ff       	call   c0023fd1 <free>
c002b0e0:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002b0e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b0e8:	c9                   	leave  
c002b0e9:	c3                   	ret    

c002b0ea <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002b0ea:	55                   	push   %ebp
c002b0eb:	89 e5                	mov    %esp,%ebp
c002b0ed:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002b0f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b0f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002b0f6:	83 ec 0c             	sub    $0xc,%esp
c002b0f9:	ff 75 08             	pushl  0x8(%ebp)
c002b0fc:	e8 4f 00 00 00       	call   c002b150 <bitmap_buf_size>
c002b101:	83 c4 10             	add    $0x10,%esp
c002b104:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b107:	76 1e                	jbe    c002b127 <bitmap_create_in_buf+0x3d>
c002b109:	83 ec 0c             	sub    $0xc,%esp
c002b10c:	68 24 1a 03 c0       	push   $0xc0031a24
c002b111:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b116:	68 c8 1a 03 c0       	push   $0xc0031ac8
c002b11b:	6a 68                	push   $0x68
c002b11d:	68 63 1a 03 c0       	push   $0xc0031a63
c002b122:	e8 fb ee ff ff       	call   c002a022 <debug_panic>

  b->bit_cnt = bit_cnt;
c002b127:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b12a:	8b 55 08             	mov    0x8(%ebp),%edx
c002b12d:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002b12f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b132:	8d 50 08             	lea    0x8(%eax),%edx
c002b135:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b138:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002b13b:	83 ec 08             	sub    $0x8,%esp
c002b13e:	6a 00                	push   $0x0
c002b140:	ff 75 f4             	pushl  -0xc(%ebp)
c002b143:	e8 17 02 00 00       	call   c002b35f <bitmap_set_all>
c002b148:	83 c4 10             	add    $0x10,%esp
  return b;
c002b14b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b14e:	c9                   	leave  
c002b14f:	c3                   	ret    

c002b150 <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002b150:	55                   	push   %ebp
c002b151:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002b153:	ff 75 08             	pushl  0x8(%ebp)
c002b156:	e8 fc fe ff ff       	call   c002b057 <byte_cnt>
c002b15b:	83 c4 04             	add    $0x4,%esp
c002b15e:	83 c0 08             	add    $0x8,%eax
}
c002b161:	c9                   	leave  
c002b162:	c3                   	ret    

c002b163 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002b163:	55                   	push   %ebp
c002b164:	89 e5                	mov    %esp,%ebp
c002b166:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002b169:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b16d:	74 20                	je     c002b18f <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002b16f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b172:	8b 40 04             	mov    0x4(%eax),%eax
c002b175:	83 ec 0c             	sub    $0xc,%esp
c002b178:	50                   	push   %eax
c002b179:	e8 53 8e ff ff       	call   c0023fd1 <free>
c002b17e:	83 c4 10             	add    $0x10,%esp
      free (b);
c002b181:	83 ec 0c             	sub    $0xc,%esp
c002b184:	ff 75 08             	pushl  0x8(%ebp)
c002b187:	e8 45 8e ff ff       	call   c0023fd1 <free>
c002b18c:	83 c4 10             	add    $0x10,%esp
    }
}
c002b18f:	90                   	nop
c002b190:	c9                   	leave  
c002b191:	c3                   	ret    

c002b192 <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002b192:	55                   	push   %ebp
c002b193:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002b195:	8b 45 08             	mov    0x8(%ebp),%eax
c002b198:	8b 00                	mov    (%eax),%eax
}
c002b19a:	5d                   	pop    %ebp
c002b19b:	c3                   	ret    

c002b19c <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002b19c:	55                   	push   %ebp
c002b19d:	89 e5                	mov    %esp,%ebp
c002b19f:	83 ec 18             	sub    $0x18,%esp
c002b1a2:	8b 45 10             	mov    0x10(%ebp),%eax
c002b1a5:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002b1a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b1ac:	75 21                	jne    c002b1cf <bitmap_set+0x33>
c002b1ae:	83 ec 0c             	sub    $0xc,%esp
c002b1b1:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b1b6:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b1bb:	68 e0 1a 03 c0       	push   $0xc0031ae0
c002b1c0:	68 93 00 00 00       	push   $0x93
c002b1c5:	68 63 1a 03 c0       	push   $0xc0031a63
c002b1ca:	e8 53 ee ff ff       	call   c002a022 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002b1cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1d2:	8b 00                	mov    (%eax),%eax
c002b1d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b1d7:	77 21                	ja     c002b1fa <bitmap_set+0x5e>
c002b1d9:	83 ec 0c             	sub    $0xc,%esp
c002b1dc:	68 87 1a 03 c0       	push   $0xc0031a87
c002b1e1:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b1e6:	68 e0 1a 03 c0       	push   $0xc0031ae0
c002b1eb:	68 94 00 00 00       	push   $0x94
c002b1f0:	68 63 1a 03 c0       	push   $0xc0031a63
c002b1f5:	e8 28 ee ff ff       	call   c002a022 <debug_panic>
  if (value)
c002b1fa:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002b1fe:	74 13                	je     c002b213 <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002b200:	83 ec 08             	sub    $0x8,%esp
c002b203:	ff 75 0c             	pushl  0xc(%ebp)
c002b206:	ff 75 08             	pushl  0x8(%ebp)
c002b209:	e8 19 00 00 00       	call   c002b227 <bitmap_mark>
c002b20e:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002b211:	eb 11                	jmp    c002b224 <bitmap_set+0x88>
    bitmap_reset (b, idx);
c002b213:	83 ec 08             	sub    $0x8,%esp
c002b216:	ff 75 0c             	pushl  0xc(%ebp)
c002b219:	ff 75 08             	pushl  0x8(%ebp)
c002b21c:	e8 3e 00 00 00       	call   c002b25f <bitmap_reset>
c002b221:	83 c4 10             	add    $0x10,%esp
}
c002b224:	90                   	nop
c002b225:	c9                   	leave  
c002b226:	c3                   	ret    

c002b227 <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002b227:	55                   	push   %ebp
c002b228:	89 e5                	mov    %esp,%ebp
c002b22a:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002b22d:	ff 75 0c             	pushl  0xc(%ebp)
c002b230:	e8 f3 fd ff ff       	call   c002b028 <elem_idx>
c002b235:	83 c4 04             	add    $0x4,%esp
c002b238:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002b23b:	ff 75 0c             	pushl  0xc(%ebp)
c002b23e:	e8 f0 fd ff ff       	call   c002b033 <bit_mask>
c002b243:	83 c4 04             	add    $0x4,%esp
c002b246:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002b249:	8b 45 08             	mov    0x8(%ebp),%eax
c002b24c:	8b 40 04             	mov    0x4(%eax),%eax
c002b24f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002b252:	c1 e2 02             	shl    $0x2,%edx
c002b255:	01 c2                	add    %eax,%edx
c002b257:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002b25a:	09 02                	or     %eax,(%edx)
}
c002b25c:	90                   	nop
c002b25d:	c9                   	leave  
c002b25e:	c3                   	ret    

c002b25f <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002b25f:	55                   	push   %ebp
c002b260:	89 e5                	mov    %esp,%ebp
c002b262:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002b265:	ff 75 0c             	pushl  0xc(%ebp)
c002b268:	e8 bb fd ff ff       	call   c002b028 <elem_idx>
c002b26d:	83 c4 04             	add    $0x4,%esp
c002b270:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002b273:	ff 75 0c             	pushl  0xc(%ebp)
c002b276:	e8 b8 fd ff ff       	call   c002b033 <bit_mask>
c002b27b:	83 c4 04             	add    $0x4,%esp
c002b27e:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002b281:	8b 45 08             	mov    0x8(%ebp),%eax
c002b284:	8b 40 04             	mov    0x4(%eax),%eax
c002b287:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002b28a:	c1 e2 02             	shl    $0x2,%edx
c002b28d:	01 d0                	add    %edx,%eax
c002b28f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002b292:	f7 d2                	not    %edx
c002b294:	21 10                	and    %edx,(%eax)
}
c002b296:	90                   	nop
c002b297:	c9                   	leave  
c002b298:	c3                   	ret    

c002b299 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002b299:	55                   	push   %ebp
c002b29a:	89 e5                	mov    %esp,%ebp
c002b29c:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002b29f:	ff 75 0c             	pushl  0xc(%ebp)
c002b2a2:	e8 81 fd ff ff       	call   c002b028 <elem_idx>
c002b2a7:	83 c4 04             	add    $0x4,%esp
c002b2aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002b2ad:	ff 75 0c             	pushl  0xc(%ebp)
c002b2b0:	e8 7e fd ff ff       	call   c002b033 <bit_mask>
c002b2b5:	83 c4 04             	add    $0x4,%esp
c002b2b8:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002b2bb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2be:	8b 40 04             	mov    0x4(%eax),%eax
c002b2c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002b2c4:	c1 e2 02             	shl    $0x2,%edx
c002b2c7:	01 c2                	add    %eax,%edx
c002b2c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002b2cc:	31 02                	xor    %eax,(%edx)
}
c002b2ce:	90                   	nop
c002b2cf:	c9                   	leave  
c002b2d0:	c3                   	ret    

c002b2d1 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002b2d1:	55                   	push   %ebp
c002b2d2:	89 e5                	mov    %esp,%ebp
c002b2d4:	53                   	push   %ebx
c002b2d5:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002b2d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b2dc:	75 21                	jne    c002b2ff <bitmap_test+0x2e>
c002b2de:	83 ec 0c             	sub    $0xc,%esp
c002b2e1:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b2e6:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b2eb:	68 ec 1a 03 c0       	push   $0xc0031aec
c002b2f0:	68 c8 00 00 00       	push   $0xc8
c002b2f5:	68 63 1a 03 c0       	push   $0xc0031a63
c002b2fa:	e8 23 ed ff ff       	call   c002a022 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002b2ff:	8b 45 08             	mov    0x8(%ebp),%eax
c002b302:	8b 00                	mov    (%eax),%eax
c002b304:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b307:	77 21                	ja     c002b32a <bitmap_test+0x59>
c002b309:	83 ec 0c             	sub    $0xc,%esp
c002b30c:	68 87 1a 03 c0       	push   $0xc0031a87
c002b311:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b316:	68 ec 1a 03 c0       	push   $0xc0031aec
c002b31b:	68 c9 00 00 00       	push   $0xc9
c002b320:	68 63 1a 03 c0       	push   $0xc0031a63
c002b325:	e8 f8 ec ff ff       	call   c002a022 <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002b32a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b32d:	8b 58 04             	mov    0x4(%eax),%ebx
c002b330:	83 ec 0c             	sub    $0xc,%esp
c002b333:	ff 75 0c             	pushl  0xc(%ebp)
c002b336:	e8 ed fc ff ff       	call   c002b028 <elem_idx>
c002b33b:	83 c4 10             	add    $0x10,%esp
c002b33e:	c1 e0 02             	shl    $0x2,%eax
c002b341:	01 d8                	add    %ebx,%eax
c002b343:	8b 18                	mov    (%eax),%ebx
c002b345:	83 ec 0c             	sub    $0xc,%esp
c002b348:	ff 75 0c             	pushl  0xc(%ebp)
c002b34b:	e8 e3 fc ff ff       	call   c002b033 <bit_mask>
c002b350:	83 c4 10             	add    $0x10,%esp
c002b353:	21 d8                	and    %ebx,%eax
c002b355:	85 c0                	test   %eax,%eax
c002b357:	0f 95 c0             	setne  %al
}
c002b35a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b35d:	c9                   	leave  
c002b35e:	c3                   	ret    

c002b35f <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002b35f:	55                   	push   %ebp
c002b360:	89 e5                	mov    %esp,%ebp
c002b362:	53                   	push   %ebx
c002b363:	83 ec 14             	sub    $0x14,%esp
c002b366:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b369:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002b36c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b370:	75 21                	jne    c002b393 <bitmap_set_all+0x34>
c002b372:	83 ec 0c             	sub    $0xc,%esp
c002b375:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b37a:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b37f:	68 f8 1a 03 c0       	push   $0xc0031af8
c002b384:	68 d3 00 00 00       	push   $0xd3
c002b389:	68 63 1a 03 c0       	push   $0xc0031a63
c002b38e:	e8 8f ec ff ff       	call   c002a022 <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002b393:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002b397:	83 ec 0c             	sub    $0xc,%esp
c002b39a:	ff 75 08             	pushl  0x8(%ebp)
c002b39d:	e8 f0 fd ff ff       	call   c002b192 <bitmap_size>
c002b3a2:	83 c4 10             	add    $0x10,%esp
c002b3a5:	53                   	push   %ebx
c002b3a6:	50                   	push   %eax
c002b3a7:	6a 00                	push   $0x0
c002b3a9:	ff 75 08             	pushl  0x8(%ebp)
c002b3ac:	e8 09 00 00 00       	call   c002b3ba <bitmap_set_multiple>
c002b3b1:	83 c4 10             	add    $0x10,%esp
}
c002b3b4:	90                   	nop
c002b3b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b3b8:	c9                   	leave  
c002b3b9:	c3                   	ret    

c002b3ba <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b3ba:	55                   	push   %ebp
c002b3bb:	89 e5                	mov    %esp,%ebp
c002b3bd:	83 ec 28             	sub    $0x28,%esp
c002b3c0:	8b 45 14             	mov    0x14(%ebp),%eax
c002b3c3:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002b3c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b3ca:	75 21                	jne    c002b3ed <bitmap_set_multiple+0x33>
c002b3cc:	83 ec 0c             	sub    $0xc,%esp
c002b3cf:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b3d4:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b3d9:	68 08 1b 03 c0       	push   $0xc0031b08
c002b3de:	68 de 00 00 00       	push   $0xde
c002b3e3:	68 63 1a 03 c0       	push   $0xc0031a63
c002b3e8:	e8 35 ec ff ff       	call   c002a022 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b3ed:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3f0:	8b 00                	mov    (%eax),%eax
c002b3f2:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b3f5:	73 21                	jae    c002b418 <bitmap_set_multiple+0x5e>
c002b3f7:	83 ec 0c             	sub    $0xc,%esp
c002b3fa:	68 98 1a 03 c0       	push   $0xc0031a98
c002b3ff:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b404:	68 08 1b 03 c0       	push   $0xc0031b08
c002b409:	68 df 00 00 00       	push   $0xdf
c002b40e:	68 63 1a 03 c0       	push   $0xc0031a63
c002b413:	e8 0a ec ff ff       	call   c002a022 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b418:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b41b:	8b 45 10             	mov    0x10(%ebp),%eax
c002b41e:	01 c2                	add    %eax,%edx
c002b420:	8b 45 08             	mov    0x8(%ebp),%eax
c002b423:	8b 00                	mov    (%eax),%eax
c002b425:	39 c2                	cmp    %eax,%edx
c002b427:	76 21                	jbe    c002b44a <bitmap_set_multiple+0x90>
c002b429:	83 ec 0c             	sub    $0xc,%esp
c002b42c:	68 ac 1a 03 c0       	push   $0xc0031aac
c002b431:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b436:	68 08 1b 03 c0       	push   $0xc0031b08
c002b43b:	68 e0 00 00 00       	push   $0xe0
c002b440:	68 63 1a 03 c0       	push   $0xc0031a63
c002b445:	e8 d8 eb ff ff       	call   c002a022 <debug_panic>

  for (i = 0; i < cnt; i++)
c002b44a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b451:	eb 1f                	jmp    c002b472 <bitmap_set_multiple+0xb8>
    bitmap_set (b, start + i, value);
c002b453:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b457:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002b45a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b45d:	01 ca                	add    %ecx,%edx
c002b45f:	83 ec 04             	sub    $0x4,%esp
c002b462:	50                   	push   %eax
c002b463:	52                   	push   %edx
c002b464:	ff 75 08             	pushl  0x8(%ebp)
c002b467:	e8 30 fd ff ff       	call   c002b19c <bitmap_set>
c002b46c:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < cnt; i++)
c002b46f:	ff 45 f4             	incl   -0xc(%ebp)
c002b472:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b475:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b478:	72 d9                	jb     c002b453 <bitmap_set_multiple+0x99>
}
c002b47a:	90                   	nop
c002b47b:	c9                   	leave  
c002b47c:	c3                   	ret    

c002b47d <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b47d:	55                   	push   %ebp
c002b47e:	89 e5                	mov    %esp,%ebp
c002b480:	83 ec 28             	sub    $0x28,%esp
c002b483:	8b 45 14             	mov    0x14(%ebp),%eax
c002b486:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002b489:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b48d:	75 21                	jne    c002b4b0 <bitmap_count+0x33>
c002b48f:	83 ec 0c             	sub    $0xc,%esp
c002b492:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b497:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b49c:	68 1c 1b 03 c0       	push   $0xc0031b1c
c002b4a1:	68 ed 00 00 00       	push   $0xed
c002b4a6:	68 63 1a 03 c0       	push   $0xc0031a63
c002b4ab:	e8 72 eb ff ff       	call   c002a022 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b4b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4b3:	8b 00                	mov    (%eax),%eax
c002b4b5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b4b8:	73 21                	jae    c002b4db <bitmap_count+0x5e>
c002b4ba:	83 ec 0c             	sub    $0xc,%esp
c002b4bd:	68 98 1a 03 c0       	push   $0xc0031a98
c002b4c2:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b4c7:	68 1c 1b 03 c0       	push   $0xc0031b1c
c002b4cc:	68 ee 00 00 00       	push   $0xee
c002b4d1:	68 63 1a 03 c0       	push   $0xc0031a63
c002b4d6:	e8 47 eb ff ff       	call   c002a022 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b4db:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b4de:	8b 45 10             	mov    0x10(%ebp),%eax
c002b4e1:	01 c2                	add    %eax,%edx
c002b4e3:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4e6:	8b 00                	mov    (%eax),%eax
c002b4e8:	39 c2                	cmp    %eax,%edx
c002b4ea:	76 21                	jbe    c002b50d <bitmap_count+0x90>
c002b4ec:	83 ec 0c             	sub    $0xc,%esp
c002b4ef:	68 ac 1a 03 c0       	push   $0xc0031aac
c002b4f4:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b4f9:	68 1c 1b 03 c0       	push   $0xc0031b1c
c002b4fe:	68 ef 00 00 00       	push   $0xef
c002b503:	68 63 1a 03 c0       	push   $0xc0031a63
c002b508:	e8 15 eb ff ff       	call   c002a022 <debug_panic>

  value_cnt = 0;
c002b50d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002b514:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b51b:	eb 22                	jmp    c002b53f <bitmap_count+0xc2>
    if (bitmap_test (b, start + i) == value)
c002b51d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b520:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b523:	01 d0                	add    %edx,%eax
c002b525:	83 ec 08             	sub    $0x8,%esp
c002b528:	50                   	push   %eax
c002b529:	ff 75 08             	pushl  0x8(%ebp)
c002b52c:	e8 a0 fd ff ff       	call   c002b2d1 <bitmap_test>
c002b531:	83 c4 10             	add    $0x10,%esp
c002b534:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002b537:	75 03                	jne    c002b53c <bitmap_count+0xbf>
      value_cnt++;
c002b539:	ff 45 f0             	incl   -0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002b53c:	ff 45 f4             	incl   -0xc(%ebp)
c002b53f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b542:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b545:	72 d6                	jb     c002b51d <bitmap_count+0xa0>
  return value_cnt;
c002b547:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b54a:	c9                   	leave  
c002b54b:	c3                   	ret    

c002b54c <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b54c:	55                   	push   %ebp
c002b54d:	89 e5                	mov    %esp,%ebp
c002b54f:	83 ec 28             	sub    $0x28,%esp
c002b552:	8b 45 14             	mov    0x14(%ebp),%eax
c002b555:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002b558:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b55c:	75 21                	jne    c002b57f <bitmap_contains+0x33>
c002b55e:	83 ec 0c             	sub    $0xc,%esp
c002b561:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b566:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b56b:	68 2c 1b 03 c0       	push   $0xc0031b2c
c002b570:	68 ff 00 00 00       	push   $0xff
c002b575:	68 63 1a 03 c0       	push   $0xc0031a63
c002b57a:	e8 a3 ea ff ff       	call   c002a022 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b57f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b582:	8b 00                	mov    (%eax),%eax
c002b584:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b587:	73 21                	jae    c002b5aa <bitmap_contains+0x5e>
c002b589:	83 ec 0c             	sub    $0xc,%esp
c002b58c:	68 98 1a 03 c0       	push   $0xc0031a98
c002b591:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b596:	68 2c 1b 03 c0       	push   $0xc0031b2c
c002b59b:	68 00 01 00 00       	push   $0x100
c002b5a0:	68 63 1a 03 c0       	push   $0xc0031a63
c002b5a5:	e8 78 ea ff ff       	call   c002a022 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b5aa:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b5ad:	8b 45 10             	mov    0x10(%ebp),%eax
c002b5b0:	01 c2                	add    %eax,%edx
c002b5b2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b5b5:	8b 00                	mov    (%eax),%eax
c002b5b7:	39 c2                	cmp    %eax,%edx
c002b5b9:	76 21                	jbe    c002b5dc <bitmap_contains+0x90>
c002b5bb:	83 ec 0c             	sub    $0xc,%esp
c002b5be:	68 ac 1a 03 c0       	push   $0xc0031aac
c002b5c3:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b5c8:	68 2c 1b 03 c0       	push   $0xc0031b2c
c002b5cd:	68 01 01 00 00       	push   $0x101
c002b5d2:	68 63 1a 03 c0       	push   $0xc0031a63
c002b5d7:	e8 46 ea ff ff       	call   c002a022 <debug_panic>

  for (i = 0; i < cnt; i++)
c002b5dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b5e3:	eb 23                	jmp    c002b608 <bitmap_contains+0xbc>
    if (bitmap_test (b, start + i) == value)
c002b5e5:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b5e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b5eb:	01 d0                	add    %edx,%eax
c002b5ed:	83 ec 08             	sub    $0x8,%esp
c002b5f0:	50                   	push   %eax
c002b5f1:	ff 75 08             	pushl  0x8(%ebp)
c002b5f4:	e8 d8 fc ff ff       	call   c002b2d1 <bitmap_test>
c002b5f9:	83 c4 10             	add    $0x10,%esp
c002b5fc:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002b5ff:	75 04                	jne    c002b605 <bitmap_contains+0xb9>
      return true;
c002b601:	b0 01                	mov    $0x1,%al
c002b603:	eb 0d                	jmp    c002b612 <bitmap_contains+0xc6>
  for (i = 0; i < cnt; i++)
c002b605:	ff 45 f4             	incl   -0xc(%ebp)
c002b608:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b60b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b60e:	72 d5                	jb     c002b5e5 <bitmap_contains+0x99>
  return false;
c002b610:	b0 00                	mov    $0x0,%al
}
c002b612:	c9                   	leave  
c002b613:	c3                   	ret    

c002b614 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b614:	55                   	push   %ebp
c002b615:	89 e5                	mov    %esp,%ebp
c002b617:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002b61a:	6a 01                	push   $0x1
c002b61c:	ff 75 10             	pushl  0x10(%ebp)
c002b61f:	ff 75 0c             	pushl  0xc(%ebp)
c002b622:	ff 75 08             	pushl  0x8(%ebp)
c002b625:	e8 22 ff ff ff       	call   c002b54c <bitmap_contains>
c002b62a:	83 c4 10             	add    $0x10,%esp
}
c002b62d:	c9                   	leave  
c002b62e:	c3                   	ret    

c002b62f <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b62f:	55                   	push   %ebp
c002b630:	89 e5                	mov    %esp,%ebp
c002b632:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002b635:	6a 01                	push   $0x1
c002b637:	ff 75 10             	pushl  0x10(%ebp)
c002b63a:	ff 75 0c             	pushl  0xc(%ebp)
c002b63d:	ff 75 08             	pushl  0x8(%ebp)
c002b640:	e8 07 ff ff ff       	call   c002b54c <bitmap_contains>
c002b645:	83 c4 10             	add    $0x10,%esp
c002b648:	0f b6 c0             	movzbl %al,%eax
c002b64b:	85 c0                	test   %eax,%eax
c002b64d:	0f 95 c0             	setne  %al
c002b650:	83 f0 01             	xor    $0x1,%eax
c002b653:	0f b6 c0             	movzbl %al,%eax
c002b656:	83 e0 01             	and    $0x1,%eax
}
c002b659:	c9                   	leave  
c002b65a:	c3                   	ret    

c002b65b <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b65b:	55                   	push   %ebp
c002b65c:	89 e5                	mov    %esp,%ebp
c002b65e:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002b661:	6a 00                	push   $0x0
c002b663:	ff 75 10             	pushl  0x10(%ebp)
c002b666:	ff 75 0c             	pushl  0xc(%ebp)
c002b669:	ff 75 08             	pushl  0x8(%ebp)
c002b66c:	e8 db fe ff ff       	call   c002b54c <bitmap_contains>
c002b671:	83 c4 10             	add    $0x10,%esp
c002b674:	0f b6 c0             	movzbl %al,%eax
c002b677:	85 c0                	test   %eax,%eax
c002b679:	0f 95 c0             	setne  %al
c002b67c:	83 f0 01             	xor    $0x1,%eax
c002b67f:	0f b6 c0             	movzbl %al,%eax
c002b682:	83 e0 01             	and    $0x1,%eax
}
c002b685:	c9                   	leave  
c002b686:	c3                   	ret    

c002b687 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b687:	55                   	push   %ebp
c002b688:	89 e5                	mov    %esp,%ebp
c002b68a:	83 ec 28             	sub    $0x28,%esp
c002b68d:	8b 45 14             	mov    0x14(%ebp),%eax
c002b690:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002b693:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b697:	75 21                	jne    c002b6ba <bitmap_scan+0x33>
c002b699:	83 ec 0c             	sub    $0xc,%esp
c002b69c:	68 7d 1a 03 c0       	push   $0xc0031a7d
c002b6a1:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b6a6:	68 3c 1b 03 c0       	push   $0xc0031b3c
c002b6ab:	68 2a 01 00 00       	push   $0x12a
c002b6b0:	68 63 1a 03 c0       	push   $0xc0031a63
c002b6b5:	e8 68 e9 ff ff       	call   c002a022 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b6ba:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6bd:	8b 00                	mov    (%eax),%eax
c002b6bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b6c2:	73 21                	jae    c002b6e5 <bitmap_scan+0x5e>
c002b6c4:	83 ec 0c             	sub    $0xc,%esp
c002b6c7:	68 98 1a 03 c0       	push   $0xc0031a98
c002b6cc:	68 4c 1a 03 c0       	push   $0xc0031a4c
c002b6d1:	68 3c 1b 03 c0       	push   $0xc0031b3c
c002b6d6:	68 2b 01 00 00       	push   $0x12b
c002b6db:	68 63 1a 03 c0       	push   $0xc0031a63
c002b6e0:	e8 3d e9 ff ff       	call   c002a022 <debug_panic>

  if (cnt <= b->bit_cnt) 
c002b6e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6e8:	8b 00                	mov    (%eax),%eax
c002b6ea:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b6ed:	72 51                	jb     c002b740 <bitmap_scan+0xb9>
    {
      size_t last = b->bit_cnt - cnt;
c002b6ef:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6f2:	8b 00                	mov    (%eax),%eax
c002b6f4:	2b 45 10             	sub    0x10(%ebp),%eax
c002b6f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002b6fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b6fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b700:	eb 36                	jmp    c002b738 <bitmap_scan+0xb1>
        if (!bitmap_contains (b, i, cnt, !value))
c002b702:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b706:	85 c0                	test   %eax,%eax
c002b708:	0f 95 c0             	setne  %al
c002b70b:	83 f0 01             	xor    $0x1,%eax
c002b70e:	0f b6 c0             	movzbl %al,%eax
c002b711:	83 e0 01             	and    $0x1,%eax
c002b714:	0f b6 c0             	movzbl %al,%eax
c002b717:	50                   	push   %eax
c002b718:	ff 75 10             	pushl  0x10(%ebp)
c002b71b:	ff 75 f4             	pushl  -0xc(%ebp)
c002b71e:	ff 75 08             	pushl  0x8(%ebp)
c002b721:	e8 26 fe ff ff       	call   c002b54c <bitmap_contains>
c002b726:	83 c4 10             	add    $0x10,%esp
c002b729:	83 f0 01             	xor    $0x1,%eax
c002b72c:	84 c0                	test   %al,%al
c002b72e:	74 05                	je     c002b735 <bitmap_scan+0xae>
          return i; 
c002b730:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b733:	eb 10                	jmp    c002b745 <bitmap_scan+0xbe>
      for (i = start; i <= last; i++)
c002b735:	ff 45 f4             	incl   -0xc(%ebp)
c002b738:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b73b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b73e:	76 c2                	jbe    c002b702 <bitmap_scan+0x7b>
    }
  return BITMAP_ERROR;
c002b740:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002b745:	c9                   	leave  
c002b746:	c3                   	ret    

c002b747 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002b747:	55                   	push   %ebp
c002b748:	89 e5                	mov    %esp,%ebp
c002b74a:	83 ec 28             	sub    $0x28,%esp
c002b74d:	8b 45 14             	mov    0x14(%ebp),%eax
c002b750:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002b753:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b757:	50                   	push   %eax
c002b758:	ff 75 10             	pushl  0x10(%ebp)
c002b75b:	ff 75 0c             	pushl  0xc(%ebp)
c002b75e:	ff 75 08             	pushl  0x8(%ebp)
c002b761:	e8 21 ff ff ff       	call   c002b687 <bitmap_scan>
c002b766:	83 c4 10             	add    $0x10,%esp
c002b769:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002b76c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002b770:	74 27                	je     c002b799 <bitmap_scan_and_flip+0x52>
    bitmap_set_multiple (b, idx, cnt, !value);
c002b772:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b776:	85 c0                	test   %eax,%eax
c002b778:	0f 95 c0             	setne  %al
c002b77b:	83 f0 01             	xor    $0x1,%eax
c002b77e:	0f b6 c0             	movzbl %al,%eax
c002b781:	83 e0 01             	and    $0x1,%eax
c002b784:	0f b6 c0             	movzbl %al,%eax
c002b787:	50                   	push   %eax
c002b788:	ff 75 10             	pushl  0x10(%ebp)
c002b78b:	ff 75 f4             	pushl  -0xc(%ebp)
c002b78e:	ff 75 08             	pushl  0x8(%ebp)
c002b791:	e8 24 fc ff ff       	call   c002b3ba <bitmap_set_multiple>
c002b796:	83 c4 10             	add    $0x10,%esp
  return idx;
c002b799:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b79c:	c9                   	leave  
c002b79d:	c3                   	ret    

c002b79e <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002b79e:	55                   	push   %ebp
c002b79f:	89 e5                	mov    %esp,%ebp
c002b7a1:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002b7a4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7a7:	8b 00                	mov    (%eax),%eax
c002b7a9:	50                   	push   %eax
c002b7aa:	e8 a8 f8 ff ff       	call   c002b057 <byte_cnt>
c002b7af:	83 c4 04             	add    $0x4,%esp
c002b7b2:	89 c2                	mov    %eax,%edx
c002b7b4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7b7:	8b 40 04             	mov    0x4(%eax),%eax
c002b7ba:	6a 00                	push   $0x0
c002b7bc:	52                   	push   %edx
c002b7bd:	50                   	push   %eax
c002b7be:	6a 00                	push   $0x0
c002b7c0:	e8 c3 ce ff ff       	call   c0028688 <hex_dump>
c002b7c5:	83 c4 10             	add    $0x10,%esp
}
c002b7c8:	90                   	nop
c002b7c9:	c9                   	leave  
c002b7ca:	c3                   	ret    

c002b7cb <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002b7cb:	55                   	push   %ebp
c002b7cc:	89 e5                	mov    %esp,%ebp
c002b7ce:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002b7d1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002b7da:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7dd:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002b7e4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7e7:	8b 40 04             	mov    0x4(%eax),%eax
c002b7ea:	c1 e0 04             	shl    $0x4,%eax
c002b7ed:	83 ec 0c             	sub    $0xc,%esp
c002b7f0:	50                   	push   %eax
c002b7f1:	e8 cf 84 ff ff       	call   c0023cc5 <malloc>
c002b7f6:	83 c4 10             	add    $0x10,%esp
c002b7f9:	89 c2                	mov    %eax,%edx
c002b7fb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7fe:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002b801:	8b 45 08             	mov    0x8(%ebp),%eax
c002b804:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b807:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002b80a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b80d:	8b 55 10             	mov    0x10(%ebp),%edx
c002b810:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002b813:	8b 45 08             	mov    0x8(%ebp),%eax
c002b816:	8b 55 14             	mov    0x14(%ebp),%edx
c002b819:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002b81c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b81f:	8b 40 08             	mov    0x8(%eax),%eax
c002b822:	85 c0                	test   %eax,%eax
c002b824:	74 14                	je     c002b83a <hash_init+0x6f>
    {
      hash_clear (h, NULL);
c002b826:	83 ec 08             	sub    $0x8,%esp
c002b829:	6a 00                	push   $0x0
c002b82b:	ff 75 08             	pushl  0x8(%ebp)
c002b82e:	e8 0b 00 00 00       	call   c002b83e <hash_clear>
c002b833:	83 c4 10             	add    $0x10,%esp
      return true;
c002b836:	b0 01                	mov    $0x1,%al
c002b838:	eb 02                	jmp    c002b83c <hash_init+0x71>
    }
  else
    return false;
c002b83a:	b0 00                	mov    $0x0,%al
}
c002b83c:	c9                   	leave  
c002b83d:	c3                   	ret    

c002b83e <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002b83e:	55                   	push   %ebp
c002b83f:	89 e5                	mov    %esp,%ebp
c002b841:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002b844:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b84b:	eb 71                	jmp    c002b8be <hash_clear+0x80>
    {
      struct list *bucket = &h->buckets[i];
c002b84d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b850:	8b 40 08             	mov    0x8(%eax),%eax
c002b853:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b856:	c1 e2 04             	shl    $0x4,%edx
c002b859:	01 d0                	add    %edx,%eax
c002b85b:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002b85e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b862:	74 49                	je     c002b8ad <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002b864:	eb 32                	jmp    c002b898 <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002b866:	83 ec 0c             	sub    $0xc,%esp
c002b869:	ff 75 f0             	pushl  -0x10(%ebp)
c002b86c:	e8 81 ee ff ff       	call   c002a6f2 <list_pop_front>
c002b871:	83 c4 10             	add    $0x10,%esp
c002b874:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002b877:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b87a:	83 c0 04             	add    $0x4,%eax
c002b87d:	83 e8 04             	sub    $0x4,%eax
c002b880:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002b883:	8b 45 08             	mov    0x8(%ebp),%eax
c002b886:	8b 40 14             	mov    0x14(%eax),%eax
c002b889:	83 ec 08             	sub    $0x8,%esp
c002b88c:	50                   	push   %eax
c002b88d:	ff 75 e8             	pushl  -0x18(%ebp)
c002b890:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b893:	ff d0                	call   *%eax
c002b895:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002b898:	83 ec 0c             	sub    $0xc,%esp
c002b89b:	ff 75 f0             	pushl  -0x10(%ebp)
c002b89e:	e8 77 ef ff ff       	call   c002a81a <list_empty>
c002b8a3:	83 c4 10             	add    $0x10,%esp
c002b8a6:	83 f0 01             	xor    $0x1,%eax
c002b8a9:	84 c0                	test   %al,%al
c002b8ab:	75 b9                	jne    c002b866 <hash_clear+0x28>
          }

      list_init (bucket); 
c002b8ad:	83 ec 0c             	sub    $0xc,%esp
c002b8b0:	ff 75 f0             	pushl  -0x10(%ebp)
c002b8b3:	e8 db e9 ff ff       	call   c002a293 <list_init>
c002b8b8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
c002b8bb:	ff 45 f4             	incl   -0xc(%ebp)
c002b8be:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8c1:	8b 40 04             	mov    0x4(%eax),%eax
c002b8c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b8c7:	77 84                	ja     c002b84d <hash_clear+0xf>
    }    

  h->elem_cnt = 0;
c002b8c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002b8d2:	90                   	nop
c002b8d3:	c9                   	leave  
c002b8d4:	c3                   	ret    

c002b8d5 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002b8d5:	55                   	push   %ebp
c002b8d6:	89 e5                	mov    %esp,%ebp
c002b8d8:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002b8db:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b8df:	74 11                	je     c002b8f2 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002b8e1:	83 ec 08             	sub    $0x8,%esp
c002b8e4:	ff 75 0c             	pushl  0xc(%ebp)
c002b8e7:	ff 75 08             	pushl  0x8(%ebp)
c002b8ea:	e8 4f ff ff ff       	call   c002b83e <hash_clear>
c002b8ef:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002b8f2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8f5:	8b 40 08             	mov    0x8(%eax),%eax
c002b8f8:	83 ec 0c             	sub    $0xc,%esp
c002b8fb:	50                   	push   %eax
c002b8fc:	e8 d0 86 ff ff       	call   c0023fd1 <free>
c002b901:	83 c4 10             	add    $0x10,%esp
}
c002b904:	90                   	nop
c002b905:	c9                   	leave  
c002b906:	c3                   	ret    

c002b907 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002b907:	55                   	push   %ebp
c002b908:	89 e5                	mov    %esp,%ebp
c002b90a:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b90d:	83 ec 08             	sub    $0x8,%esp
c002b910:	ff 75 0c             	pushl  0xc(%ebp)
c002b913:	ff 75 08             	pushl  0x8(%ebp)
c002b916:	e8 7e 04 00 00       	call   c002bd99 <find_bucket>
c002b91b:	83 c4 10             	add    $0x10,%esp
c002b91e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b921:	83 ec 04             	sub    $0x4,%esp
c002b924:	ff 75 0c             	pushl  0xc(%ebp)
c002b927:	ff 75 f4             	pushl  -0xc(%ebp)
c002b92a:	ff 75 08             	pushl  0x8(%ebp)
c002b92d:	e8 a3 04 00 00       	call   c002bdd5 <find_elem>
c002b932:	83 c4 10             	add    $0x10,%esp
c002b935:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002b938:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b93c:	75 14                	jne    c002b952 <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002b93e:	83 ec 04             	sub    $0x4,%esp
c002b941:	ff 75 0c             	pushl  0xc(%ebp)
c002b944:	ff 75 f4             	pushl  -0xc(%ebp)
c002b947:	ff 75 08             	pushl  0x8(%ebp)
c002b94a:	e8 ee 06 00 00       	call   c002c03d <insert_elem>
c002b94f:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b952:	83 ec 0c             	sub    $0xc,%esp
c002b955:	ff 75 08             	pushl  0x8(%ebp)
c002b958:	e8 43 05 00 00       	call   c002bea0 <rehash>
c002b95d:	83 c4 10             	add    $0x10,%esp

  return old; 
c002b960:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b963:	c9                   	leave  
c002b964:	c3                   	ret    

c002b965 <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002b965:	55                   	push   %ebp
c002b966:	89 e5                	mov    %esp,%ebp
c002b968:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b96b:	83 ec 08             	sub    $0x8,%esp
c002b96e:	ff 75 0c             	pushl  0xc(%ebp)
c002b971:	ff 75 08             	pushl  0x8(%ebp)
c002b974:	e8 20 04 00 00       	call   c002bd99 <find_bucket>
c002b979:	83 c4 10             	add    $0x10,%esp
c002b97c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b97f:	83 ec 04             	sub    $0x4,%esp
c002b982:	ff 75 0c             	pushl  0xc(%ebp)
c002b985:	ff 75 f4             	pushl  -0xc(%ebp)
c002b988:	ff 75 08             	pushl  0x8(%ebp)
c002b98b:	e8 45 04 00 00       	call   c002bdd5 <find_elem>
c002b990:	83 c4 10             	add    $0x10,%esp
c002b993:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002b996:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b99a:	74 11                	je     c002b9ad <hash_replace+0x48>
    remove_elem (h, old);
c002b99c:	83 ec 08             	sub    $0x8,%esp
c002b99f:	ff 75 f0             	pushl  -0x10(%ebp)
c002b9a2:	ff 75 08             	pushl  0x8(%ebp)
c002b9a5:	e8 bb 06 00 00       	call   c002c065 <remove_elem>
c002b9aa:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002b9ad:	83 ec 04             	sub    $0x4,%esp
c002b9b0:	ff 75 0c             	pushl  0xc(%ebp)
c002b9b3:	ff 75 f4             	pushl  -0xc(%ebp)
c002b9b6:	ff 75 08             	pushl  0x8(%ebp)
c002b9b9:	e8 7f 06 00 00       	call   c002c03d <insert_elem>
c002b9be:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b9c1:	83 ec 0c             	sub    $0xc,%esp
c002b9c4:	ff 75 08             	pushl  0x8(%ebp)
c002b9c7:	e8 d4 04 00 00       	call   c002bea0 <rehash>
c002b9cc:	83 c4 10             	add    $0x10,%esp

  return old;
c002b9cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b9d2:	c9                   	leave  
c002b9d3:	c3                   	ret    

c002b9d4 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002b9d4:	55                   	push   %ebp
c002b9d5:	89 e5                	mov    %esp,%ebp
c002b9d7:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002b9da:	83 ec 08             	sub    $0x8,%esp
c002b9dd:	ff 75 0c             	pushl  0xc(%ebp)
c002b9e0:	ff 75 08             	pushl  0x8(%ebp)
c002b9e3:	e8 b1 03 00 00       	call   c002bd99 <find_bucket>
c002b9e8:	83 c4 10             	add    $0x10,%esp
c002b9eb:	83 ec 04             	sub    $0x4,%esp
c002b9ee:	ff 75 0c             	pushl  0xc(%ebp)
c002b9f1:	50                   	push   %eax
c002b9f2:	ff 75 08             	pushl  0x8(%ebp)
c002b9f5:	e8 db 03 00 00       	call   c002bdd5 <find_elem>
c002b9fa:	83 c4 10             	add    $0x10,%esp
}
c002b9fd:	c9                   	leave  
c002b9fe:	c3                   	ret    

c002b9ff <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002b9ff:	55                   	push   %ebp
c002ba00:	89 e5                	mov    %esp,%ebp
c002ba02:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002ba05:	83 ec 08             	sub    $0x8,%esp
c002ba08:	ff 75 0c             	pushl  0xc(%ebp)
c002ba0b:	ff 75 08             	pushl  0x8(%ebp)
c002ba0e:	e8 86 03 00 00       	call   c002bd99 <find_bucket>
c002ba13:	83 c4 10             	add    $0x10,%esp
c002ba16:	83 ec 04             	sub    $0x4,%esp
c002ba19:	ff 75 0c             	pushl  0xc(%ebp)
c002ba1c:	50                   	push   %eax
c002ba1d:	ff 75 08             	pushl  0x8(%ebp)
c002ba20:	e8 b0 03 00 00       	call   c002bdd5 <find_elem>
c002ba25:	83 c4 10             	add    $0x10,%esp
c002ba28:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002ba2b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ba2f:	74 1f                	je     c002ba50 <hash_delete+0x51>
    {
      remove_elem (h, found);
c002ba31:	83 ec 08             	sub    $0x8,%esp
c002ba34:	ff 75 f4             	pushl  -0xc(%ebp)
c002ba37:	ff 75 08             	pushl  0x8(%ebp)
c002ba3a:	e8 26 06 00 00       	call   c002c065 <remove_elem>
c002ba3f:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002ba42:	83 ec 0c             	sub    $0xc,%esp
c002ba45:	ff 75 08             	pushl  0x8(%ebp)
c002ba48:	e8 53 04 00 00       	call   c002bea0 <rehash>
c002ba4d:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002ba50:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ba53:	c9                   	leave  
c002ba54:	c3                   	ret    

c002ba55 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002ba55:	55                   	push   %ebp
c002ba56:	89 e5                	mov    %esp,%ebp
c002ba58:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002ba5b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ba5f:	75 21                	jne    c002ba82 <hash_apply+0x2d>
c002ba61:	83 ec 0c             	sub    $0xc,%esp
c002ba64:	68 48 1b 03 c0       	push   $0xc0031b48
c002ba69:	68 57 1b 03 c0       	push   $0xc0031b57
c002ba6e:	68 b0 1b 03 c0       	push   $0xc0031bb0
c002ba73:	68 a7 00 00 00       	push   $0xa7
c002ba78:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002ba7d:	e8 a0 e5 ff ff       	call   c002a022 <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002ba82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ba89:	eb 6d                	jmp    c002baf8 <hash_apply+0xa3>
    {
      struct list *bucket = &h->buckets[i];
c002ba8b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba8e:	8b 40 08             	mov    0x8(%eax),%eax
c002ba91:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ba94:	c1 e2 04             	shl    $0x4,%edx
c002ba97:	01 d0                	add    %edx,%eax
c002ba99:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002ba9c:	83 ec 0c             	sub    $0xc,%esp
c002ba9f:	ff 75 ec             	pushl  -0x14(%ebp)
c002baa2:	e8 41 e8 ff ff       	call   c002a2e8 <list_begin>
c002baa7:	83 c4 10             	add    $0x10,%esp
c002baaa:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002baad:	eb 33                	jmp    c002bae2 <hash_apply+0x8d>
        {
          next = list_next (elem);
c002baaf:	83 ec 0c             	sub    $0xc,%esp
c002bab2:	ff 75 f0             	pushl  -0x10(%ebp)
c002bab5:	e8 60 e8 ff ff       	call   c002a31a <list_next>
c002baba:	83 c4 10             	add    $0x10,%esp
c002babd:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002bac0:	8b 45 08             	mov    0x8(%ebp),%eax
c002bac3:	8b 40 14             	mov    0x14(%eax),%eax
c002bac6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bac9:	83 c2 04             	add    $0x4,%edx
c002bacc:	83 ea 04             	sub    $0x4,%edx
c002bacf:	83 ec 08             	sub    $0x8,%esp
c002bad2:	50                   	push   %eax
c002bad3:	52                   	push   %edx
c002bad4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bad7:	ff d0                	call   *%eax
c002bad9:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002badc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002badf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002bae2:	83 ec 0c             	sub    $0xc,%esp
c002bae5:	ff 75 ec             	pushl  -0x14(%ebp)
c002bae8:	e8 77 e8 ff ff       	call   c002a364 <list_end>
c002baed:	83 c4 10             	add    $0x10,%esp
c002baf0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002baf3:	75 ba                	jne    c002baaf <hash_apply+0x5a>
  for (i = 0; i < h->bucket_cnt; i++) 
c002baf5:	ff 45 f4             	incl   -0xc(%ebp)
c002baf8:	8b 45 08             	mov    0x8(%ebp),%eax
c002bafb:	8b 40 04             	mov    0x4(%eax),%eax
c002bafe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bb01:	77 88                	ja     c002ba8b <hash_apply+0x36>
        }
    }
}
c002bb03:	90                   	nop
c002bb04:	c9                   	leave  
c002bb05:	c3                   	ret    

c002bb06 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002bb06:	55                   	push   %ebp
c002bb07:	89 e5                	mov    %esp,%ebp
c002bb09:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002bb0c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bb10:	75 21                	jne    c002bb33 <hash_first+0x2d>
c002bb12:	83 ec 0c             	sub    $0xc,%esp
c002bb15:	68 86 1b 03 c0       	push   $0xc0031b86
c002bb1a:	68 57 1b 03 c0       	push   $0xc0031b57
c002bb1f:	68 bc 1b 03 c0       	push   $0xc0031bbc
c002bb24:	68 ca 00 00 00       	push   $0xca
c002bb29:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002bb2e:	e8 ef e4 ff ff       	call   c002a022 <debug_panic>
  ASSERT (h != NULL);
c002bb33:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002bb37:	75 21                	jne    c002bb5a <hash_first+0x54>
c002bb39:	83 ec 0c             	sub    $0xc,%esp
c002bb3c:	68 90 1b 03 c0       	push   $0xc0031b90
c002bb41:	68 57 1b 03 c0       	push   $0xc0031b57
c002bb46:	68 bc 1b 03 c0       	push   $0xc0031bbc
c002bb4b:	68 cb 00 00 00       	push   $0xcb
c002bb50:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002bb55:	e8 c8 e4 ff ff       	call   c002a022 <debug_panic>

  i->hash = h;
c002bb5a:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb5d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bb60:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002bb62:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb65:	8b 00                	mov    (%eax),%eax
c002bb67:	8b 50 08             	mov    0x8(%eax),%edx
c002bb6a:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb6d:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002bb70:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb73:	8b 40 04             	mov    0x4(%eax),%eax
c002bb76:	83 ec 0c             	sub    $0xc,%esp
c002bb79:	50                   	push   %eax
c002bb7a:	e8 c4 e8 ff ff       	call   c002a443 <list_head>
c002bb7f:	83 c4 10             	add    $0x10,%esp
c002bb82:	83 c0 04             	add    $0x4,%eax
c002bb85:	8d 50 fc             	lea    -0x4(%eax),%edx
c002bb88:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb8b:	89 50 08             	mov    %edx,0x8(%eax)
}
c002bb8e:	90                   	nop
c002bb8f:	c9                   	leave  
c002bb90:	c3                   	ret    

c002bb91 <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002bb91:	55                   	push   %ebp
c002bb92:	89 e5                	mov    %esp,%ebp
c002bb94:	53                   	push   %ebx
c002bb95:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002bb98:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bb9c:	75 21                	jne    c002bbbf <hash_next+0x2e>
c002bb9e:	83 ec 0c             	sub    $0xc,%esp
c002bba1:	68 86 1b 03 c0       	push   $0xc0031b86
c002bba6:	68 57 1b 03 c0       	push   $0xc0031b57
c002bbab:	68 c8 1b 03 c0       	push   $0xc0031bc8
c002bbb0:	68 dd 00 00 00       	push   $0xdd
c002bbb5:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002bbba:	e8 63 e4 ff ff       	call   c002a022 <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002bbbf:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbc2:	8b 40 08             	mov    0x8(%eax),%eax
c002bbc5:	83 ec 0c             	sub    $0xc,%esp
c002bbc8:	50                   	push   %eax
c002bbc9:	e8 4c e7 ff ff       	call   c002a31a <list_next>
c002bbce:	83 c4 10             	add    $0x10,%esp
c002bbd1:	83 c0 04             	add    $0x4,%eax
c002bbd4:	8d 50 fc             	lea    -0x4(%eax),%edx
c002bbd7:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbda:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002bbdd:	eb 58                	jmp    c002bc37 <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002bbdf:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbe2:	8b 40 04             	mov    0x4(%eax),%eax
c002bbe5:	8d 50 10             	lea    0x10(%eax),%edx
c002bbe8:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbeb:	89 50 04             	mov    %edx,0x4(%eax)
c002bbee:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbf1:	8b 50 04             	mov    0x4(%eax),%edx
c002bbf4:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbf7:	8b 00                	mov    (%eax),%eax
c002bbf9:	8b 48 08             	mov    0x8(%eax),%ecx
c002bbfc:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbff:	8b 00                	mov    (%eax),%eax
c002bc01:	8b 40 04             	mov    0x4(%eax),%eax
c002bc04:	c1 e0 04             	shl    $0x4,%eax
c002bc07:	01 c8                	add    %ecx,%eax
c002bc09:	39 c2                	cmp    %eax,%edx
c002bc0b:	72 0c                	jb     c002bc19 <hash_next+0x88>
        {
          i->elem = NULL;
c002bc0d:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc10:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002bc17:	eb 40                	jmp    c002bc59 <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002bc19:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc1c:	8b 40 04             	mov    0x4(%eax),%eax
c002bc1f:	83 ec 0c             	sub    $0xc,%esp
c002bc22:	50                   	push   %eax
c002bc23:	e8 c0 e6 ff ff       	call   c002a2e8 <list_begin>
c002bc28:	83 c4 10             	add    $0x10,%esp
c002bc2b:	83 c0 04             	add    $0x4,%eax
c002bc2e:	8d 50 fc             	lea    -0x4(%eax),%edx
c002bc31:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc34:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002bc37:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc3a:	8b 58 08             	mov    0x8(%eax),%ebx
c002bc3d:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc40:	8b 40 04             	mov    0x4(%eax),%eax
c002bc43:	83 ec 0c             	sub    $0xc,%esp
c002bc46:	50                   	push   %eax
c002bc47:	e8 18 e7 ff ff       	call   c002a364 <list_end>
c002bc4c:	83 c4 10             	add    $0x10,%esp
c002bc4f:	83 c0 04             	add    $0x4,%eax
c002bc52:	83 e8 04             	sub    $0x4,%eax
c002bc55:	39 c3                	cmp    %eax,%ebx
c002bc57:	74 86                	je     c002bbdf <hash_next+0x4e>
    }
  
  return i->elem;
c002bc59:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc5c:	8b 40 08             	mov    0x8(%eax),%eax
}
c002bc5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bc62:	c9                   	leave  
c002bc63:	c3                   	ret    

c002bc64 <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002bc64:	55                   	push   %ebp
c002bc65:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002bc67:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc6a:	8b 40 08             	mov    0x8(%eax),%eax
}
c002bc6d:	5d                   	pop    %ebp
c002bc6e:	c3                   	ret    

c002bc6f <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002bc6f:	55                   	push   %ebp
c002bc70:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002bc72:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc75:	8b 00                	mov    (%eax),%eax
}
c002bc77:	5d                   	pop    %ebp
c002bc78:	c3                   	ret    

c002bc79 <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002bc79:	55                   	push   %ebp
c002bc7a:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002bc7c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc7f:	8b 00                	mov    (%eax),%eax
c002bc81:	85 c0                	test   %eax,%eax
c002bc83:	0f 94 c0             	sete   %al
}
c002bc86:	5d                   	pop    %ebp
c002bc87:	c3                   	ret    

c002bc88 <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002bc88:	55                   	push   %ebp
c002bc89:	89 e5                	mov    %esp,%ebp
c002bc8b:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002bc8e:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc91:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002bc94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002bc98:	75 21                	jne    c002bcbb <hash_bytes+0x33>
c002bc9a:	83 ec 0c             	sub    $0xc,%esp
c002bc9d:	68 9a 1b 03 c0       	push   $0xc0031b9a
c002bca2:	68 57 1b 03 c0       	push   $0xc0031b57
c002bca7:	68 d4 1b 03 c0       	push   $0xc0031bd4
c002bcac:	68 10 01 00 00       	push   $0x110
c002bcb1:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002bcb6:	e8 67 e3 ff ff       	call   c002a022 <debug_panic>

  hash = FNV_32_BASIS;
c002bcbb:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002bcc2:	eb 30                	jmp    c002bcf4 <hash_bytes+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002bcc4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bcc7:	89 d0                	mov    %edx,%eax
c002bcc9:	c1 e0 10             	shl    $0x10,%eax
c002bccc:	01 d0                	add    %edx,%eax
c002bcce:	01 c0                	add    %eax,%eax
c002bcd0:	01 d0                	add    %edx,%eax
c002bcd2:	c1 e0 03             	shl    $0x3,%eax
c002bcd5:	01 d0                	add    %edx,%eax
c002bcd7:	c1 e0 03             	shl    $0x3,%eax
c002bcda:	01 d0                	add    %edx,%eax
c002bcdc:	01 c0                	add    %eax,%eax
c002bcde:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002bce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bce4:	8d 50 01             	lea    0x1(%eax),%edx
c002bce7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002bcea:	8a 00                	mov    (%eax),%al
c002bcec:	0f b6 c0             	movzbl %al,%eax
c002bcef:	31 c8                	xor    %ecx,%eax
c002bcf1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (size-- > 0)
c002bcf4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bcf7:	8d 50 ff             	lea    -0x1(%eax),%edx
c002bcfa:	89 55 0c             	mov    %edx,0xc(%ebp)
c002bcfd:	85 c0                	test   %eax,%eax
c002bcff:	75 c3                	jne    c002bcc4 <hash_bytes+0x3c>

  return hash;
c002bd01:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002bd04:	c9                   	leave  
c002bd05:	c3                   	ret    

c002bd06 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002bd06:	55                   	push   %ebp
c002bd07:	89 e5                	mov    %esp,%ebp
c002bd09:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002bd0c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bd0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002bd12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002bd16:	75 21                	jne    c002bd39 <hash_string+0x33>
c002bd18:	83 ec 0c             	sub    $0xc,%esp
c002bd1b:	68 a6 1b 03 c0       	push   $0xc0031ba6
c002bd20:	68 57 1b 03 c0       	push   $0xc0031b57
c002bd25:	68 e0 1b 03 c0       	push   $0xc0031be0
c002bd2a:	68 20 01 00 00       	push   $0x120
c002bd2f:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002bd34:	e8 e9 e2 ff ff       	call   c002a022 <debug_panic>

  hash = FNV_32_BASIS;
c002bd39:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002bd40:	eb 30                	jmp    c002bd72 <hash_string+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002bd42:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bd45:	89 d0                	mov    %edx,%eax
c002bd47:	c1 e0 10             	shl    $0x10,%eax
c002bd4a:	01 d0                	add    %edx,%eax
c002bd4c:	01 c0                	add    %eax,%eax
c002bd4e:	01 d0                	add    %edx,%eax
c002bd50:	c1 e0 03             	shl    $0x3,%eax
c002bd53:	01 d0                	add    %edx,%eax
c002bd55:	c1 e0 03             	shl    $0x3,%eax
c002bd58:	01 d0                	add    %edx,%eax
c002bd5a:	01 c0                	add    %eax,%eax
c002bd5c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002bd5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bd62:	8d 50 01             	lea    0x1(%eax),%edx
c002bd65:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002bd68:	8a 00                	mov    (%eax),%al
c002bd6a:	0f b6 c0             	movzbl %al,%eax
c002bd6d:	31 c8                	xor    %ecx,%eax
c002bd6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (*s != '\0')
c002bd72:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bd75:	8a 00                	mov    (%eax),%al
c002bd77:	84 c0                	test   %al,%al
c002bd79:	75 c7                	jne    c002bd42 <hash_string+0x3c>

  return hash;
c002bd7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002bd7e:	c9                   	leave  
c002bd7f:	c3                   	ret    

c002bd80 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002bd80:	55                   	push   %ebp
c002bd81:	89 e5                	mov    %esp,%ebp
c002bd83:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002bd86:	83 ec 08             	sub    $0x8,%esp
c002bd89:	6a 04                	push   $0x4
c002bd8b:	8d 45 08             	lea    0x8(%ebp),%eax
c002bd8e:	50                   	push   %eax
c002bd8f:	e8 f4 fe ff ff       	call   c002bc88 <hash_bytes>
c002bd94:	83 c4 10             	add    $0x10,%esp
}
c002bd97:	c9                   	leave  
c002bd98:	c3                   	ret    

c002bd99 <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002bd99:	55                   	push   %ebp
c002bd9a:	89 e5                	mov    %esp,%ebp
c002bd9c:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002bd9f:	8b 45 08             	mov    0x8(%ebp),%eax
c002bda2:	8b 40 0c             	mov    0xc(%eax),%eax
c002bda5:	8b 55 08             	mov    0x8(%ebp),%edx
c002bda8:	8b 52 14             	mov    0x14(%edx),%edx
c002bdab:	83 ec 08             	sub    $0x8,%esp
c002bdae:	52                   	push   %edx
c002bdaf:	ff 75 0c             	pushl  0xc(%ebp)
c002bdb2:	ff d0                	call   *%eax
c002bdb4:	83 c4 10             	add    $0x10,%esp
c002bdb7:	89 c2                	mov    %eax,%edx
c002bdb9:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdbc:	8b 40 04             	mov    0x4(%eax),%eax
c002bdbf:	48                   	dec    %eax
c002bdc0:	21 d0                	and    %edx,%eax
c002bdc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002bdc5:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdc8:	8b 40 08             	mov    0x8(%eax),%eax
c002bdcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bdce:	c1 e2 04             	shl    $0x4,%edx
c002bdd1:	01 d0                	add    %edx,%eax
}
c002bdd3:	c9                   	leave  
c002bdd4:	c3                   	ret    

c002bdd5 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002bdd5:	55                   	push   %ebp
c002bdd6:	89 e5                	mov    %esp,%ebp
c002bdd8:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002bddb:	83 ec 0c             	sub    $0xc,%esp
c002bdde:	ff 75 0c             	pushl  0xc(%ebp)
c002bde1:	e8 02 e5 ff ff       	call   c002a2e8 <list_begin>
c002bde6:	83 c4 10             	add    $0x10,%esp
c002bde9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002bdec:	eb 66                	jmp    c002be54 <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002bdee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bdf1:	83 c0 04             	add    $0x4,%eax
c002bdf4:	83 e8 04             	sub    $0x4,%eax
c002bdf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002bdfa:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdfd:	8b 40 10             	mov    0x10(%eax),%eax
c002be00:	8b 55 08             	mov    0x8(%ebp),%edx
c002be03:	8b 52 14             	mov    0x14(%edx),%edx
c002be06:	83 ec 04             	sub    $0x4,%esp
c002be09:	52                   	push   %edx
c002be0a:	ff 75 10             	pushl  0x10(%ebp)
c002be0d:	ff 75 f0             	pushl  -0x10(%ebp)
c002be10:	ff d0                	call   *%eax
c002be12:	83 c4 10             	add    $0x10,%esp
c002be15:	83 f0 01             	xor    $0x1,%eax
c002be18:	84 c0                	test   %al,%al
c002be1a:	74 27                	je     c002be43 <find_elem+0x6e>
c002be1c:	8b 45 08             	mov    0x8(%ebp),%eax
c002be1f:	8b 40 10             	mov    0x10(%eax),%eax
c002be22:	8b 55 08             	mov    0x8(%ebp),%edx
c002be25:	8b 52 14             	mov    0x14(%edx),%edx
c002be28:	83 ec 04             	sub    $0x4,%esp
c002be2b:	52                   	push   %edx
c002be2c:	ff 75 f0             	pushl  -0x10(%ebp)
c002be2f:	ff 75 10             	pushl  0x10(%ebp)
c002be32:	ff d0                	call   *%eax
c002be34:	83 c4 10             	add    $0x10,%esp
c002be37:	83 f0 01             	xor    $0x1,%eax
c002be3a:	84 c0                	test   %al,%al
c002be3c:	74 05                	je     c002be43 <find_elem+0x6e>
        return hi; 
c002be3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002be41:	eb 29                	jmp    c002be6c <find_elem+0x97>
  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002be43:	83 ec 0c             	sub    $0xc,%esp
c002be46:	ff 75 f4             	pushl  -0xc(%ebp)
c002be49:	e8 cc e4 ff ff       	call   c002a31a <list_next>
c002be4e:	83 c4 10             	add    $0x10,%esp
c002be51:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002be54:	83 ec 0c             	sub    $0xc,%esp
c002be57:	ff 75 0c             	pushl  0xc(%ebp)
c002be5a:	e8 05 e5 ff ff       	call   c002a364 <list_end>
c002be5f:	83 c4 10             	add    $0x10,%esp
c002be62:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002be65:	75 87                	jne    c002bdee <find_elem+0x19>
    }
  return NULL;
c002be67:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002be6c:	c9                   	leave  
c002be6d:	c3                   	ret    

c002be6e <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002be6e:	55                   	push   %ebp
c002be6f:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002be71:	8b 45 08             	mov    0x8(%ebp),%eax
c002be74:	48                   	dec    %eax
c002be75:	23 45 08             	and    0x8(%ebp),%eax
}
c002be78:	5d                   	pop    %ebp
c002be79:	c3                   	ret    

c002be7a <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002be7a:	55                   	push   %ebp
c002be7b:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002be7d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002be81:	74 16                	je     c002be99 <is_power_of_2+0x1f>
c002be83:	ff 75 08             	pushl  0x8(%ebp)
c002be86:	e8 e3 ff ff ff       	call   c002be6e <turn_off_least_1bit>
c002be8b:	83 c4 04             	add    $0x4,%esp
c002be8e:	85 c0                	test   %eax,%eax
c002be90:	75 07                	jne    c002be99 <is_power_of_2+0x1f>
c002be92:	b8 01 00 00 00       	mov    $0x1,%eax
c002be97:	eb 05                	jmp    c002be9e <is_power_of_2+0x24>
c002be99:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002be9e:	c9                   	leave  
c002be9f:	c3                   	ret    

c002bea0 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002bea0:	55                   	push   %ebp
c002bea1:	89 e5                	mov    %esp,%ebp
c002bea3:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002bea6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002beaa:	75 21                	jne    c002becd <rehash+0x2d>
c002beac:	83 ec 0c             	sub    $0xc,%esp
c002beaf:	68 90 1b 03 c0       	push   $0xc0031b90
c002beb4:	68 57 1b 03 c0       	push   $0xc0031b57
c002beb9:	68 ec 1b 03 c0       	push   $0xc0031bec
c002bebe:	68 66 01 00 00       	push   $0x166
c002bec3:	68 6e 1b 03 c0       	push   $0xc0031b6e
c002bec8:	e8 55 e1 ff ff       	call   c002a022 <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002becd:	8b 45 08             	mov    0x8(%ebp),%eax
c002bed0:	8b 40 08             	mov    0x8(%eax),%eax
c002bed3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002bed6:	8b 45 08             	mov    0x8(%ebp),%eax
c002bed9:	8b 40 04             	mov    0x4(%eax),%eax
c002bedc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002bedf:	8b 45 08             	mov    0x8(%ebp),%eax
c002bee2:	8b 00                	mov    (%eax),%eax
c002bee4:	d1 e8                	shr    %eax
c002bee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002bee9:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002beed:	77 1a                	ja     c002bf09 <rehash+0x69>
    new_bucket_cnt = 4;
c002beef:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002bef6:	eb 11                	jmp    c002bf09 <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002bef8:	83 ec 0c             	sub    $0xc,%esp
c002befb:	ff 75 f4             	pushl  -0xc(%ebp)
c002befe:	e8 6b ff ff ff       	call   c002be6e <turn_off_least_1bit>
c002bf03:	83 c4 10             	add    $0x10,%esp
c002bf06:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002bf09:	83 ec 0c             	sub    $0xc,%esp
c002bf0c:	ff 75 f4             	pushl  -0xc(%ebp)
c002bf0f:	e8 66 ff ff ff       	call   c002be7a <is_power_of_2>
c002bf14:	83 c4 10             	add    $0x10,%esp
c002bf17:	85 c0                	test   %eax,%eax
c002bf19:	74 dd                	je     c002bef8 <rehash+0x58>

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002bf1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf1e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002bf21:	0f 84 10 01 00 00    	je     c002c037 <rehash+0x197>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002bf27:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf2a:	c1 e0 04             	shl    $0x4,%eax
c002bf2d:	83 ec 0c             	sub    $0xc,%esp
c002bf30:	50                   	push   %eax
c002bf31:	e8 8f 7d ff ff       	call   c0023cc5 <malloc>
c002bf36:	83 c4 10             	add    $0x10,%esp
c002bf39:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002bf3c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002bf40:	0f 84 f4 00 00 00    	je     c002c03a <rehash+0x19a>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002bf46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002bf4d:	eb 1c                	jmp    c002bf6b <rehash+0xcb>
    list_init (&new_buckets[i]);
c002bf4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf52:	c1 e0 04             	shl    $0x4,%eax
c002bf55:	89 c2                	mov    %eax,%edx
c002bf57:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bf5a:	01 d0                	add    %edx,%eax
c002bf5c:	83 ec 0c             	sub    $0xc,%esp
c002bf5f:	50                   	push   %eax
c002bf60:	e8 2e e3 ff ff       	call   c002a293 <list_init>
c002bf65:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < new_bucket_cnt; i++) 
c002bf68:	ff 45 f0             	incl   -0x10(%ebp)
c002bf6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf6e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bf71:	72 dc                	jb     c002bf4f <rehash+0xaf>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002bf73:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf76:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002bf79:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002bf7c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf7f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bf82:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002bf85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002bf8c:	e9 8a 00 00 00       	jmp    c002c01b <rehash+0x17b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002bf91:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf94:	c1 e0 04             	shl    $0x4,%eax
c002bf97:	89 c2                	mov    %eax,%edx
c002bf99:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bf9c:	01 d0                	add    %edx,%eax
c002bf9e:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002bfa1:	83 ec 0c             	sub    $0xc,%esp
c002bfa4:	ff 75 dc             	pushl  -0x24(%ebp)
c002bfa7:	e8 3c e3 ff ff       	call   c002a2e8 <list_begin>
c002bfac:	83 c4 10             	add    $0x10,%esp
c002bfaf:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002bfb2:	eb 51                	jmp    c002c005 <rehash+0x165>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002bfb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bfb7:	83 c0 04             	add    $0x4,%eax
c002bfba:	83 e8 04             	sub    $0x4,%eax
          struct list *new_bucket
c002bfbd:	83 ec 08             	sub    $0x8,%esp
c002bfc0:	50                   	push   %eax
c002bfc1:	ff 75 08             	pushl  0x8(%ebp)
c002bfc4:	e8 d0 fd ff ff       	call   c002bd99 <find_bucket>
c002bfc9:	83 c4 10             	add    $0x10,%esp
c002bfcc:	89 45 d8             	mov    %eax,-0x28(%ebp)
          next = list_next (elem);
c002bfcf:	83 ec 0c             	sub    $0xc,%esp
c002bfd2:	ff 75 ec             	pushl  -0x14(%ebp)
c002bfd5:	e8 40 e3 ff ff       	call   c002a31a <list_next>
c002bfda:	83 c4 10             	add    $0x10,%esp
c002bfdd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002bfe0:	83 ec 0c             	sub    $0xc,%esp
c002bfe3:	ff 75 ec             	pushl  -0x14(%ebp)
c002bfe6:	e8 ae e6 ff ff       	call   c002a699 <list_remove>
c002bfeb:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002bfee:	83 ec 08             	sub    $0x8,%esp
c002bff1:	ff 75 ec             	pushl  -0x14(%ebp)
c002bff4:	ff 75 d8             	pushl  -0x28(%ebp)
c002bff7:	e8 51 e6 ff ff       	call   c002a64d <list_push_front>
c002bffc:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002bfff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002c002:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002c005:	83 ec 0c             	sub    $0xc,%esp
c002c008:	ff 75 dc             	pushl  -0x24(%ebp)
c002c00b:	e8 54 e3 ff ff       	call   c002a364 <list_end>
c002c010:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (old_bucket);
c002c013:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002c016:	75 9c                	jne    c002bfb4 <rehash+0x114>
  for (i = 0; i < old_bucket_cnt; i++) 
c002c018:	ff 45 f0             	incl   -0x10(%ebp)
c002c01b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c01e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002c021:	0f 82 6a ff ff ff    	jb     c002bf91 <rehash+0xf1>
        }
    }

  free (old_buckets);
c002c027:	83 ec 0c             	sub    $0xc,%esp
c002c02a:	ff 75 e8             	pushl  -0x18(%ebp)
c002c02d:	e8 9f 7f ff ff       	call   c0023fd1 <free>
c002c032:	83 c4 10             	add    $0x10,%esp
c002c035:	eb 04                	jmp    c002c03b <rehash+0x19b>
    return;
c002c037:	90                   	nop
c002c038:	eb 01                	jmp    c002c03b <rehash+0x19b>
      return;
c002c03a:	90                   	nop
}
c002c03b:	c9                   	leave  
c002c03c:	c3                   	ret    

c002c03d <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002c03d:	55                   	push   %ebp
c002c03e:	89 e5                	mov    %esp,%ebp
c002c040:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002c043:	8b 45 08             	mov    0x8(%ebp),%eax
c002c046:	8b 00                	mov    (%eax),%eax
c002c048:	8d 50 01             	lea    0x1(%eax),%edx
c002c04b:	8b 45 08             	mov    0x8(%ebp),%eax
c002c04e:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002c050:	8b 45 10             	mov    0x10(%ebp),%eax
c002c053:	83 ec 08             	sub    $0x8,%esp
c002c056:	50                   	push   %eax
c002c057:	ff 75 0c             	pushl  0xc(%ebp)
c002c05a:	e8 ee e5 ff ff       	call   c002a64d <list_push_front>
c002c05f:	83 c4 10             	add    $0x10,%esp
}
c002c062:	90                   	nop
c002c063:	c9                   	leave  
c002c064:	c3                   	ret    

c002c065 <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002c065:	55                   	push   %ebp
c002c066:	89 e5                	mov    %esp,%ebp
c002c068:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002c06b:	8b 45 08             	mov    0x8(%ebp),%eax
c002c06e:	8b 00                	mov    (%eax),%eax
c002c070:	8d 50 ff             	lea    -0x1(%eax),%edx
c002c073:	8b 45 08             	mov    0x8(%ebp),%eax
c002c076:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002c078:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c07b:	83 ec 0c             	sub    $0xc,%esp
c002c07e:	50                   	push   %eax
c002c07f:	e8 15 e6 ff ff       	call   c002a699 <list_remove>
c002c084:	83 c4 10             	add    $0x10,%esp
}
c002c087:	90                   	nop
c002c088:	c9                   	leave  
c002c089:	c3                   	ret    

c002c08a <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002c08a:	55                   	push   %ebp
c002c08b:	89 e5                	mov    %esp,%ebp
c002c08d:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002c090:	83 ec 0c             	sub    $0xc,%esp
c002c093:	68 60 a0 03 c0       	push   $0xc003a060
c002c098:	e8 c5 6f ff ff       	call   c0023062 <lock_init>
c002c09d:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002c0a0:	c6 05 84 a0 03 c0 01 	movb   $0x1,0xc003a084
}
c002c0a7:	90                   	nop
c002c0a8:	c9                   	leave  
c002c0a9:	c3                   	ret    

c002c0aa <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002c0aa:	55                   	push   %ebp
c002c0ab:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002c0ad:	c6 05 84 a0 03 c0 00 	movb   $0x0,0xc003a084
}
c002c0b4:	90                   	nop
c002c0b5:	5d                   	pop    %ebp
c002c0b6:	c3                   	ret    

c002c0b7 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002c0b7:	55                   	push   %ebp
c002c0b8:	89 e5                	mov    %esp,%ebp
c002c0ba:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002c0bd:	a1 90 a0 03 c0       	mov    0xc003a090,%eax
c002c0c2:	8b 15 94 a0 03 c0    	mov    0xc003a094,%edx
c002c0c8:	83 ec 04             	sub    $0x4,%esp
c002c0cb:	52                   	push   %edx
c002c0cc:	50                   	push   %eax
c002c0cd:	68 f4 1b 03 c0       	push   $0xc0031bf4
c002c0d2:	e8 7a ba ff ff       	call   c0027b51 <printf>
c002c0d7:	83 c4 10             	add    $0x10,%esp
}
c002c0da:	90                   	nop
c002c0db:	c9                   	leave  
c002c0dc:	c3                   	ret    

c002c0dd <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002c0dd:	55                   	push   %ebp
c002c0de:	89 e5                	mov    %esp,%ebp
c002c0e0:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002c0e3:	e8 62 5b ff ff       	call   c0021c4a <intr_context>
c002c0e8:	83 f0 01             	xor    $0x1,%eax
c002c0eb:	84 c0                	test   %al,%al
c002c0ed:	74 3a                	je     c002c129 <acquire_console+0x4c>
c002c0ef:	a0 84 a0 03 c0       	mov    0xc003a084,%al
c002c0f4:	84 c0                	test   %al,%al
c002c0f6:	74 31                	je     c002c129 <acquire_console+0x4c>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002c0f8:	83 ec 0c             	sub    $0xc,%esp
c002c0fb:	68 60 a0 03 c0       	push   $0xc003a060
c002c100:	e8 9a 72 ff ff       	call   c002339f <lock_held_by_current_thread>
c002c105:	83 c4 10             	add    $0x10,%esp
c002c108:	84 c0                	test   %al,%al
c002c10a:	74 0d                	je     c002c119 <acquire_console+0x3c>
        console_lock_depth++; 
c002c10c:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c002c111:	40                   	inc    %eax
c002c112:	a3 88 a0 03 c0       	mov    %eax,0xc003a088
      else
        lock_acquire (&console_lock); 
    }
}
c002c117:	eb 10                	jmp    c002c129 <acquire_console+0x4c>
        lock_acquire (&console_lock); 
c002c119:	83 ec 0c             	sub    $0xc,%esp
c002c11c:	68 60 a0 03 c0       	push   $0xc003a060
c002c121:	e8 89 6f ff ff       	call   c00230af <lock_acquire>
c002c126:	83 c4 10             	add    $0x10,%esp
}
c002c129:	90                   	nop
c002c12a:	c9                   	leave  
c002c12b:	c3                   	ret    

c002c12c <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002c12c:	55                   	push   %ebp
c002c12d:	89 e5                	mov    %esp,%ebp
c002c12f:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002c132:	e8 13 5b ff ff       	call   c0021c4a <intr_context>
c002c137:	83 f0 01             	xor    $0x1,%eax
c002c13a:	84 c0                	test   %al,%al
c002c13c:	74 2f                	je     c002c16d <release_console+0x41>
c002c13e:	a0 84 a0 03 c0       	mov    0xc003a084,%al
c002c143:	84 c0                	test   %al,%al
c002c145:	74 26                	je     c002c16d <release_console+0x41>
    {
      if (console_lock_depth > 0)
c002c147:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c002c14c:	85 c0                	test   %eax,%eax
c002c14e:	7e 0d                	jle    c002c15d <release_console+0x31>
        console_lock_depth--;
c002c150:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c002c155:	48                   	dec    %eax
c002c156:	a3 88 a0 03 c0       	mov    %eax,0xc003a088
      else
        lock_release (&console_lock); 
    }
}
c002c15b:	eb 10                	jmp    c002c16d <release_console+0x41>
        lock_release (&console_lock); 
c002c15d:	83 ec 0c             	sub    $0xc,%esp
c002c160:	68 60 a0 03 c0       	push   $0xc003a060
c002c165:	e8 76 71 ff ff       	call   c00232e0 <lock_release>
c002c16a:	83 c4 10             	add    $0x10,%esp
}
c002c16d:	90                   	nop
c002c16e:	c9                   	leave  
c002c16f:	c3                   	ret    

c002c170 <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002c170:	55                   	push   %ebp
c002c171:	89 e5                	mov    %esp,%ebp
c002c173:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002c176:	e8 cf 5a ff ff       	call   c0021c4a <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002c17b:	84 c0                	test   %al,%al
c002c17d:	75 20                	jne    c002c19f <console_locked_by_current_thread+0x2f>
          || !use_console_lock
c002c17f:	a0 84 a0 03 c0       	mov    0xc003a084,%al
c002c184:	83 f0 01             	xor    $0x1,%eax
c002c187:	84 c0                	test   %al,%al
c002c189:	75 14                	jne    c002c19f <console_locked_by_current_thread+0x2f>
          || lock_held_by_current_thread (&console_lock));
c002c18b:	83 ec 0c             	sub    $0xc,%esp
c002c18e:	68 60 a0 03 c0       	push   $0xc003a060
c002c193:	e8 07 72 ff ff       	call   c002339f <lock_held_by_current_thread>
c002c198:	83 c4 10             	add    $0x10,%esp
c002c19b:	84 c0                	test   %al,%al
c002c19d:	74 07                	je     c002c1a6 <console_locked_by_current_thread+0x36>
c002c19f:	b8 01 00 00 00       	mov    $0x1,%eax
c002c1a4:	eb 05                	jmp    c002c1ab <console_locked_by_current_thread+0x3b>
c002c1a6:	b8 00 00 00 00       	mov    $0x0,%eax
c002c1ab:	83 e0 01             	and    $0x1,%eax
}
c002c1ae:	c9                   	leave  
c002c1af:	c3                   	ret    

c002c1b0 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002c1b0:	55                   	push   %ebp
c002c1b1:	89 e5                	mov    %esp,%ebp
c002c1b3:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002c1b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002c1bd:	e8 1b ff ff ff       	call   c002c0dd <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002c1c2:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002c1c5:	50                   	push   %eax
c002c1c6:	68 8f c2 02 c0       	push   $0xc002c28f
c002c1cb:	ff 75 0c             	pushl  0xc(%ebp)
c002c1ce:	ff 75 08             	pushl  0x8(%ebp)
c002c1d1:	e8 a1 b9 ff ff       	call   c0027b77 <__vprintf>
c002c1d6:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002c1d9:	e8 4e ff ff ff       	call   c002c12c <release_console>

  return char_cnt;
c002c1de:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002c1e1:	c9                   	leave  
c002c1e2:	c3                   	ret    

c002c1e3 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002c1e3:	55                   	push   %ebp
c002c1e4:	89 e5                	mov    %esp,%ebp
c002c1e6:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002c1e9:	e8 ef fe ff ff       	call   c002c0dd <acquire_console>
  while (*s != '\0')
c002c1ee:	eb 1a                	jmp    c002c20a <puts+0x27>
    putchar_have_lock (*s++);
c002c1f0:	8b 45 08             	mov    0x8(%ebp),%eax
c002c1f3:	8d 50 01             	lea    0x1(%eax),%edx
c002c1f6:	89 55 08             	mov    %edx,0x8(%ebp)
c002c1f9:	8a 00                	mov    (%eax),%al
c002c1fb:	0f b6 c0             	movzbl %al,%eax
c002c1fe:	83 ec 0c             	sub    $0xc,%esp
c002c201:	50                   	push   %eax
c002c202:	e8 bc 00 00 00       	call   c002c2c3 <putchar_have_lock>
c002c207:	83 c4 10             	add    $0x10,%esp
  while (*s != '\0')
c002c20a:	8b 45 08             	mov    0x8(%ebp),%eax
c002c20d:	8a 00                	mov    (%eax),%al
c002c20f:	84 c0                	test   %al,%al
c002c211:	75 dd                	jne    c002c1f0 <puts+0xd>
  putchar_have_lock ('\n');
c002c213:	83 ec 0c             	sub    $0xc,%esp
c002c216:	6a 0a                	push   $0xa
c002c218:	e8 a6 00 00 00       	call   c002c2c3 <putchar_have_lock>
c002c21d:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002c220:	e8 07 ff ff ff       	call   c002c12c <release_console>

  return 0;
c002c225:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002c22a:	c9                   	leave  
c002c22b:	c3                   	ret    

c002c22c <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002c22c:	55                   	push   %ebp
c002c22d:	89 e5                	mov    %esp,%ebp
c002c22f:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002c232:	e8 a6 fe ff ff       	call   c002c0dd <acquire_console>
  while (n-- > 0)
c002c237:	eb 1a                	jmp    c002c253 <putbuf+0x27>
    putchar_have_lock (*buffer++);
c002c239:	8b 45 08             	mov    0x8(%ebp),%eax
c002c23c:	8d 50 01             	lea    0x1(%eax),%edx
c002c23f:	89 55 08             	mov    %edx,0x8(%ebp)
c002c242:	8a 00                	mov    (%eax),%al
c002c244:	0f b6 c0             	movzbl %al,%eax
c002c247:	83 ec 0c             	sub    $0xc,%esp
c002c24a:	50                   	push   %eax
c002c24b:	e8 73 00 00 00       	call   c002c2c3 <putchar_have_lock>
c002c250:	83 c4 10             	add    $0x10,%esp
  while (n-- > 0)
c002c253:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c256:	8d 50 ff             	lea    -0x1(%eax),%edx
c002c259:	89 55 0c             	mov    %edx,0xc(%ebp)
c002c25c:	85 c0                	test   %eax,%eax
c002c25e:	75 d9                	jne    c002c239 <putbuf+0xd>
  release_console ();
c002c260:	e8 c7 fe ff ff       	call   c002c12c <release_console>
}
c002c265:	90                   	nop
c002c266:	c9                   	leave  
c002c267:	c3                   	ret    

c002c268 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002c268:	55                   	push   %ebp
c002c269:	89 e5                	mov    %esp,%ebp
c002c26b:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002c26e:	e8 6a fe ff ff       	call   c002c0dd <acquire_console>
  putchar_have_lock (c);
c002c273:	8b 45 08             	mov    0x8(%ebp),%eax
c002c276:	0f b6 c0             	movzbl %al,%eax
c002c279:	83 ec 0c             	sub    $0xc,%esp
c002c27c:	50                   	push   %eax
c002c27d:	e8 41 00 00 00       	call   c002c2c3 <putchar_have_lock>
c002c282:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002c285:	e8 a2 fe ff ff       	call   c002c12c <release_console>
  
  return c;
c002c28a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002c28d:	c9                   	leave  
c002c28e:	c3                   	ret    

c002c28f <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002c28f:	55                   	push   %ebp
c002c290:	89 e5                	mov    %esp,%ebp
c002c292:	83 ec 28             	sub    $0x28,%esp
c002c295:	8b 45 08             	mov    0x8(%ebp),%eax
c002c298:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002c29b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c29e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002c2a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c2a4:	8b 00                	mov    (%eax),%eax
c002c2a6:	8d 50 01             	lea    0x1(%eax),%edx
c002c2a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c2ac:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002c2ae:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002c2b1:	0f b6 c0             	movzbl %al,%eax
c002c2b4:	83 ec 0c             	sub    $0xc,%esp
c002c2b7:	50                   	push   %eax
c002c2b8:	e8 06 00 00 00       	call   c002c2c3 <putchar_have_lock>
c002c2bd:	83 c4 10             	add    $0x10,%esp
}
c002c2c0:	90                   	nop
c002c2c1:	c9                   	leave  
c002c2c2:	c3                   	ret    

c002c2c3 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002c2c3:	55                   	push   %ebp
c002c2c4:	89 e5                	mov    %esp,%ebp
c002c2c6:	83 ec 18             	sub    $0x18,%esp
c002c2c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002c2cc:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002c2cf:	e8 9c fe ff ff       	call   c002c170 <console_locked_by_current_thread>
c002c2d4:	84 c0                	test   %al,%al
c002c2d6:	75 21                	jne    c002c2f9 <putchar_have_lock+0x36>
c002c2d8:	83 ec 0c             	sub    $0xc,%esp
c002c2db:	68 18 1c 03 c0       	push   $0xc0031c18
c002c2e0:	68 3c 1c 03 c0       	push   $0xc0031c3c
c002c2e5:	68 70 1c 03 c0       	push   $0xc0031c70
c002c2ea:	68 bb 00 00 00       	push   $0xbb
c002c2ef:	68 53 1c 03 c0       	push   $0xc0031c53
c002c2f4:	e8 29 dd ff ff       	call   c002a022 <debug_panic>
  write_cnt++;
c002c2f9:	a1 90 a0 03 c0       	mov    0xc003a090,%eax
c002c2fe:	8b 15 94 a0 03 c0    	mov    0xc003a094,%edx
c002c304:	83 c0 01             	add    $0x1,%eax
c002c307:	83 d2 00             	adc    $0x0,%edx
c002c30a:	a3 90 a0 03 c0       	mov    %eax,0xc003a090
c002c30f:	89 15 94 a0 03 c0    	mov    %edx,0xc003a094
  serial_putc (c);
c002c315:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002c319:	83 ec 0c             	sub    $0xc,%esp
c002c31c:	50                   	push   %eax
c002c31d:	e8 5e 90 ff ff       	call   c0025380 <serial_putc>
c002c322:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002c325:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002c329:	83 ec 0c             	sub    $0xc,%esp
c002c32c:	50                   	push   %eax
c002c32d:	e8 e6 8b ff ff       	call   c0024f18 <vga_putc>
c002c332:	83 c4 10             	add    $0x10,%esp
}
c002c335:	90                   	nop
c002c336:	c9                   	leave  
c002c337:	c3                   	ret    

c002c338 <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002c338:	55                   	push   %ebp
c002c339:	89 e5                	mov    %esp,%ebp
c002c33b:	83 ec 18             	sub    $0x18,%esp
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002c33e:	c7 45 f4 60 1e 03 c0 	movl   $0xc0031e60,-0xc(%ebp)
c002c345:	eb 4e                	jmp    c002c395 <run_test+0x5d>
    if (!strcmp (name, t->name))
c002c347:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c34a:	8b 00                	mov    (%eax),%eax
c002c34c:	83 ec 08             	sub    $0x8,%esp
c002c34f:	50                   	push   %eax
c002c350:	ff 75 08             	pushl  0x8(%ebp)
c002c353:	e8 f5 cb ff ff       	call   c0028f4d <strcmp>
c002c358:	83 c4 10             	add    $0x10,%esp
c002c35b:	85 c0                	test   %eax,%eax
c002c35d:	75 32                	jne    c002c391 <run_test+0x59>
      {
        test_name = name;
c002c35f:	8b 45 08             	mov    0x8(%ebp),%eax
c002c362:	a3 98 a0 03 c0       	mov    %eax,0xc003a098
        msg ("begin");
c002c367:	83 ec 0c             	sub    $0xc,%esp
c002c36a:	68 38 1f 03 c0       	push   $0xc0031f38
c002c36f:	e8 49 00 00 00       	call   c002c3bd <msg>
c002c374:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002c377:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c37a:	8b 40 04             	mov    0x4(%eax),%eax
c002c37d:	ff d0                	call   *%eax
        msg ("end");
c002c37f:	83 ec 0c             	sub    $0xc,%esp
c002c382:	68 3e 1f 03 c0       	push   $0xc0031f3e
c002c387:	e8 31 00 00 00       	call   c002c3bd <msg>
c002c38c:	83 c4 10             	add    $0x10,%esp
        return;
c002c38f:	eb 2a                	jmp    c002c3bb <run_test+0x83>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002c391:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002c395:	b8 38 1f 03 c0       	mov    $0xc0031f38,%eax
c002c39a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002c39d:	72 a8                	jb     c002c347 <run_test+0xf>
      }
  PANIC ("no test named \"%s\"", name);
c002c39f:	83 ec 0c             	sub    $0xc,%esp
c002c3a2:	ff 75 08             	pushl  0x8(%ebp)
c002c3a5:	68 42 1f 03 c0       	push   $0xc0031f42
c002c3aa:	68 9c 1f 03 c0       	push   $0xc0031f9c
c002c3af:	6a 3c                	push   $0x3c
c002c3b1:	68 55 1f 03 c0       	push   $0xc0031f55
c002c3b6:	e8 67 dc ff ff       	call   c002a022 <debug_panic>
}
c002c3bb:	c9                   	leave  
c002c3bc:	c3                   	ret    

c002c3bd <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002c3bd:	55                   	push   %ebp
c002c3be:	89 e5                	mov    %esp,%ebp
c002c3c0:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c002c3c3:	a1 98 a0 03 c0       	mov    0xc003a098,%eax
c002c3c8:	83 ec 08             	sub    $0x8,%esp
c002c3cb:	50                   	push   %eax
c002c3cc:	68 71 1f 03 c0       	push   $0xc0031f71
c002c3d1:	e8 7b b7 ff ff       	call   c0027b51 <printf>
c002c3d6:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002c3d9:	8d 45 0c             	lea    0xc(%ebp),%eax
c002c3dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002c3df:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c3e2:	83 ec 08             	sub    $0x8,%esp
c002c3e5:	50                   	push   %eax
c002c3e6:	ff 75 08             	pushl  0x8(%ebp)
c002c3e9:	e8 c2 fd ff ff       	call   c002c1b0 <vprintf>
c002c3ee:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002c3f1:	83 ec 0c             	sub    $0xc,%esp
c002c3f4:	6a 0a                	push   $0xa
c002c3f6:	e8 6d fe ff ff       	call   c002c268 <putchar>
c002c3fb:	83 c4 10             	add    $0x10,%esp
}
c002c3fe:	90                   	nop
c002c3ff:	c9                   	leave  
c002c400:	c3                   	ret    

c002c401 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002c401:	55                   	push   %ebp
c002c402:	89 e5                	mov    %esp,%ebp
c002c404:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002c407:	a1 98 a0 03 c0       	mov    0xc003a098,%eax
c002c40c:	83 ec 08             	sub    $0x8,%esp
c002c40f:	50                   	push   %eax
c002c410:	68 77 1f 03 c0       	push   $0xc0031f77
c002c415:	e8 37 b7 ff ff       	call   c0027b51 <printf>
c002c41a:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002c41d:	8d 45 0c             	lea    0xc(%ebp),%eax
c002c420:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002c423:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c426:	83 ec 08             	sub    $0x8,%esp
c002c429:	50                   	push   %eax
c002c42a:	ff 75 08             	pushl  0x8(%ebp)
c002c42d:	e8 7e fd ff ff       	call   c002c1b0 <vprintf>
c002c432:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002c435:	83 ec 0c             	sub    $0xc,%esp
c002c438:	6a 0a                	push   $0xa
c002c43a:	e8 29 fe ff ff       	call   c002c268 <putchar>
c002c43f:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002c442:	68 83 1f 03 c0       	push   $0xc0031f83
c002c447:	68 a8 1f 03 c0       	push   $0xc0031fa8
c002c44c:	6a 5d                	push   $0x5d
c002c44e:	68 55 1f 03 c0       	push   $0xc0031f55
c002c453:	e8 ca db ff ff       	call   c002a022 <debug_panic>

c002c458 <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002c458:	55                   	push   %ebp
c002c459:	89 e5                	mov    %esp,%ebp
c002c45b:	83 ec 08             	sub    $0x8,%esp
  printf ("(%s) PASS\n", test_name);
c002c45e:	a1 98 a0 03 c0       	mov    0xc003a098,%eax
c002c463:	83 ec 08             	sub    $0x8,%esp
c002c466:	50                   	push   %eax
c002c467:	68 8f 1f 03 c0       	push   $0xc0031f8f
c002c46c:	e8 e0 b6 ff ff       	call   c0027b51 <printf>
c002c471:	83 c4 10             	add    $0x10,%esp
}
c002c474:	90                   	nop
c002c475:	c9                   	leave  
c002c476:	c3                   	ret    

c002c477 <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002c477:	55                   	push   %ebp
c002c478:	89 e5                	mov    %esp,%ebp
c002c47a:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 1);
c002c47d:	83 ec 08             	sub    $0x8,%esp
c002c480:	6a 01                	push   $0x1
c002c482:	6a 05                	push   $0x5
c002c484:	e8 1e 00 00 00       	call   c002c4a7 <test_sleep>
c002c489:	83 c4 10             	add    $0x10,%esp
}
c002c48c:	90                   	nop
c002c48d:	c9                   	leave  
c002c48e:	c3                   	ret    

c002c48f <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002c48f:	55                   	push   %ebp
c002c490:	89 e5                	mov    %esp,%ebp
c002c492:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 7);
c002c495:	83 ec 08             	sub    $0x8,%esp
c002c498:	6a 07                	push   $0x7
c002c49a:	6a 05                	push   $0x5
c002c49c:	e8 06 00 00 00       	call   c002c4a7 <test_sleep>
c002c4a1:	83 c4 10             	add    $0x10,%esp
}
c002c4a4:	90                   	nop
c002c4a5:	c9                   	leave  
c002c4a6:	c3                   	ret    

c002c4a7 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002c4a7:	55                   	push   %ebp
c002c4a8:	89 e5                	mov    %esp,%ebp
c002c4aa:	83 ec 78             	sub    $0x78,%esp
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c4ad:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002c4b2:	83 f0 01             	xor    $0x1,%eax
c002c4b5:	84 c0                	test   %al,%al
c002c4b7:	75 1e                	jne    c002c4d7 <test_sleep+0x30>
c002c4b9:	83 ec 0c             	sub    $0xc,%esp
c002c4bc:	68 b0 1f 03 c0       	push   $0xc0031fb0
c002c4c1:	68 be 1f 03 c0       	push   $0xc0031fbe
c002c4c6:	68 c4 21 03 c0       	push   $0xc00321c4
c002c4cb:	6a 3c                	push   $0x3c
c002c4cd:	68 d8 1f 03 c0       	push   $0xc0031fd8
c002c4d2:	e8 4b db ff ff       	call   c002a022 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002c4d7:	83 ec 04             	sub    $0x4,%esp
c002c4da:	ff 75 0c             	pushl  0xc(%ebp)
c002c4dd:	ff 75 08             	pushl  0x8(%ebp)
c002c4e0:	68 fc 1f 03 c0       	push   $0xc0031ffc
c002c4e5:	e8 d3 fe ff ff       	call   c002c3bd <msg>
c002c4ea:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002c4ed:	83 ec 0c             	sub    $0xc,%esp
c002c4f0:	68 28 20 03 c0       	push   $0xc0032028
c002c4f5:	e8 c3 fe ff ff       	call   c002c3bd <msg>
c002c4fa:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002c4fd:	83 ec 0c             	sub    $0xc,%esp
c002c500:	68 4c 20 03 c0       	push   $0xc003204c
c002c505:	e8 b3 fe ff ff       	call   c002c3bd <msg>
c002c50a:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002c50d:	83 ec 0c             	sub    $0xc,%esp
c002c510:	68 7c 20 03 c0       	push   $0xc003207c
c002c515:	e8 a3 fe ff ff       	call   c002c3bd <msg>
c002c51a:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002c51d:	83 ec 0c             	sub    $0xc,%esp
c002c520:	68 ac 20 03 c0       	push   $0xc00320ac
c002c525:	e8 93 fe ff ff       	call   c002c3bd <msg>
c002c52a:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002c52d:	8b 45 08             	mov    0x8(%ebp),%eax
c002c530:	c1 e0 04             	shl    $0x4,%eax
c002c533:	83 ec 0c             	sub    $0xc,%esp
c002c536:	50                   	push   %eax
c002c537:	e8 89 77 ff ff       	call   c0023cc5 <malloc>
c002c53c:	83 c4 10             	add    $0x10,%esp
c002c53f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002c542:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c545:	8b 45 08             	mov    0x8(%ebp),%eax
c002c548:	0f af c2             	imul   %edx,%eax
c002c54b:	c1 e0 03             	shl    $0x3,%eax
c002c54e:	83 ec 0c             	sub    $0xc,%esp
c002c551:	50                   	push   %eax
c002c552:	e8 6e 77 ff ff       	call   c0023cc5 <malloc>
c002c557:	83 c4 10             	add    $0x10,%esp
c002c55a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002c55d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002c561:	74 06                	je     c002c569 <test_sleep+0xc2>
c002c563:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002c567:	75 16                	jne    c002c57f <test_sleep+0xd8>
    PANIC ("couldn't allocate memory for test");
c002c569:	68 e0 20 03 c0       	push   $0xc00320e0
c002c56e:	68 c4 21 03 c0       	push   $0xc00321c4
c002c573:	6a 48                	push   $0x48
c002c575:	68 d8 1f 03 c0       	push   $0xc0031fd8
c002c57a:	e8 a3 da ff ff       	call   c002a022 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002c57f:	e8 a6 7f ff ff       	call   c002452a <timer_ticks>
c002c584:	83 c0 64             	add    $0x64,%eax
c002c587:	83 d2 00             	adc    $0x0,%edx
c002c58a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
c002c58d:	89 55 a8             	mov    %edx,-0x58(%ebp)
  test.iterations = iterations;
c002c590:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c593:	89 45 ac             	mov    %eax,-0x54(%ebp)
  lock_init (&test.output_lock);
c002c596:	83 ec 0c             	sub    $0xc,%esp
c002c599:	8d 45 a4             	lea    -0x5c(%ebp),%eax
c002c59c:	83 c0 0c             	add    $0xc,%eax
c002c59f:	50                   	push   %eax
c002c5a0:	e8 bd 6a ff ff       	call   c0023062 <lock_init>
c002c5a5:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002c5a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c5ab:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002c5ae:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002c5b2:	75 1e                	jne    c002c5d2 <test_sleep+0x12b>
c002c5b4:	83 ec 0c             	sub    $0xc,%esp
c002c5b7:	68 02 21 03 c0       	push   $0xc0032102
c002c5bc:	68 be 1f 03 c0       	push   $0xc0031fbe
c002c5c1:	68 c4 21 03 c0       	push   $0xc00321c4
c002c5c6:	6a 51                	push   $0x51
c002c5c8:	68 d8 1f 03 c0       	push   $0xc0031fd8
c002c5cd:	e8 50 da ff ff       	call   c002a022 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002c5d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002c5d9:	eb 71                	jmp    c002c64c <test_sleep+0x1a5>
    {
      struct sleep_thread *t = threads + i;
c002c5db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c5de:	c1 e0 04             	shl    $0x4,%eax
c002c5e1:	89 c2                	mov    %eax,%edx
c002c5e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c5e6:	01 d0                	add    %edx,%eax
c002c5e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char name[16];
      
      t->test = &test;
c002c5eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c5ee:	8d 55 a4             	lea    -0x5c(%ebp),%edx
c002c5f1:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002c5f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c5f6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002c5f9:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002c5fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c5ff:	8d 50 01             	lea    0x1(%eax),%edx
c002c602:	89 d0                	mov    %edx,%eax
c002c604:	c1 e0 02             	shl    $0x2,%eax
c002c607:	01 d0                	add    %edx,%eax
c002c609:	01 c0                	add    %eax,%eax
c002c60b:	89 c2                	mov    %eax,%edx
c002c60d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c610:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002c613:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c616:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002c61d:	ff 75 ec             	pushl  -0x14(%ebp)
c002c620:	68 11 21 03 c0       	push   $0xc0032111
c002c625:	6a 10                	push   $0x10
c002c627:	8d 45 94             	lea    -0x6c(%ebp),%eax
c002c62a:	50                   	push   %eax
c002c62b:	e8 f8 b4 ff ff       	call   c0027b28 <snprintf>
c002c630:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002c633:	ff 75 e0             	pushl  -0x20(%ebp)
c002c636:	68 e1 c7 02 c0       	push   $0xc002c7e1
c002c63b:	6a 1f                	push   $0x1f
c002c63d:	8d 45 94             	lea    -0x6c(%ebp),%eax
c002c640:	50                   	push   %eax
c002c641:	e8 16 44 ff ff       	call   c0020a5c <thread_create>
c002c646:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002c649:	ff 45 ec             	incl   -0x14(%ebp)
c002c64c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c64f:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c652:	7c 87                	jl     c002c5db <test_sleep+0x134>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002c654:	8b 45 08             	mov    0x8(%ebp),%eax
c002c657:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002c65b:	89 c2                	mov    %eax,%edx
c002c65d:	89 d0                	mov    %edx,%eax
c002c65f:	c1 e0 02             	shl    $0x2,%eax
c002c662:	01 d0                	add    %edx,%eax
c002c664:	01 c0                	add    %eax,%eax
c002c666:	05 c8 00 00 00       	add    $0xc8,%eax
c002c66b:	99                   	cltd   
c002c66c:	83 ec 08             	sub    $0x8,%esp
c002c66f:	52                   	push   %edx
c002c670:	50                   	push   %eax
c002c671:	e8 08 7f ff ff       	call   c002457e <timer_sleep>
c002c676:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002c679:	83 ec 0c             	sub    $0xc,%esp
c002c67c:	8d 45 a4             	lea    -0x5c(%ebp),%eax
c002c67f:	83 c0 0c             	add    $0xc,%eax
c002c682:	50                   	push   %eax
c002c683:	e8 27 6a ff ff       	call   c00230af <lock_acquire>
c002c688:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002c68b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002c692:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c695:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c698:	e9 ba 00 00 00       	jmp    c002c757 <test_sleep+0x2b0>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002c69d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c6a0:	8b 00                	mov    (%eax),%eax
c002c6a2:	85 c0                	test   %eax,%eax
c002c6a4:	78 0a                	js     c002c6b0 <test_sleep+0x209>
c002c6a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c6a9:	8b 00                	mov    (%eax),%eax
c002c6ab:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c6ae:	7c 1e                	jl     c002c6ce <test_sleep+0x227>
c002c6b0:	83 ec 0c             	sub    $0xc,%esp
c002c6b3:	68 1b 21 03 c0       	push   $0xc003211b
c002c6b8:	68 be 1f 03 c0       	push   $0xc0031fbe
c002c6bd:	68 c4 21 03 c0       	push   $0xc00321c4
c002c6c2:	6a 6e                	push   $0x6e
c002c6c4:	68 d8 1f 03 c0       	push   $0xc0031fd8
c002c6c9:	e8 54 d9 ff ff       	call   c002a022 <debug_panic>
      t = threads + *op;
c002c6ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c6d1:	8b 00                	mov    (%eax),%eax
c002c6d3:	c1 e0 04             	shl    $0x4,%eax
c002c6d6:	89 c2                	mov    %eax,%edx
c002c6d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c6db:	01 d0                	add    %edx,%eax
c002c6dd:	89 45 dc             	mov    %eax,-0x24(%ebp)

      new_prod = ++t->iterations * t->duration;
c002c6e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c6e3:	8b 40 0c             	mov    0xc(%eax),%eax
c002c6e6:	8d 50 01             	lea    0x1(%eax),%edx
c002c6e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c6ec:	89 50 0c             	mov    %edx,0xc(%eax)
c002c6ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c6f2:	8b 50 0c             	mov    0xc(%eax),%edx
c002c6f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c6f8:	8b 40 08             	mov    0x8(%eax),%eax
c002c6fb:	0f af c2             	imul   %edx,%eax
c002c6fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002c701:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c704:	8b 48 0c             	mov    0xc(%eax),%ecx
c002c707:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c70a:	8b 50 08             	mov    0x8(%eax),%edx
c002c70d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c710:	8b 40 04             	mov    0x4(%eax),%eax
c002c713:	83 ec 0c             	sub    $0xc,%esp
c002c716:	ff 75 d8             	pushl  -0x28(%ebp)
c002c719:	51                   	push   %ecx
c002c71a:	52                   	push   %edx
c002c71b:	50                   	push   %eax
c002c71c:	68 38 21 03 c0       	push   $0xc0032138
c002c721:	e8 97 fc ff ff       	call   c002c3bd <msg>
c002c726:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002c729:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c72c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002c72f:	7c 08                	jl     c002c739 <test_sleep+0x292>
        product = new_prod;
c002c731:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c734:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c737:	eb 1a                	jmp    c002c753 <test_sleep+0x2ac>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002c739:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c73c:	8b 40 04             	mov    0x4(%eax),%eax
c002c73f:	ff 75 d8             	pushl  -0x28(%ebp)
c002c742:	ff 75 f0             	pushl  -0x10(%ebp)
c002c745:	50                   	push   %eax
c002c746:	68 6c 21 03 c0       	push   $0xc003216c
c002c74b:	e8 b1 fc ff ff       	call   c002c401 <fail>
c002c750:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002c753:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002c757:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002c75a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c75d:	0f 87 3a ff ff ff    	ja     c002c69d <test_sleep+0x1f6>
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002c763:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002c76a:	eb 3c                	jmp    c002c7a8 <test_sleep+0x301>
    if (threads[i].iterations != iterations)
c002c76c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c76f:	c1 e0 04             	shl    $0x4,%eax
c002c772:	89 c2                	mov    %eax,%edx
c002c774:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c777:	01 d0                	add    %edx,%eax
c002c779:	8b 40 0c             	mov    0xc(%eax),%eax
c002c77c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002c77f:	74 24                	je     c002c7a5 <test_sleep+0x2fe>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002c781:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c784:	c1 e0 04             	shl    $0x4,%eax
c002c787:	89 c2                	mov    %eax,%edx
c002c789:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c78c:	01 d0                	add    %edx,%eax
      fail ("thread %d woke up %d times instead of %d",
c002c78e:	8b 40 0c             	mov    0xc(%eax),%eax
c002c791:	ff 75 0c             	pushl  0xc(%ebp)
c002c794:	50                   	push   %eax
c002c795:	ff 75 ec             	pushl  -0x14(%ebp)
c002c798:	68 98 21 03 c0       	push   $0xc0032198
c002c79d:	e8 5f fc ff ff       	call   c002c401 <fail>
c002c7a2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002c7a5:	ff 45 ec             	incl   -0x14(%ebp)
c002c7a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c7ab:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c7ae:	7c bc                	jl     c002c76c <test_sleep+0x2c5>
  
  lock_release (&test.output_lock);
c002c7b0:	83 ec 0c             	sub    $0xc,%esp
c002c7b3:	8d 45 a4             	lea    -0x5c(%ebp),%eax
c002c7b6:	83 c0 0c             	add    $0xc,%eax
c002c7b9:	50                   	push   %eax
c002c7ba:	e8 21 6b ff ff       	call   c00232e0 <lock_release>
c002c7bf:	83 c4 10             	add    $0x10,%esp
  free (output);
c002c7c2:	83 ec 0c             	sub    $0xc,%esp
c002c7c5:	ff 75 e4             	pushl  -0x1c(%ebp)
c002c7c8:	e8 04 78 ff ff       	call   c0023fd1 <free>
c002c7cd:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002c7d0:	83 ec 0c             	sub    $0xc,%esp
c002c7d3:	ff 75 e8             	pushl  -0x18(%ebp)
c002c7d6:	e8 f6 77 ff ff       	call   c0023fd1 <free>
c002c7db:	83 c4 10             	add    $0x10,%esp
}
c002c7de:	90                   	nop
c002c7df:	c9                   	leave  
c002c7e0:	c3                   	ret    

c002c7e1 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002c7e1:	55                   	push   %ebp
c002c7e2:	89 e5                	mov    %esp,%ebp
c002c7e4:	53                   	push   %ebx
c002c7e5:	83 ec 24             	sub    $0x24,%esp
  struct sleep_thread *t = t_;
c002c7e8:	8b 45 08             	mov    0x8(%ebp),%eax
c002c7eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct sleep_test *test = t->test;
c002c7ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c7f1:	8b 00                	mov    (%eax),%eax
c002c7f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002c7f6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c7fd:	eb 7b                	jmp    c002c87a <sleeper+0x99>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002c7ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c802:	8b 08                	mov    (%eax),%ecx
c002c804:	8b 58 04             	mov    0x4(%eax),%ebx
c002c807:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c80a:	8b 40 08             	mov    0x8(%eax),%eax
c002c80d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c002c811:	99                   	cltd   
c002c812:	01 c8                	add    %ecx,%eax
c002c814:	11 da                	adc    %ebx,%edx
c002c816:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c819:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002c81c:	e8 09 7d ff ff       	call   c002452a <timer_ticks>
c002c821:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002c824:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002c827:	29 c1                	sub    %eax,%ecx
c002c829:	19 d3                	sbb    %edx,%ebx
c002c82b:	89 c8                	mov    %ecx,%eax
c002c82d:	89 da                	mov    %ebx,%edx
c002c82f:	83 ec 08             	sub    $0x8,%esp
c002c832:	52                   	push   %edx
c002c833:	50                   	push   %eax
c002c834:	e8 45 7d ff ff       	call   c002457e <timer_sleep>
c002c839:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002c83c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c83f:	83 c0 0c             	add    $0xc,%eax
c002c842:	83 ec 0c             	sub    $0xc,%esp
c002c845:	50                   	push   %eax
c002c846:	e8 64 68 ff ff       	call   c00230af <lock_acquire>
c002c84b:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002c84e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c851:	8b 40 30             	mov    0x30(%eax),%eax
c002c854:	8d 48 04             	lea    0x4(%eax),%ecx
c002c857:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002c85a:	89 4a 30             	mov    %ecx,0x30(%edx)
c002c85d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002c860:	8b 52 04             	mov    0x4(%edx),%edx
c002c863:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002c865:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c868:	83 c0 0c             	add    $0xc,%eax
c002c86b:	83 ec 0c             	sub    $0xc,%esp
c002c86e:	50                   	push   %eax
c002c86f:	e8 6c 6a ff ff       	call   c00232e0 <lock_release>
c002c874:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i <= test->iterations; i++) 
c002c877:	ff 45 f4             	incl   -0xc(%ebp)
c002c87a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c87d:	8b 40 08             	mov    0x8(%eax),%eax
c002c880:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c883:	0f 8d 76 ff ff ff    	jge    c002c7ff <sleeper+0x1e>
    }
}
c002c889:	90                   	nop
c002c88a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c88d:	c9                   	leave  
c002c88e:	c3                   	ret    

c002c88f <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002c88f:	55                   	push   %ebp
c002c890:	89 e5                	mov    %esp,%ebp
c002c892:	83 ec 08             	sub    $0x8,%esp
  test_sleep (3, 5);
c002c895:	83 ec 08             	sub    $0x8,%esp
c002c898:	6a 05                	push   $0x5
c002c89a:	6a 03                	push   $0x3
c002c89c:	e8 06 00 00 00       	call   c002c8a7 <test_sleep>
c002c8a1:	83 c4 10             	add    $0x10,%esp
}
c002c8a4:	90                   	nop
c002c8a5:	c9                   	leave  
c002c8a6:	c3                   	ret    

c002c8a7 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002c8a7:	55                   	push   %ebp
c002c8a8:	89 e5                	mov    %esp,%ebp
c002c8aa:	53                   	push   %ebx
c002c8ab:	83 ec 34             	sub    $0x34,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c8ae:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002c8b3:	83 f0 01             	xor    $0x1,%eax
c002c8b6:	84 c0                	test   %al,%al
c002c8b8:	75 1e                	jne    c002c8d8 <test_sleep+0x31>
c002c8ba:	83 ec 0c             	sub    $0xc,%esp
c002c8bd:	68 d0 21 03 c0       	push   $0xc00321d0
c002c8c2:	68 de 21 03 c0       	push   $0xc00321de
c002c8c7:	68 58 23 03 c0       	push   $0xc0032358
c002c8cc:	6a 28                	push   $0x28
c002c8ce:	68 f8 21 03 c0       	push   $0xc00321f8
c002c8d3:	e8 4a d7 ff ff       	call   c002a022 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002c8d8:	83 ec 04             	sub    $0x4,%esp
c002c8db:	ff 75 0c             	pushl  0xc(%ebp)
c002c8de:	ff 75 08             	pushl  0x8(%ebp)
c002c8e1:	68 24 22 03 c0       	push   $0xc0032224
c002c8e6:	e8 d2 fa ff ff       	call   c002c3bd <msg>
c002c8eb:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002c8ee:	83 ec 0c             	sub    $0xc,%esp
c002c8f1:	68 50 22 03 c0       	push   $0xc0032250
c002c8f6:	e8 c2 fa ff ff       	call   c002c3bd <msg>
c002c8fb:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002c8fe:	83 ec 0c             	sub    $0xc,%esp
c002c901:	68 78 22 03 c0       	push   $0xc0032278
c002c906:	e8 b2 fa ff ff       	call   c002c3bd <msg>
c002c90b:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002c90e:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c911:	8b 45 08             	mov    0x8(%ebp),%eax
c002c914:	0f af c2             	imul   %edx,%eax
c002c917:	c1 e0 03             	shl    $0x3,%eax
c002c91a:	83 ec 0c             	sub    $0xc,%esp
c002c91d:	50                   	push   %eax
c002c91e:	e8 a2 73 ff ff       	call   c0023cc5 <malloc>
c002c923:	83 c4 10             	add    $0x10,%esp
c002c926:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002c929:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c92d:	75 16                	jne    c002c945 <test_sleep+0x9e>
    PANIC ("couldn't allocate memory for test");
c002c92f:	68 bc 22 03 c0       	push   $0xc00322bc
c002c934:	68 58 23 03 c0       	push   $0xc0032358
c002c939:	6a 31                	push   $0x31
c002c93b:	68 f8 21 03 c0       	push   $0xc00321f8
c002c940:	e8 dd d6 ff ff       	call   c002a022 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002c945:	e8 e0 7b ff ff       	call   c002452a <timer_ticks>
c002c94a:	83 c0 64             	add    $0x64,%eax
c002c94d:	83 d2 00             	adc    $0x0,%edx
c002c950:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c953:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002c956:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c959:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002c95c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c95f:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002c962:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c966:	75 1e                	jne    c002c986 <test_sleep+0xdf>
c002c968:	83 ec 0c             	sub    $0xc,%esp
c002c96b:	68 de 22 03 c0       	push   $0xc00322de
c002c970:	68 de 21 03 c0       	push   $0xc00321de
c002c975:	68 58 23 03 c0       	push   $0xc0032358
c002c97a:	6a 39                	push   $0x39
c002c97c:	68 f8 21 03 c0       	push   $0xc00321f8
c002c981:	e8 9c d6 ff ff       	call   c002a022 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002c986:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c98d:	eb 30                	jmp    c002c9bf <test_sleep+0x118>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002c98f:	ff 75 f4             	pushl  -0xc(%ebp)
c002c992:	68 ed 22 03 c0       	push   $0xc00322ed
c002c997:	6a 10                	push   $0x10
c002c999:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c99c:	50                   	push   %eax
c002c99d:	e8 86 b1 ff ff       	call   c0027b28 <snprintf>
c002c9a2:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002c9a5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c9a8:	50                   	push   %eax
c002c9a9:	68 7b ca 02 c0       	push   $0xc002ca7b
c002c9ae:	6a 1f                	push   $0x1f
c002c9b0:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c9b3:	50                   	push   %eax
c002c9b4:	e8 a3 40 ff ff       	call   c0020a5c <thread_create>
c002c9b9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002c9bc:	ff 45 f4             	incl   -0xc(%ebp)
c002c9bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c9c2:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c9c5:	7c c8                	jl     c002c98f <test_sleep+0xe8>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002c9c7:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c9ca:	89 d0                	mov    %edx,%eax
c002c9cc:	c1 e0 02             	shl    $0x2,%eax
c002c9cf:	01 d0                	add    %edx,%eax
c002c9d1:	01 c0                	add    %eax,%eax
c002c9d3:	05 c8 00 00 00       	add    $0xc8,%eax
c002c9d8:	99                   	cltd   
c002c9d9:	83 ec 08             	sub    $0x8,%esp
c002c9dc:	52                   	push   %edx
c002c9dd:	50                   	push   %eax
c002c9de:	e8 9b 7b ff ff       	call   c002457e <timer_sleep>
c002c9e3:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002c9e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c9e9:	8b 00                	mov    (%eax),%eax
c002c9eb:	83 ec 08             	sub    $0x8,%esp
c002c9ee:	50                   	push   %eax
c002c9ef:	68 f8 22 03 c0       	push   $0xc00322f8
c002c9f4:	e8 c4 f9 ff ff       	call   c002c3bd <msg>
c002c9f9:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002c9fc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002ca03:	eb 4e                	jmp    c002ca53 <test_sleep+0x1ac>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002ca05:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002ca0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ca12:	01 d0                	add    %edx,%eax
c002ca14:	8b 10                	mov    (%eax),%edx
c002ca16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca19:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002ca1e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002ca25:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ca28:	01 c8                	add    %ecx,%eax
c002ca2a:	8b 00                	mov    (%eax),%eax
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002ca2c:	89 d3                	mov    %edx,%ebx
c002ca2e:	29 c3                	sub    %eax,%ebx
c002ca30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca33:	99                   	cltd   
c002ca34:	f7 7d 08             	idivl  0x8(%ebp)
c002ca37:	89 d1                	mov    %edx,%ecx
c002ca39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca3c:	99                   	cltd   
c002ca3d:	f7 7d 08             	idivl  0x8(%ebp)
c002ca40:	53                   	push   %ebx
c002ca41:	51                   	push   %ecx
c002ca42:	50                   	push   %eax
c002ca43:	68 28 23 03 c0       	push   $0xc0032328
c002ca48:	e8 70 f9 ff ff       	call   c002c3bd <msg>
c002ca4d:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002ca50:	ff 45 f4             	incl   -0xc(%ebp)
c002ca53:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ca56:	89 c2                	mov    %eax,%edx
c002ca58:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ca5b:	29 c2                	sub    %eax,%edx
c002ca5d:	89 d0                	mov    %edx,%eax
c002ca5f:	c1 f8 02             	sar    $0x2,%eax
c002ca62:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002ca65:	7f 9e                	jg     c002ca05 <test_sleep+0x15e>
  
  free (output);
c002ca67:	83 ec 0c             	sub    $0xc,%esp
c002ca6a:	ff 75 f0             	pushl  -0x10(%ebp)
c002ca6d:	e8 5f 75 ff ff       	call   c0023fd1 <free>
c002ca72:	83 c4 10             	add    $0x10,%esp
}
c002ca75:	90                   	nop
c002ca76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ca79:	c9                   	leave  
c002ca7a:	c3                   	ret    

c002ca7b <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002ca7b:	55                   	push   %ebp
c002ca7c:	89 e5                	mov    %esp,%ebp
c002ca7e:	53                   	push   %ebx
c002ca7f:	83 ec 14             	sub    $0x14,%esp
  struct sleep_test *test = test_;
c002ca82:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca85:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002ca88:	83 ec 08             	sub    $0x8,%esp
c002ca8b:	6a 00                	push   $0x0
c002ca8d:	6a 01                	push   $0x1
c002ca8f:	e8 ea 7a ff ff       	call   c002457e <timer_sleep>
c002ca94:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002ca97:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002ca9e:	eb 6b                	jmp    c002cb0b <sleeper+0x90>
    {
      int64_t sleep_until = test->start + i * 10;
c002caa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002caa3:	8b 08                	mov    (%eax),%ecx
c002caa5:	8b 58 04             	mov    0x4(%eax),%ebx
c002caa8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002caab:	89 d0                	mov    %edx,%eax
c002caad:	c1 e0 02             	shl    $0x2,%eax
c002cab0:	01 d0                	add    %edx,%eax
c002cab2:	01 c0                	add    %eax,%eax
c002cab4:	99                   	cltd   
c002cab5:	01 c8                	add    %ecx,%eax
c002cab7:	11 da                	adc    %ebx,%edx
c002cab9:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002cabc:	89 55 ec             	mov    %edx,-0x14(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002cabf:	e8 66 7a ff ff       	call   c002452a <timer_ticks>
c002cac4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002cac7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002caca:	29 c1                	sub    %eax,%ecx
c002cacc:	19 d3                	sbb    %edx,%ebx
c002cace:	89 c8                	mov    %ecx,%eax
c002cad0:	89 da                	mov    %ebx,%edx
c002cad2:	83 ec 08             	sub    $0x8,%esp
c002cad5:	52                   	push   %edx
c002cad6:	50                   	push   %eax
c002cad7:	e8 a2 7a ff ff       	call   c002457e <timer_sleep>
c002cadc:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002cadf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cae2:	8b 58 0c             	mov    0xc(%eax),%ebx
c002cae5:	8d 53 04             	lea    0x4(%ebx),%edx
c002cae8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002caeb:	89 50 0c             	mov    %edx,0xc(%eax)
c002caee:	e8 37 7a ff ff       	call   c002452a <timer_ticks>
c002caf3:	89 c1                	mov    %eax,%ecx
c002caf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002caf8:	8b 50 04             	mov    0x4(%eax),%edx
c002cafb:	8b 00                	mov    (%eax),%eax
c002cafd:	29 c1                	sub    %eax,%ecx
c002caff:	89 c8                	mov    %ecx,%eax
c002cb01:	89 03                	mov    %eax,(%ebx)
      thread_yield ();
c002cb03:	e8 79 42 ff ff       	call   c0020d81 <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002cb08:	ff 45 f4             	incl   -0xc(%ebp)
c002cb0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cb0e:	8b 40 08             	mov    0x8(%eax),%eax
c002cb11:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002cb14:	7d 8a                	jge    c002caa0 <sleeper+0x25>
    }
}
c002cb16:	90                   	nop
c002cb17:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cb1a:	c9                   	leave  
c002cb1b:	c3                   	ret    

c002cb1c <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002cb1c:	55                   	push   %ebp
c002cb1d:	89 e5                	mov    %esp,%ebp
c002cb1f:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cb22:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002cb27:	83 f0 01             	xor    $0x1,%eax
c002cb2a:	84 c0                	test   %al,%al
c002cb2c:	75 1e                	jne    c002cb4c <test_alarm_priority+0x30>
c002cb2e:	83 ec 0c             	sub    $0xc,%esp
c002cb31:	68 64 23 03 c0       	push   $0xc0032364
c002cb36:	68 72 23 03 c0       	push   $0xc0032372
c002cb3b:	68 d0 23 03 c0       	push   $0xc00323d0
c002cb40:	6a 16                	push   $0x16
c002cb42:	68 8c 23 03 c0       	push   $0xc003238c
c002cb47:	e8 d6 d4 ff ff       	call   c002a022 <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002cb4c:	e8 d9 79 ff ff       	call   c002452a <timer_ticks>
c002cb51:	05 f4 01 00 00       	add    $0x1f4,%eax
c002cb56:	83 d2 00             	adc    $0x0,%edx
c002cb59:	a3 a0 a0 03 c0       	mov    %eax,0xc003a0a0
c002cb5e:	89 15 a4 a0 03 c0    	mov    %edx,0xc003a0a4
  sema_init (&wait_sema, 0);
c002cb64:	83 ec 08             	sub    $0x8,%esp
c002cb67:	6a 00                	push   $0x0
c002cb69:	68 a8 a0 03 c0       	push   $0xc003a0a8
c002cb6e:	e8 09 62 ff ff       	call   c0022d7c <sema_init>
c002cb73:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002cb76:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002cb7d:	eb 4b                	jmp    c002cbca <test_alarm_priority+0xae>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002cb7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb82:	83 c0 05             	add    $0x5,%eax
c002cb85:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002cb8a:	99                   	cltd   
c002cb8b:	f7 f9                	idiv   %ecx
c002cb8d:	89 d0                	mov    %edx,%eax
c002cb8f:	ba 1e 00 00 00       	mov    $0x1e,%edx
c002cb94:	29 c2                	sub    %eax,%edx
c002cb96:	89 d0                	mov    %edx,%eax
c002cb98:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002cb9b:	ff 75 f0             	pushl  -0x10(%ebp)
c002cb9e:	68 b1 23 03 c0       	push   $0xc00323b1
c002cba3:	6a 10                	push   $0x10
c002cba5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cba8:	50                   	push   %eax
c002cba9:	e8 7a af ff ff       	call   c0027b28 <snprintf>
c002cbae:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002cbb1:	6a 00                	push   $0x0
c002cbb3:	68 02 cc 02 c0       	push   $0xc002cc02
c002cbb8:	ff 75 f0             	pushl  -0x10(%ebp)
c002cbbb:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cbbe:	50                   	push   %eax
c002cbbf:	e8 98 3e ff ff       	call   c0020a5c <thread_create>
c002cbc4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002cbc7:	ff 45 f4             	incl   -0xc(%ebp)
c002cbca:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002cbce:	7e af                	jle    c002cb7f <test_alarm_priority+0x63>
    }

  thread_set_priority (PRI_MIN);
c002cbd0:	83 ec 0c             	sub    $0xc,%esp
c002cbd3:	6a 00                	push   $0x0
c002cbd5:	e8 ba 42 ff ff       	call   c0020e94 <thread_set_priority>
c002cbda:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002cbdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002cbe4:	eb 13                	jmp    c002cbf9 <test_alarm_priority+0xdd>
    sema_down (&wait_sema);
c002cbe6:	83 ec 0c             	sub    $0xc,%esp
c002cbe9:	68 a8 a0 03 c0       	push   $0xc003a0a8
c002cbee:	e8 d0 61 ff ff       	call   c0022dc3 <sema_down>
c002cbf3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++)
c002cbf6:	ff 45 f4             	incl   -0xc(%ebp)
c002cbf9:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002cbfd:	7e e7                	jle    c002cbe6 <test_alarm_priority+0xca>
}
c002cbff:	90                   	nop
c002cc00:	c9                   	leave  
c002cc01:	c3                   	ret    

c002cc02 <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002cc02:	55                   	push   %ebp
c002cc03:	89 e5                	mov    %esp,%ebp
c002cc05:	56                   	push   %esi
c002cc06:	53                   	push   %ebx
c002cc07:	83 ec 10             	sub    $0x10,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002cc0a:	e8 1b 79 ff ff       	call   c002452a <timer_ticks>
c002cc0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002cc12:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) == 0)
c002cc15:	eb 01                	jmp    c002cc18 <alarm_priority_thread+0x16>
    continue;
c002cc17:	90                   	nop
  while (timer_elapsed (start_time) == 0)
c002cc18:	83 ec 08             	sub    $0x8,%esp
c002cc1b:	ff 75 f4             	pushl  -0xc(%ebp)
c002cc1e:	ff 75 f0             	pushl  -0x10(%ebp)
c002cc21:	e8 39 79 ff ff       	call   c002455f <timer_elapsed>
c002cc26:	83 c4 10             	add    $0x10,%esp
c002cc29:	89 c1                	mov    %eax,%ecx
c002cc2b:	80 f5 00             	xor    $0x0,%ch
c002cc2e:	89 cb                	mov    %ecx,%ebx
c002cc30:	89 d0                	mov    %edx,%eax
c002cc32:	80 f4 00             	xor    $0x0,%ah
c002cc35:	89 c6                	mov    %eax,%esi
c002cc37:	89 f0                	mov    %esi,%eax
c002cc39:	09 d8                	or     %ebx,%eax
c002cc3b:	85 c0                	test   %eax,%eax
c002cc3d:	74 d8                	je     c002cc17 <alarm_priority_thread+0x15>

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002cc3f:	8b 1d a0 a0 03 c0    	mov    0xc003a0a0,%ebx
c002cc45:	8b 35 a4 a0 03 c0    	mov    0xc003a0a4,%esi
c002cc4b:	e8 da 78 ff ff       	call   c002452a <timer_ticks>
c002cc50:	29 c3                	sub    %eax,%ebx
c002cc52:	19 d6                	sbb    %edx,%esi
c002cc54:	89 d8                	mov    %ebx,%eax
c002cc56:	89 f2                	mov    %esi,%edx
c002cc58:	83 ec 08             	sub    $0x8,%esp
c002cc5b:	52                   	push   %edx
c002cc5c:	50                   	push   %eax
c002cc5d:	e8 1c 79 ff ff       	call   c002457e <timer_sleep>
c002cc62:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002cc65:	e8 11 40 ff ff       	call   c0020c7b <thread_name>
c002cc6a:	83 ec 08             	sub    $0x8,%esp
c002cc6d:	50                   	push   %eax
c002cc6e:	68 bd 23 03 c0       	push   $0xc00323bd
c002cc73:	e8 45 f7 ff ff       	call   c002c3bd <msg>
c002cc78:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002cc7b:	83 ec 0c             	sub    $0xc,%esp
c002cc7e:	68 a8 a0 03 c0       	push   $0xc003a0a8
c002cc83:	e8 49 62 ff ff       	call   c0022ed1 <sema_up>
c002cc88:	83 c4 10             	add    $0x10,%esp
}
c002cc8b:	90                   	nop
c002cc8c:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002cc8f:	5b                   	pop    %ebx
c002cc90:	5e                   	pop    %esi
c002cc91:	5d                   	pop    %ebp
c002cc92:	c3                   	ret    

c002cc93 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002cc93:	55                   	push   %ebp
c002cc94:	89 e5                	mov    %esp,%ebp
c002cc96:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (0);
c002cc99:	83 ec 08             	sub    $0x8,%esp
c002cc9c:	6a 00                	push   $0x0
c002cc9e:	6a 00                	push   $0x0
c002cca0:	e8 d9 78 ff ff       	call   c002457e <timer_sleep>
c002cca5:	83 c4 10             	add    $0x10,%esp
  pass ();
c002cca8:	e8 ab f7 ff ff       	call   c002c458 <pass>
}
c002ccad:	90                   	nop
c002ccae:	c9                   	leave  
c002ccaf:	c3                   	ret    

c002ccb0 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002ccb0:	55                   	push   %ebp
c002ccb1:	89 e5                	mov    %esp,%ebp
c002ccb3:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (-100);
c002ccb6:	83 ec 08             	sub    $0x8,%esp
c002ccb9:	6a ff                	push   $0xffffffff
c002ccbb:	6a 9c                	push   $0xffffff9c
c002ccbd:	e8 bc 78 ff ff       	call   c002457e <timer_sleep>
c002ccc2:	83 c4 10             	add    $0x10,%esp
  pass ();
c002ccc5:	e8 8e f7 ff ff       	call   c002c458 <pass>
}
c002ccca:	90                   	nop
c002cccb:	c9                   	leave  
c002cccc:	c3                   	ret    

c002cccd <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002cccd:	55                   	push   %ebp
c002ccce:	89 e5                	mov    %esp,%ebp
c002ccd0:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ccd3:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002ccd8:	83 f0 01             	xor    $0x1,%eax
c002ccdb:	84 c0                	test   %al,%al
c002ccdd:	75 1e                	jne    c002ccfd <test_priority_change+0x30>
c002ccdf:	83 ec 0c             	sub    $0xc,%esp
c002cce2:	68 e4 23 03 c0       	push   $0xc00323e4
c002cce7:	68 f2 23 03 c0       	push   $0xc00323f2
c002ccec:	68 e8 24 03 c0       	push   $0xc00324e8
c002ccf1:	6a 10                	push   $0x10
c002ccf3:	68 0c 24 03 c0       	push   $0xc003240c
c002ccf8:	e8 25 d3 ff ff       	call   c002a022 <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002ccfd:	83 ec 0c             	sub    $0xc,%esp
c002cd00:	68 34 24 03 c0       	push   $0xc0032434
c002cd05:	e8 b3 f6 ff ff       	call   c002c3bd <msg>
c002cd0a:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002cd0d:	6a 00                	push   $0x0
c002cd0f:	68 53 cd 02 c0       	push   $0xc002cd53
c002cd14:	6a 20                	push   $0x20
c002cd16:	68 57 24 03 c0       	push   $0xc0032457
c002cd1b:	e8 3c 3d ff ff       	call   c0020a5c <thread_create>
c002cd20:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002cd23:	83 ec 0c             	sub    $0xc,%esp
c002cd26:	68 60 24 03 c0       	push   $0xc0032460
c002cd2b:	e8 8d f6 ff ff       	call   c002c3bd <msg>
c002cd30:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002cd33:	83 ec 0c             	sub    $0xc,%esp
c002cd36:	6a 1d                	push   $0x1d
c002cd38:	e8 57 41 ff ff       	call   c0020e94 <thread_set_priority>
c002cd3d:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002cd40:	83 ec 0c             	sub    $0xc,%esp
c002cd43:	68 90 24 03 c0       	push   $0xc0032490
c002cd48:	e8 70 f6 ff ff       	call   c002c3bd <msg>
c002cd4d:	83 c4 10             	add    $0x10,%esp
}
c002cd50:	90                   	nop
c002cd51:	c9                   	leave  
c002cd52:	c3                   	ret    

c002cd53 <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002cd53:	55                   	push   %ebp
c002cd54:	89 e5                	mov    %esp,%ebp
c002cd56:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread 2 now lowering priority.");
c002cd59:	83 ec 0c             	sub    $0xc,%esp
c002cd5c:	68 b4 24 03 c0       	push   $0xc00324b4
c002cd61:	e8 57 f6 ff ff       	call   c002c3bd <msg>
c002cd66:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002cd69:	83 ec 0c             	sub    $0xc,%esp
c002cd6c:	6a 1e                	push   $0x1e
c002cd6e:	e8 21 41 ff ff       	call   c0020e94 <thread_set_priority>
c002cd73:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002cd76:	83 ec 0c             	sub    $0xc,%esp
c002cd79:	68 d4 24 03 c0       	push   $0xc00324d4
c002cd7e:	e8 3a f6 ff ff       	call   c002c3bd <msg>
c002cd83:	83 c4 10             	add    $0x10,%esp
}
c002cd86:	90                   	nop
c002cd87:	c9                   	leave  
c002cd88:	c3                   	ret    

c002cd89 <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002cd89:	55                   	push   %ebp
c002cd8a:	89 e5                	mov    %esp,%ebp
c002cd8c:	83 ec 38             	sub    $0x38,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cd8f:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002cd94:	83 f0 01             	xor    $0x1,%eax
c002cd97:	84 c0                	test   %al,%al
c002cd99:	75 1e                	jne    c002cdb9 <test_priority_donate_one+0x30>
c002cd9b:	83 ec 0c             	sub    $0xc,%esp
c002cd9e:	68 00 25 03 c0       	push   $0xc0032500
c002cda3:	68 0e 25 03 c0       	push   $0xc003250e
c002cda8:	68 90 26 03 c0       	push   $0xc0032690
c002cdad:	6a 1b                	push   $0x1b
c002cdaf:	68 28 25 03 c0       	push   $0xc0032528
c002cdb4:	e8 69 d2 ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cdb9:	e8 4f 41 ff ff       	call   c0020f0d <thread_get_priority>
c002cdbe:	83 f8 1f             	cmp    $0x1f,%eax
c002cdc1:	74 1e                	je     c002cde1 <test_priority_donate_one+0x58>
c002cdc3:	83 ec 0c             	sub    $0xc,%esp
c002cdc6:	68 54 25 03 c0       	push   $0xc0032554
c002cdcb:	68 0e 25 03 c0       	push   $0xc003250e
c002cdd0:	68 90 26 03 c0       	push   $0xc0032690
c002cdd5:	6a 1e                	push   $0x1e
c002cdd7:	68 28 25 03 c0       	push   $0xc0032528
c002cddc:	e8 41 d2 ff ff       	call   c002a022 <debug_panic>

  lock_init (&lock);
c002cde1:	83 ec 0c             	sub    $0xc,%esp
c002cde4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002cde7:	50                   	push   %eax
c002cde8:	e8 75 62 ff ff       	call   c0023062 <lock_init>
c002cded:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002cdf0:	83 ec 0c             	sub    $0xc,%esp
c002cdf3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002cdf6:	50                   	push   %eax
c002cdf7:	e8 b3 62 ff ff       	call   c00230af <lock_acquire>
c002cdfc:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002cdff:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002ce02:	50                   	push   %eax
c002ce03:	68 91 ce 02 c0       	push   $0xc002ce91
c002ce08:	6a 20                	push   $0x20
c002ce0a:	68 7a 25 03 c0       	push   $0xc003257a
c002ce0f:	e8 48 3c ff ff       	call   c0020a5c <thread_create>
c002ce14:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ce17:	e8 f1 40 ff ff       	call   c0020f0d <thread_get_priority>
c002ce1c:	83 ec 04             	sub    $0x4,%esp
c002ce1f:	50                   	push   %eax
c002ce20:	6a 20                	push   $0x20
c002ce22:	68 84 25 03 c0       	push   $0xc0032584
c002ce27:	e8 91 f5 ff ff       	call   c002c3bd <msg>
c002ce2c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002ce2f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002ce32:	50                   	push   %eax
c002ce33:	68 dc ce 02 c0       	push   $0xc002cedc
c002ce38:	6a 21                	push   $0x21
c002ce3a:	68 bf 25 03 c0       	push   $0xc00325bf
c002ce3f:	e8 18 3c ff ff       	call   c0020a5c <thread_create>
c002ce44:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ce47:	e8 c1 40 ff ff       	call   c0020f0d <thread_get_priority>
c002ce4c:	83 ec 04             	sub    $0x4,%esp
c002ce4f:	50                   	push   %eax
c002ce50:	6a 21                	push   $0x21
c002ce52:	68 84 25 03 c0       	push   $0xc0032584
c002ce57:	e8 61 f5 ff ff       	call   c002c3bd <msg>
c002ce5c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002ce5f:	83 ec 0c             	sub    $0xc,%esp
c002ce62:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002ce65:	50                   	push   %eax
c002ce66:	e8 75 64 ff ff       	call   c00232e0 <lock_release>
c002ce6b:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002ce6e:	83 ec 0c             	sub    $0xc,%esp
c002ce71:	68 c8 25 03 c0       	push   $0xc00325c8
c002ce76:	e8 42 f5 ff ff       	call   c002c3bd <msg>
c002ce7b:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002ce7e:	83 ec 0c             	sub    $0xc,%esp
c002ce81:	68 08 26 03 c0       	push   $0xc0032608
c002ce86:	e8 32 f5 ff ff       	call   c002c3bd <msg>
c002ce8b:	83 c4 10             	add    $0x10,%esp
}
c002ce8e:	90                   	nop
c002ce8f:	c9                   	leave  
c002ce90:	c3                   	ret    

c002ce91 <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002ce91:	55                   	push   %ebp
c002ce92:	89 e5                	mov    %esp,%ebp
c002ce94:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ce97:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce9a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ce9d:	83 ec 0c             	sub    $0xc,%esp
c002cea0:	ff 75 f4             	pushl  -0xc(%ebp)
c002cea3:	e8 07 62 ff ff       	call   c00230af <lock_acquire>
c002cea8:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002ceab:	83 ec 0c             	sub    $0xc,%esp
c002ceae:	68 41 26 03 c0       	push   $0xc0032641
c002ceb3:	e8 05 f5 ff ff       	call   c002c3bd <msg>
c002ceb8:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cebb:	83 ec 0c             	sub    $0xc,%esp
c002cebe:	ff 75 f4             	pushl  -0xc(%ebp)
c002cec1:	e8 1a 64 ff ff       	call   c00232e0 <lock_release>
c002cec6:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002cec9:	83 ec 0c             	sub    $0xc,%esp
c002cecc:	68 58 26 03 c0       	push   $0xc0032658
c002ced1:	e8 e7 f4 ff ff       	call   c002c3bd <msg>
c002ced6:	83 c4 10             	add    $0x10,%esp
}
c002ced9:	90                   	nop
c002ceda:	c9                   	leave  
c002cedb:	c3                   	ret    

c002cedc <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002cedc:	55                   	push   %ebp
c002cedd:	89 e5                	mov    %esp,%ebp
c002cedf:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cee2:	8b 45 08             	mov    0x8(%ebp),%eax
c002cee5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cee8:	83 ec 0c             	sub    $0xc,%esp
c002ceeb:	ff 75 f4             	pushl  -0xc(%ebp)
c002ceee:	e8 bc 61 ff ff       	call   c00230af <lock_acquire>
c002cef3:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002cef6:	83 ec 0c             	sub    $0xc,%esp
c002cef9:	68 67 26 03 c0       	push   $0xc0032667
c002cefe:	e8 ba f4 ff ff       	call   c002c3bd <msg>
c002cf03:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cf06:	83 ec 0c             	sub    $0xc,%esp
c002cf09:	ff 75 f4             	pushl  -0xc(%ebp)
c002cf0c:	e8 cf 63 ff ff       	call   c00232e0 <lock_release>
c002cf11:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002cf14:	83 ec 0c             	sub    $0xc,%esp
c002cf17:	68 7e 26 03 c0       	push   $0xc003267e
c002cf1c:	e8 9c f4 ff ff       	call   c002c3bd <msg>
c002cf21:	83 c4 10             	add    $0x10,%esp
}
c002cf24:	90                   	nop
c002cf25:	c9                   	leave  
c002cf26:	c3                   	ret    

c002cf27 <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002cf27:	55                   	push   %ebp
c002cf28:	89 e5                	mov    %esp,%ebp
c002cf2a:	83 ec 58             	sub    $0x58,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cf2d:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002cf32:	83 f0 01             	xor    $0x1,%eax
c002cf35:	84 c0                	test   %al,%al
c002cf37:	75 1e                	jne    c002cf57 <test_priority_donate_multiple+0x30>
c002cf39:	83 ec 0c             	sub    $0xc,%esp
c002cf3c:	68 ac 26 03 c0       	push   $0xc00326ac
c002cf41:	68 ba 26 03 c0       	push   $0xc00326ba
c002cf46:	68 10 28 03 c0       	push   $0xc0032810
c002cf4b:	6a 1b                	push   $0x1b
c002cf4d:	68 d4 26 03 c0       	push   $0xc00326d4
c002cf52:	e8 cb d0 ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cf57:	e8 b1 3f ff ff       	call   c0020f0d <thread_get_priority>
c002cf5c:	83 f8 1f             	cmp    $0x1f,%eax
c002cf5f:	74 1e                	je     c002cf7f <test_priority_donate_multiple+0x58>
c002cf61:	83 ec 0c             	sub    $0xc,%esp
c002cf64:	68 04 27 03 c0       	push   $0xc0032704
c002cf69:	68 ba 26 03 c0       	push   $0xc00326ba
c002cf6e:	68 10 28 03 c0       	push   $0xc0032810
c002cf73:	6a 1e                	push   $0x1e
c002cf75:	68 d4 26 03 c0       	push   $0xc00326d4
c002cf7a:	e8 a3 d0 ff ff       	call   c002a022 <debug_panic>

  lock_init (&a);
c002cf7f:	83 ec 0c             	sub    $0xc,%esp
c002cf82:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002cf85:	50                   	push   %eax
c002cf86:	e8 d7 60 ff ff       	call   c0023062 <lock_init>
c002cf8b:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002cf8e:	83 ec 0c             	sub    $0xc,%esp
c002cf91:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002cf94:	50                   	push   %eax
c002cf95:	e8 c8 60 ff ff       	call   c0023062 <lock_init>
c002cf9a:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002cf9d:	83 ec 0c             	sub    $0xc,%esp
c002cfa0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002cfa3:	50                   	push   %eax
c002cfa4:	e8 06 61 ff ff       	call   c00230af <lock_acquire>
c002cfa9:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002cfac:	83 ec 0c             	sub    $0xc,%esp
c002cfaf:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002cfb2:	50                   	push   %eax
c002cfb3:	e8 f7 60 ff ff       	call   c00230af <lock_acquire>
c002cfb8:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002cfbb:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002cfbe:	50                   	push   %eax
c002cfbf:	68 8c d0 02 c0       	push   $0xc002d08c
c002cfc4:	6a 20                	push   $0x20
c002cfc6:	68 2a 27 03 c0       	push   $0xc003272a
c002cfcb:	e8 8c 3a ff ff       	call   c0020a5c <thread_create>
c002cfd0:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cfd3:	e8 35 3f ff ff       	call   c0020f0d <thread_get_priority>
c002cfd8:	83 ec 04             	sub    $0x4,%esp
c002cfdb:	50                   	push   %eax
c002cfdc:	6a 20                	push   $0x20
c002cfde:	68 2c 27 03 c0       	push   $0xc003272c
c002cfe3:	e8 d5 f3 ff ff       	call   c002c3bd <msg>
c002cfe8:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002cfeb:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002cfee:	50                   	push   %eax
c002cfef:	68 d7 d0 02 c0       	push   $0xc002d0d7
c002cff4:	6a 21                	push   $0x21
c002cff6:	68 67 27 03 c0       	push   $0xc0032767
c002cffb:	e8 5c 3a ff ff       	call   c0020a5c <thread_create>
c002d000:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d003:	e8 05 3f ff ff       	call   c0020f0d <thread_get_priority>
c002d008:	83 ec 04             	sub    $0x4,%esp
c002d00b:	50                   	push   %eax
c002d00c:	6a 21                	push   $0x21
c002d00e:	68 2c 27 03 c0       	push   $0xc003272c
c002d013:	e8 a5 f3 ff ff       	call   c002c3bd <msg>
c002d018:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002d01b:	83 ec 0c             	sub    $0xc,%esp
c002d01e:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d021:	50                   	push   %eax
c002d022:	e8 b9 62 ff ff       	call   c00232e0 <lock_release>
c002d027:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002d02a:	83 ec 0c             	sub    $0xc,%esp
c002d02d:	68 6c 27 03 c0       	push   $0xc003276c
c002d032:	e8 86 f3 ff ff       	call   c002c3bd <msg>
c002d037:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d03a:	e8 ce 3e ff ff       	call   c0020f0d <thread_get_priority>
c002d03f:	83 ec 04             	sub    $0x4,%esp
c002d042:	50                   	push   %eax
c002d043:	6a 20                	push   $0x20
c002d045:	68 2c 27 03 c0       	push   $0xc003272c
c002d04a:	e8 6e f3 ff ff       	call   c002c3bd <msg>
c002d04f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002d052:	83 ec 0c             	sub    $0xc,%esp
c002d055:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d058:	50                   	push   %eax
c002d059:	e8 82 62 ff ff       	call   c00232e0 <lock_release>
c002d05e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002d061:	83 ec 0c             	sub    $0xc,%esp
c002d064:	68 90 27 03 c0       	push   $0xc0032790
c002d069:	e8 4f f3 ff ff       	call   c002c3bd <msg>
c002d06e:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d071:	e8 97 3e ff ff       	call   c0020f0d <thread_get_priority>
c002d076:	83 ec 04             	sub    $0x4,%esp
c002d079:	50                   	push   %eax
c002d07a:	6a 1f                	push   $0x1f
c002d07c:	68 2c 27 03 c0       	push   $0xc003272c
c002d081:	e8 37 f3 ff ff       	call   c002c3bd <msg>
c002d086:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002d089:	90                   	nop
c002d08a:	c9                   	leave  
c002d08b:	c3                   	ret    

c002d08c <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002d08c:	55                   	push   %ebp
c002d08d:	89 e5                	mov    %esp,%ebp
c002d08f:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d092:	8b 45 08             	mov    0x8(%ebp),%eax
c002d095:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d098:	83 ec 0c             	sub    $0xc,%esp
c002d09b:	ff 75 f4             	pushl  -0xc(%ebp)
c002d09e:	e8 0c 60 ff ff       	call   c00230af <lock_acquire>
c002d0a3:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002d0a6:	83 ec 0c             	sub    $0xc,%esp
c002d0a9:	68 b4 27 03 c0       	push   $0xc00327b4
c002d0ae:	e8 0a f3 ff ff       	call   c002c3bd <msg>
c002d0b3:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d0b6:	83 ec 0c             	sub    $0xc,%esp
c002d0b9:	ff 75 f4             	pushl  -0xc(%ebp)
c002d0bc:	e8 1f 62 ff ff       	call   c00232e0 <lock_release>
c002d0c1:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002d0c4:	83 ec 0c             	sub    $0xc,%esp
c002d0c7:	68 ce 27 03 c0       	push   $0xc00327ce
c002d0cc:	e8 ec f2 ff ff       	call   c002c3bd <msg>
c002d0d1:	83 c4 10             	add    $0x10,%esp
}
c002d0d4:	90                   	nop
c002d0d5:	c9                   	leave  
c002d0d6:	c3                   	ret    

c002d0d7 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002d0d7:	55                   	push   %ebp
c002d0d8:	89 e5                	mov    %esp,%ebp
c002d0da:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d0dd:	8b 45 08             	mov    0x8(%ebp),%eax
c002d0e0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d0e3:	83 ec 0c             	sub    $0xc,%esp
c002d0e6:	ff 75 f4             	pushl  -0xc(%ebp)
c002d0e9:	e8 c1 5f ff ff       	call   c00230af <lock_acquire>
c002d0ee:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002d0f1:	83 ec 0c             	sub    $0xc,%esp
c002d0f4:	68 e1 27 03 c0       	push   $0xc00327e1
c002d0f9:	e8 bf f2 ff ff       	call   c002c3bd <msg>
c002d0fe:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d101:	83 ec 0c             	sub    $0xc,%esp
c002d104:	ff 75 f4             	pushl  -0xc(%ebp)
c002d107:	e8 d4 61 ff ff       	call   c00232e0 <lock_release>
c002d10c:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002d10f:	83 ec 0c             	sub    $0xc,%esp
c002d112:	68 fb 27 03 c0       	push   $0xc00327fb
c002d117:	e8 a1 f2 ff ff       	call   c002c3bd <msg>
c002d11c:	83 c4 10             	add    $0x10,%esp
}
c002d11f:	90                   	nop
c002d120:	c9                   	leave  
c002d121:	c3                   	ret    

c002d122 <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002d122:	55                   	push   %ebp
c002d123:	89 e5                	mov    %esp,%ebp
c002d125:	83 ec 58             	sub    $0x58,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d128:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002d12d:	83 f0 01             	xor    $0x1,%eax
c002d130:	84 c0                	test   %al,%al
c002d132:	75 1e                	jne    c002d152 <test_priority_donate_multiple2+0x30>
c002d134:	83 ec 0c             	sub    $0xc,%esp
c002d137:	68 30 28 03 c0       	push   $0xc0032830
c002d13c:	68 3e 28 03 c0       	push   $0xc003283e
c002d141:	68 98 29 03 c0       	push   $0xc0032998
c002d146:	6a 21                	push   $0x21
c002d148:	68 58 28 03 c0       	push   $0xc0032858
c002d14d:	e8 d0 ce ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d152:	e8 b6 3d ff ff       	call   c0020f0d <thread_get_priority>
c002d157:	83 f8 1f             	cmp    $0x1f,%eax
c002d15a:	74 1e                	je     c002d17a <test_priority_donate_multiple2+0x58>
c002d15c:	83 ec 0c             	sub    $0xc,%esp
c002d15f:	68 88 28 03 c0       	push   $0xc0032888
c002d164:	68 3e 28 03 c0       	push   $0xc003283e
c002d169:	68 98 29 03 c0       	push   $0xc0032998
c002d16e:	6a 24                	push   $0x24
c002d170:	68 58 28 03 c0       	push   $0xc0032858
c002d175:	e8 a8 ce ff ff       	call   c002a022 <debug_panic>

  lock_init (&a);
c002d17a:	83 ec 0c             	sub    $0xc,%esp
c002d17d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d180:	50                   	push   %eax
c002d181:	e8 dc 5e ff ff       	call   c0023062 <lock_init>
c002d186:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002d189:	83 ec 0c             	sub    $0xc,%esp
c002d18c:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d18f:	50                   	push   %eax
c002d190:	e8 cd 5e ff ff       	call   c0023062 <lock_init>
c002d195:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002d198:	83 ec 0c             	sub    $0xc,%esp
c002d19b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d19e:	50                   	push   %eax
c002d19f:	e8 0b 5f ff ff       	call   c00230af <lock_acquire>
c002d1a4:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002d1a7:	83 ec 0c             	sub    $0xc,%esp
c002d1aa:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d1ad:	50                   	push   %eax
c002d1ae:	e8 fc 5e ff ff       	call   c00230af <lock_acquire>
c002d1b3:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002d1b6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d1b9:	50                   	push   %eax
c002d1ba:	68 8d d2 02 c0       	push   $0xc002d28d
c002d1bf:	6a 22                	push   $0x22
c002d1c1:	68 ae 28 03 c0       	push   $0xc00328ae
c002d1c6:	e8 91 38 ff ff       	call   c0020a5c <thread_create>
c002d1cb:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d1ce:	e8 3a 3d ff ff       	call   c0020f0d <thread_get_priority>
c002d1d3:	83 ec 04             	sub    $0x4,%esp
c002d1d6:	50                   	push   %eax
c002d1d7:	6a 22                	push   $0x22
c002d1d9:	68 b0 28 03 c0       	push   $0xc00328b0
c002d1de:	e8 da f1 ff ff       	call   c002c3bd <msg>
c002d1e3:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002d1e6:	6a 00                	push   $0x0
c002d1e8:	68 23 d3 02 c0       	push   $0xc002d323
c002d1ed:	6a 20                	push   $0x20
c002d1ef:	68 eb 28 03 c0       	push   $0xc00328eb
c002d1f4:	e8 63 38 ff ff       	call   c0020a5c <thread_create>
c002d1f9:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002d1fc:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d1ff:	50                   	push   %eax
c002d200:	68 d8 d2 02 c0       	push   $0xc002d2d8
c002d205:	6a 24                	push   $0x24
c002d207:	68 ed 28 03 c0       	push   $0xc00328ed
c002d20c:	e8 4b 38 ff ff       	call   c0020a5c <thread_create>
c002d211:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d214:	e8 f4 3c ff ff       	call   c0020f0d <thread_get_priority>
c002d219:	83 ec 04             	sub    $0x4,%esp
c002d21c:	50                   	push   %eax
c002d21d:	6a 24                	push   $0x24
c002d21f:	68 b0 28 03 c0       	push   $0xc00328b0
c002d224:	e8 94 f1 ff ff       	call   c002c3bd <msg>
c002d229:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002d22c:	83 ec 0c             	sub    $0xc,%esp
c002d22f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d232:	50                   	push   %eax
c002d233:	e8 a8 60 ff ff       	call   c00232e0 <lock_release>
c002d238:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d23b:	e8 cd 3c ff ff       	call   c0020f0d <thread_get_priority>
c002d240:	83 ec 04             	sub    $0x4,%esp
c002d243:	50                   	push   %eax
c002d244:	6a 24                	push   $0x24
c002d246:	68 b0 28 03 c0       	push   $0xc00328b0
c002d24b:	e8 6d f1 ff ff       	call   c002c3bd <msg>
c002d250:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002d253:	83 ec 0c             	sub    $0xc,%esp
c002d256:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d259:	50                   	push   %eax
c002d25a:	e8 81 60 ff ff       	call   c00232e0 <lock_release>
c002d25f:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002d262:	83 ec 0c             	sub    $0xc,%esp
c002d265:	68 f0 28 03 c0       	push   $0xc00328f0
c002d26a:	e8 4e f1 ff ff       	call   c002c3bd <msg>
c002d26f:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d272:	e8 96 3c ff ff       	call   c0020f0d <thread_get_priority>
c002d277:	83 ec 04             	sub    $0x4,%esp
c002d27a:	50                   	push   %eax
c002d27b:	6a 1f                	push   $0x1f
c002d27d:	68 b0 28 03 c0       	push   $0xc00328b0
c002d282:	e8 36 f1 ff ff       	call   c002c3bd <msg>
c002d287:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002d28a:	90                   	nop
c002d28b:	c9                   	leave  
c002d28c:	c3                   	ret    

c002d28d <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002d28d:	55                   	push   %ebp
c002d28e:	89 e5                	mov    %esp,%ebp
c002d290:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d293:	8b 45 08             	mov    0x8(%ebp),%eax
c002d296:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d299:	83 ec 0c             	sub    $0xc,%esp
c002d29c:	ff 75 f4             	pushl  -0xc(%ebp)
c002d29f:	e8 0b 5e ff ff       	call   c00230af <lock_acquire>
c002d2a4:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002d2a7:	83 ec 0c             	sub    $0xc,%esp
c002d2aa:	68 2a 29 03 c0       	push   $0xc003292a
c002d2af:	e8 09 f1 ff ff       	call   c002c3bd <msg>
c002d2b4:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d2b7:	83 ec 0c             	sub    $0xc,%esp
c002d2ba:	ff 75 f4             	pushl  -0xc(%ebp)
c002d2bd:	e8 1e 60 ff ff       	call   c00232e0 <lock_release>
c002d2c2:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002d2c5:	83 ec 0c             	sub    $0xc,%esp
c002d2c8:	68 44 29 03 c0       	push   $0xc0032944
c002d2cd:	e8 eb f0 ff ff       	call   c002c3bd <msg>
c002d2d2:	83 c4 10             	add    $0x10,%esp
}
c002d2d5:	90                   	nop
c002d2d6:	c9                   	leave  
c002d2d7:	c3                   	ret    

c002d2d8 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002d2d8:	55                   	push   %ebp
c002d2d9:	89 e5                	mov    %esp,%ebp
c002d2db:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d2de:	8b 45 08             	mov    0x8(%ebp),%eax
c002d2e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d2e4:	83 ec 0c             	sub    $0xc,%esp
c002d2e7:	ff 75 f4             	pushl  -0xc(%ebp)
c002d2ea:	e8 c0 5d ff ff       	call   c00230af <lock_acquire>
c002d2ef:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002d2f2:	83 ec 0c             	sub    $0xc,%esp
c002d2f5:	68 57 29 03 c0       	push   $0xc0032957
c002d2fa:	e8 be f0 ff ff       	call   c002c3bd <msg>
c002d2ff:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d302:	83 ec 0c             	sub    $0xc,%esp
c002d305:	ff 75 f4             	pushl  -0xc(%ebp)
c002d308:	e8 d3 5f ff ff       	call   c00232e0 <lock_release>
c002d30d:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002d310:	83 ec 0c             	sub    $0xc,%esp
c002d313:	68 71 29 03 c0       	push   $0xc0032971
c002d318:	e8 a0 f0 ff ff       	call   c002c3bd <msg>
c002d31d:	83 c4 10             	add    $0x10,%esp
}
c002d320:	90                   	nop
c002d321:	c9                   	leave  
c002d322:	c3                   	ret    

c002d323 <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002d323:	55                   	push   %ebp
c002d324:	89 e5                	mov    %esp,%ebp
c002d326:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread c finished.");
c002d329:	83 ec 0c             	sub    $0xc,%esp
c002d32c:	68 84 29 03 c0       	push   $0xc0032984
c002d331:	e8 87 f0 ff ff       	call   c002c3bd <msg>
c002d336:	83 c4 10             	add    $0x10,%esp
}
c002d339:	90                   	nop
c002d33a:	c9                   	leave  
c002d33b:	c3                   	ret    

c002d33c <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002d33c:	55                   	push   %ebp
c002d33d:	89 e5                	mov    %esp,%ebp
c002d33f:	83 ec 58             	sub    $0x58,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d342:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002d347:	83 f0 01             	xor    $0x1,%eax
c002d34a:	84 c0                	test   %al,%al
c002d34c:	75 1e                	jne    c002d36c <test_priority_donate_nest+0x30>
c002d34e:	83 ec 0c             	sub    $0xc,%esp
c002d351:	68 b8 29 03 c0       	push   $0xc00329b8
c002d356:	68 c6 29 03 c0       	push   $0xc00329c6
c002d35b:	68 74 2b 03 c0       	push   $0xc0032b74
c002d360:	6a 22                	push   $0x22
c002d362:	68 e0 29 03 c0       	push   $0xc00329e0
c002d367:	e8 b6 cc ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d36c:	e8 9c 3b ff ff       	call   c0020f0d <thread_get_priority>
c002d371:	83 f8 1f             	cmp    $0x1f,%eax
c002d374:	74 1e                	je     c002d394 <test_priority_donate_nest+0x58>
c002d376:	83 ec 0c             	sub    $0xc,%esp
c002d379:	68 0c 2a 03 c0       	push   $0xc0032a0c
c002d37e:	68 c6 29 03 c0       	push   $0xc00329c6
c002d383:	68 74 2b 03 c0       	push   $0xc0032b74
c002d388:	6a 25                	push   $0x25
c002d38a:	68 e0 29 03 c0       	push   $0xc00329e0
c002d38f:	e8 8e cc ff ff       	call   c002a022 <debug_panic>

  lock_init (&a);
c002d394:	83 ec 0c             	sub    $0xc,%esp
c002d397:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d39a:	50                   	push   %eax
c002d39b:	e8 c2 5c ff ff       	call   c0023062 <lock_init>
c002d3a0:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002d3a3:	83 ec 0c             	sub    $0xc,%esp
c002d3a6:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d3a9:	50                   	push   %eax
c002d3aa:	e8 b3 5c ff ff       	call   c0023062 <lock_init>
c002d3af:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002d3b2:	83 ec 0c             	sub    $0xc,%esp
c002d3b5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d3b8:	50                   	push   %eax
c002d3b9:	e8 f1 5c ff ff       	call   c00230af <lock_acquire>
c002d3be:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002d3c1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d3c4:	89 45 a8             	mov    %eax,-0x58(%ebp)
  locks.b = &b;
c002d3c7:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d3ca:	89 45 ac             	mov    %eax,-0x54(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002d3cd:	8d 45 a8             	lea    -0x58(%ebp),%eax
c002d3d0:	50                   	push   %eax
c002d3d1:	68 76 d4 02 c0       	push   $0xc002d476
c002d3d6:	6a 20                	push   $0x20
c002d3d8:	68 32 2a 03 c0       	push   $0xc0032a32
c002d3dd:	e8 7a 36 ff ff       	call   c0020a5c <thread_create>
c002d3e2:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d3e5:	e8 97 39 ff ff       	call   c0020d81 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002d3ea:	e8 1e 3b ff ff       	call   c0020f0d <thread_get_priority>
c002d3ef:	83 ec 04             	sub    $0x4,%esp
c002d3f2:	50                   	push   %eax
c002d3f3:	6a 20                	push   $0x20
c002d3f5:	68 3c 2a 03 c0       	push   $0xc0032a3c
c002d3fa:	e8 be ef ff ff       	call   c002c3bd <msg>
c002d3ff:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002d402:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002d405:	50                   	push   %eax
c002d406:	68 1d d5 02 c0       	push   $0xc002d51d
c002d40b:	6a 21                	push   $0x21
c002d40d:	68 76 2a 03 c0       	push   $0xc0032a76
c002d412:	e8 45 36 ff ff       	call   c0020a5c <thread_create>
c002d417:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d41a:	e8 62 39 ff ff       	call   c0020d81 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002d41f:	e8 e9 3a ff ff       	call   c0020f0d <thread_get_priority>
c002d424:	83 ec 04             	sub    $0x4,%esp
c002d427:	50                   	push   %eax
c002d428:	6a 21                	push   $0x21
c002d42a:	68 3c 2a 03 c0       	push   $0xc0032a3c
c002d42f:	e8 89 ef ff ff       	call   c002c3bd <msg>
c002d434:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002d437:	83 ec 0c             	sub    $0xc,%esp
c002d43a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d43d:	50                   	push   %eax
c002d43e:	e8 9d 5e ff ff       	call   c00232e0 <lock_release>
c002d443:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d446:	e8 36 39 ff ff       	call   c0020d81 <thread_yield>
  msg ("Medium thread should just have finished.");
c002d44b:	83 ec 0c             	sub    $0xc,%esp
c002d44e:	68 7c 2a 03 c0       	push   $0xc0032a7c
c002d453:	e8 65 ef ff ff       	call   c002c3bd <msg>
c002d458:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002d45b:	e8 ad 3a ff ff       	call   c0020f0d <thread_get_priority>
c002d460:	83 ec 04             	sub    $0x4,%esp
c002d463:	50                   	push   %eax
c002d464:	6a 1f                	push   $0x1f
c002d466:	68 3c 2a 03 c0       	push   $0xc0032a3c
c002d46b:	e8 4d ef ff ff       	call   c002c3bd <msg>
c002d470:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002d473:	90                   	nop
c002d474:	c9                   	leave  
c002d475:	c3                   	ret    

c002d476 <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002d476:	55                   	push   %ebp
c002d477:	89 e5                	mov    %esp,%ebp
c002d479:	83 ec 18             	sub    $0x18,%esp
  struct locks *locks = locks_;
c002d47c:	8b 45 08             	mov    0x8(%ebp),%eax
c002d47f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002d482:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d485:	8b 40 04             	mov    0x4(%eax),%eax
c002d488:	83 ec 0c             	sub    $0xc,%esp
c002d48b:	50                   	push   %eax
c002d48c:	e8 1e 5c ff ff       	call   c00230af <lock_acquire>
c002d491:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002d494:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d497:	8b 00                	mov    (%eax),%eax
c002d499:	83 ec 0c             	sub    $0xc,%esp
c002d49c:	50                   	push   %eax
c002d49d:	e8 0d 5c ff ff       	call   c00230af <lock_acquire>
c002d4a2:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002d4a5:	e8 63 3a ff ff       	call   c0020f0d <thread_get_priority>
c002d4aa:	83 ec 04             	sub    $0x4,%esp
c002d4ad:	50                   	push   %eax
c002d4ae:	6a 21                	push   $0x21
c002d4b0:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002d4b5:	e8 03 ef ff ff       	call   c002c3bd <msg>
c002d4ba:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002d4bd:	83 ec 0c             	sub    $0xc,%esp
c002d4c0:	68 e5 2a 03 c0       	push   $0xc0032ae5
c002d4c5:	e8 f3 ee ff ff       	call   c002c3bd <msg>
c002d4ca:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002d4cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4d0:	8b 00                	mov    (%eax),%eax
c002d4d2:	83 ec 0c             	sub    $0xc,%esp
c002d4d5:	50                   	push   %eax
c002d4d6:	e8 05 5e ff ff       	call   c00232e0 <lock_release>
c002d4db:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d4de:	e8 9e 38 ff ff       	call   c0020d81 <thread_yield>

  lock_release (locks->b);
c002d4e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4e6:	8b 40 04             	mov    0x4(%eax),%eax
c002d4e9:	83 ec 0c             	sub    $0xc,%esp
c002d4ec:	50                   	push   %eax
c002d4ed:	e8 ee 5d ff ff       	call   c00232e0 <lock_release>
c002d4f2:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d4f5:	e8 87 38 ff ff       	call   c0020d81 <thread_yield>

  msg ("High thread should have just finished.");
c002d4fa:	83 ec 0c             	sub    $0xc,%esp
c002d4fd:	68 04 2b 03 c0       	push   $0xc0032b04
c002d502:	e8 b6 ee ff ff       	call   c002c3bd <msg>
c002d507:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002d50a:	83 ec 0c             	sub    $0xc,%esp
c002d50d:	68 2b 2b 03 c0       	push   $0xc0032b2b
c002d512:	e8 a6 ee ff ff       	call   c002c3bd <msg>
c002d517:	83 c4 10             	add    $0x10,%esp
}
c002d51a:	90                   	nop
c002d51b:	c9                   	leave  
c002d51c:	c3                   	ret    

c002d51d <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002d51d:	55                   	push   %ebp
c002d51e:	89 e5                	mov    %esp,%ebp
c002d520:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d523:	8b 45 08             	mov    0x8(%ebp),%eax
c002d526:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d529:	83 ec 0c             	sub    $0xc,%esp
c002d52c:	ff 75 f4             	pushl  -0xc(%ebp)
c002d52f:	e8 7b 5b ff ff       	call   c00230af <lock_acquire>
c002d534:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002d537:	83 ec 0c             	sub    $0xc,%esp
c002d53a:	68 43 2b 03 c0       	push   $0xc0032b43
c002d53f:	e8 79 ee ff ff       	call   c002c3bd <msg>
c002d544:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d547:	83 ec 0c             	sub    $0xc,%esp
c002d54a:	ff 75 f4             	pushl  -0xc(%ebp)
c002d54d:	e8 8e 5d ff ff       	call   c00232e0 <lock_release>
c002d552:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002d555:	83 ec 0c             	sub    $0xc,%esp
c002d558:	68 5d 2b 03 c0       	push   $0xc0032b5d
c002d55d:	e8 5b ee ff ff       	call   c002c3bd <msg>
c002d562:	83 c4 10             	add    $0x10,%esp
}
c002d565:	90                   	nop
c002d566:	c9                   	leave  
c002d567:	c3                   	ret    

c002d568 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002d568:	55                   	push   %ebp
c002d569:	89 e5                	mov    %esp,%ebp
c002d56b:	83 ec 48             	sub    $0x48,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d56e:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002d573:	83 f0 01             	xor    $0x1,%eax
c002d576:	84 c0                	test   %al,%al
c002d578:	75 1e                	jne    c002d598 <test_priority_donate_sema+0x30>
c002d57a:	83 ec 0c             	sub    $0xc,%esp
c002d57d:	68 90 2b 03 c0       	push   $0xc0032b90
c002d582:	68 9e 2b 03 c0       	push   $0xc0032b9e
c002d587:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002d58c:	6a 23                	push   $0x23
c002d58e:	68 b8 2b 03 c0       	push   $0xc0032bb8
c002d593:	e8 8a ca ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d598:	e8 70 39 ff ff       	call   c0020f0d <thread_get_priority>
c002d59d:	83 f8 1f             	cmp    $0x1f,%eax
c002d5a0:	74 1e                	je     c002d5c0 <test_priority_donate_sema+0x58>
c002d5a2:	83 ec 0c             	sub    $0xc,%esp
c002d5a5:	68 e4 2b 03 c0       	push   $0xc0032be4
c002d5aa:	68 9e 2b 03 c0       	push   $0xc0032b9e
c002d5af:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002d5b4:	6a 26                	push   $0x26
c002d5b6:	68 b8 2b 03 c0       	push   $0xc0032bb8
c002d5bb:	e8 62 ca ff ff       	call   c002a022 <debug_panic>

  lock_init (&ls.lock);
c002d5c0:	83 ec 0c             	sub    $0xc,%esp
c002d5c3:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002d5c6:	50                   	push   %eax
c002d5c7:	e8 96 5a ff ff       	call   c0023062 <lock_init>
c002d5cc:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002d5cf:	83 ec 08             	sub    $0x8,%esp
c002d5d2:	6a 00                	push   $0x0
c002d5d4:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002d5d7:	83 c0 24             	add    $0x24,%eax
c002d5da:	50                   	push   %eax
c002d5db:	e8 9c 57 ff ff       	call   c0022d7c <sema_init>
c002d5e0:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002d5e3:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002d5e6:	50                   	push   %eax
c002d5e7:	68 50 d6 02 c0       	push   $0xc002d650
c002d5ec:	6a 20                	push   $0x20
c002d5ee:	68 0a 2c 03 c0       	push   $0xc0032c0a
c002d5f3:	e8 64 34 ff ff       	call   c0020a5c <thread_create>
c002d5f8:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002d5fb:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002d5fe:	50                   	push   %eax
c002d5ff:	68 bf d6 02 c0       	push   $0xc002d6bf
c002d604:	6a 22                	push   $0x22
c002d606:	68 0e 2c 03 c0       	push   $0xc0032c0e
c002d60b:	e8 4c 34 ff ff       	call   c0020a5c <thread_create>
c002d610:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002d613:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002d616:	50                   	push   %eax
c002d617:	68 f0 d6 02 c0       	push   $0xc002d6f0
c002d61c:	6a 24                	push   $0x24
c002d61e:	68 12 2c 03 c0       	push   $0xc0032c12
c002d623:	e8 34 34 ff ff       	call   c0020a5c <thread_create>
c002d628:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002d62b:	83 ec 0c             	sub    $0xc,%esp
c002d62e:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002d631:	83 c0 24             	add    $0x24,%eax
c002d634:	50                   	push   %eax
c002d635:	e8 97 58 ff ff       	call   c0022ed1 <sema_up>
c002d63a:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002d63d:	83 ec 0c             	sub    $0xc,%esp
c002d640:	68 17 2c 03 c0       	push   $0xc0032c17
c002d645:	e8 73 ed ff ff       	call   c002c3bd <msg>
c002d64a:	83 c4 10             	add    $0x10,%esp
}
c002d64d:	90                   	nop
c002d64e:	c9                   	leave  
c002d64f:	c3                   	ret    

c002d650 <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002d650:	55                   	push   %ebp
c002d651:	89 e5                	mov    %esp,%ebp
c002d653:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002d656:	8b 45 08             	mov    0x8(%ebp),%eax
c002d659:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002d65c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d65f:	83 ec 0c             	sub    $0xc,%esp
c002d662:	50                   	push   %eax
c002d663:	e8 47 5a ff ff       	call   c00230af <lock_acquire>
c002d668:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002d66b:	83 ec 0c             	sub    $0xc,%esp
c002d66e:	68 2d 2c 03 c0       	push   $0xc0032c2d
c002d673:	e8 45 ed ff ff       	call   c002c3bd <msg>
c002d678:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002d67b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d67e:	83 c0 24             	add    $0x24,%eax
c002d681:	83 ec 0c             	sub    $0xc,%esp
c002d684:	50                   	push   %eax
c002d685:	e8 39 57 ff ff       	call   c0022dc3 <sema_down>
c002d68a:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002d68d:	83 ec 0c             	sub    $0xc,%esp
c002d690:	68 45 2c 03 c0       	push   $0xc0032c45
c002d695:	e8 23 ed ff ff       	call   c002c3bd <msg>
c002d69a:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002d69d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d6a0:	83 ec 0c             	sub    $0xc,%esp
c002d6a3:	50                   	push   %eax
c002d6a4:	e8 37 5c ff ff       	call   c00232e0 <lock_release>
c002d6a9:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002d6ac:	83 ec 0c             	sub    $0xc,%esp
c002d6af:	68 60 2c 03 c0       	push   $0xc0032c60
c002d6b4:	e8 04 ed ff ff       	call   c002c3bd <msg>
c002d6b9:	83 c4 10             	add    $0x10,%esp
}
c002d6bc:	90                   	nop
c002d6bd:	c9                   	leave  
c002d6be:	c3                   	ret    

c002d6bf <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002d6bf:	55                   	push   %ebp
c002d6c0:	89 e5                	mov    %esp,%ebp
c002d6c2:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002d6c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002d6c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002d6cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d6ce:	83 c0 24             	add    $0x24,%eax
c002d6d1:	83 ec 0c             	sub    $0xc,%esp
c002d6d4:	50                   	push   %eax
c002d6d5:	e8 e9 56 ff ff       	call   c0022dc3 <sema_down>
c002d6da:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002d6dd:	83 ec 0c             	sub    $0xc,%esp
c002d6e0:	68 73 2c 03 c0       	push   $0xc0032c73
c002d6e5:	e8 d3 ec ff ff       	call   c002c3bd <msg>
c002d6ea:	83 c4 10             	add    $0x10,%esp
}
c002d6ed:	90                   	nop
c002d6ee:	c9                   	leave  
c002d6ef:	c3                   	ret    

c002d6f0 <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002d6f0:	55                   	push   %ebp
c002d6f1:	89 e5                	mov    %esp,%ebp
c002d6f3:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002d6f6:	8b 45 08             	mov    0x8(%ebp),%eax
c002d6f9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002d6fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d6ff:	83 ec 0c             	sub    $0xc,%esp
c002d702:	50                   	push   %eax
c002d703:	e8 a7 59 ff ff       	call   c00230af <lock_acquire>
c002d708:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002d70b:	83 ec 0c             	sub    $0xc,%esp
c002d70e:	68 86 2c 03 c0       	push   $0xc0032c86
c002d713:	e8 a5 ec ff ff       	call   c002c3bd <msg>
c002d718:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002d71b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d71e:	83 c0 24             	add    $0x24,%eax
c002d721:	83 ec 0c             	sub    $0xc,%esp
c002d724:	50                   	push   %eax
c002d725:	e8 a7 57 ff ff       	call   c0022ed1 <sema_up>
c002d72a:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002d72d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d730:	83 ec 0c             	sub    $0xc,%esp
c002d733:	50                   	push   %eax
c002d734:	e8 a7 5b ff ff       	call   c00232e0 <lock_release>
c002d739:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002d73c:	83 ec 0c             	sub    $0xc,%esp
c002d73f:	68 9e 2c 03 c0       	push   $0xc0032c9e
c002d744:	e8 74 ec ff ff       	call   c002c3bd <msg>
c002d749:	83 c4 10             	add    $0x10,%esp
}
c002d74c:	90                   	nop
c002d74d:	c9                   	leave  
c002d74e:	c3                   	ret    

c002d74f <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002d74f:	55                   	push   %ebp
c002d750:	89 e5                	mov    %esp,%ebp
c002d752:	83 ec 38             	sub    $0x38,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d755:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002d75a:	83 f0 01             	xor    $0x1,%eax
c002d75d:	84 c0                	test   %al,%al
c002d75f:	75 1e                	jne    c002d77f <test_priority_donate_lower+0x30>
c002d761:	83 ec 0c             	sub    $0xc,%esp
c002d764:	68 d0 2c 03 c0       	push   $0xc0032cd0
c002d769:	68 de 2c 03 c0       	push   $0xc0032cde
c002d76e:	68 f4 2d 03 c0       	push   $0xc0032df4
c002d773:	6a 15                	push   $0x15
c002d775:	68 f8 2c 03 c0       	push   $0xc0032cf8
c002d77a:	e8 a3 c8 ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d77f:	e8 89 37 ff ff       	call   c0020f0d <thread_get_priority>
c002d784:	83 f8 1f             	cmp    $0x1f,%eax
c002d787:	74 1e                	je     c002d7a7 <test_priority_donate_lower+0x58>
c002d789:	83 ec 0c             	sub    $0xc,%esp
c002d78c:	68 24 2d 03 c0       	push   $0xc0032d24
c002d791:	68 de 2c 03 c0       	push   $0xc0032cde
c002d796:	68 f4 2d 03 c0       	push   $0xc0032df4
c002d79b:	6a 18                	push   $0x18
c002d79d:	68 f8 2c 03 c0       	push   $0xc0032cf8
c002d7a2:	e8 7b c8 ff ff       	call   c002a022 <debug_panic>

  lock_init (&lock);
c002d7a7:	83 ec 0c             	sub    $0xc,%esp
c002d7aa:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d7ad:	50                   	push   %eax
c002d7ae:	e8 af 58 ff ff       	call   c0023062 <lock_init>
c002d7b3:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002d7b6:	83 ec 0c             	sub    $0xc,%esp
c002d7b9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d7bc:	50                   	push   %eax
c002d7bd:	e8 ed 58 ff ff       	call   c00230af <lock_acquire>
c002d7c2:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002d7c5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d7c8:	50                   	push   %eax
c002d7c9:	68 64 d8 02 c0       	push   $0xc002d864
c002d7ce:	6a 29                	push   $0x29
c002d7d0:	68 4a 2d 03 c0       	push   $0xc0032d4a
c002d7d5:	e8 82 32 ff ff       	call   c0020a5c <thread_create>
c002d7da:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d7dd:	e8 2b 37 ff ff       	call   c0020f0d <thread_get_priority>
c002d7e2:	83 ec 04             	sub    $0x4,%esp
c002d7e5:	50                   	push   %eax
c002d7e6:	6a 29                	push   $0x29
c002d7e8:	68 54 2d 03 c0       	push   $0xc0032d54
c002d7ed:	e8 cb eb ff ff       	call   c002c3bd <msg>
c002d7f2:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002d7f5:	83 ec 0c             	sub    $0xc,%esp
c002d7f8:	68 8f 2d 03 c0       	push   $0xc0032d8f
c002d7fd:	e8 bb eb ff ff       	call   c002c3bd <msg>
c002d802:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002d805:	83 ec 0c             	sub    $0xc,%esp
c002d808:	6a 15                	push   $0x15
c002d80a:	e8 85 36 ff ff       	call   c0020e94 <thread_set_priority>
c002d80f:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d812:	e8 f6 36 ff ff       	call   c0020f0d <thread_get_priority>
c002d817:	83 ec 04             	sub    $0x4,%esp
c002d81a:	50                   	push   %eax
c002d81b:	6a 29                	push   $0x29
c002d81d:	68 54 2d 03 c0       	push   $0xc0032d54
c002d822:	e8 96 eb ff ff       	call   c002c3bd <msg>
c002d827:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002d82a:	83 ec 0c             	sub    $0xc,%esp
c002d82d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d830:	50                   	push   %eax
c002d831:	e8 aa 5a ff ff       	call   c00232e0 <lock_release>
c002d836:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002d839:	83 ec 0c             	sub    $0xc,%esp
c002d83c:	68 ac 2d 03 c0       	push   $0xc0032dac
c002d841:	e8 77 eb ff ff       	call   c002c3bd <msg>
c002d846:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d849:	e8 bf 36 ff ff       	call   c0020f0d <thread_get_priority>
c002d84e:	83 ec 04             	sub    $0x4,%esp
c002d851:	50                   	push   %eax
c002d852:	6a 15                	push   $0x15
c002d854:	68 54 2d 03 c0       	push   $0xc0032d54
c002d859:	e8 5f eb ff ff       	call   c002c3bd <msg>
c002d85e:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002d861:	90                   	nop
c002d862:	c9                   	leave  
c002d863:	c3                   	ret    

c002d864 <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002d864:	55                   	push   %ebp
c002d865:	89 e5                	mov    %esp,%ebp
c002d867:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d86a:	8b 45 08             	mov    0x8(%ebp),%eax
c002d86d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d870:	83 ec 0c             	sub    $0xc,%esp
c002d873:	ff 75 f4             	pushl  -0xc(%ebp)
c002d876:	e8 34 58 ff ff       	call   c00230af <lock_acquire>
c002d87b:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002d87e:	83 ec 0c             	sub    $0xc,%esp
c002d881:	68 d0 2d 03 c0       	push   $0xc0032dd0
c002d886:	e8 32 eb ff ff       	call   c002c3bd <msg>
c002d88b:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d88e:	83 ec 0c             	sub    $0xc,%esp
c002d891:	ff 75 f4             	pushl  -0xc(%ebp)
c002d894:	e8 47 5a ff ff       	call   c00232e0 <lock_release>
c002d899:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002d89c:	83 ec 0c             	sub    $0xc,%esp
c002d89f:	68 e6 2d 03 c0       	push   $0xc0032de6
c002d8a4:	e8 14 eb ff ff       	call   c002c3bd <msg>
c002d8a9:	83 c4 10             	add    $0x10,%esp
}
c002d8ac:	90                   	nop
c002d8ad:	c9                   	leave  
c002d8ae:	c3                   	ret    

c002d8af <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002d8af:	55                   	push   %ebp
c002d8b0:	89 e5                	mov    %esp,%ebp
c002d8b2:	81 ec 58 01 00 00    	sub    $0x158,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d8b8:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002d8bd:	83 f0 01             	xor    $0x1,%eax
c002d8c0:	84 c0                	test   %al,%al
c002d8c2:	75 1e                	jne    c002d8e2 <test_priority_fifo+0x33>
c002d8c4:	83 ec 0c             	sub    $0xc,%esp
c002d8c7:	68 10 2e 03 c0       	push   $0xc0032e10
c002d8cc:	68 1e 2e 03 c0       	push   $0xc0032e1e
c002d8d1:	68 58 2f 03 c0       	push   $0xc0032f58
c002d8d6:	6a 28                	push   $0x28
c002d8d8:	68 38 2e 03 c0       	push   $0xc0032e38
c002d8dd:	e8 40 c7 ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d8e2:	e8 26 36 ff ff       	call   c0020f0d <thread_get_priority>
c002d8e7:	83 f8 1f             	cmp    $0x1f,%eax
c002d8ea:	74 1e                	je     c002d90a <test_priority_fifo+0x5b>
c002d8ec:	83 ec 0c             	sub    $0xc,%esp
c002d8ef:	68 5c 2e 03 c0       	push   $0xc0032e5c
c002d8f4:	68 1e 2e 03 c0       	push   $0xc0032e1e
c002d8f9:	68 58 2f 03 c0       	push   $0xc0032f58
c002d8fe:	6a 2b                	push   $0x2b
c002d900:	68 38 2e 03 c0       	push   $0xc0032e38
c002d905:	e8 18 c7 ff ff       	call   c002a022 <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002d90a:	83 ec 04             	sub    $0x4,%esp
c002d90d:	6a 10                	push   $0x10
c002d90f:	6a 10                	push   $0x10
c002d911:	68 84 2e 03 c0       	push   $0xc0032e84
c002d916:	e8 a2 ea ff ff       	call   c002c3bd <msg>
c002d91b:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002d91e:	83 ec 0c             	sub    $0xc,%esp
c002d921:	68 c4 2e 03 c0       	push   $0xc0032ec4
c002d926:	e8 92 ea ff ff       	call   c002c3bd <msg>
c002d92b:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002d92e:	83 ec 0c             	sub    $0xc,%esp
c002d931:	68 00 08 00 00       	push   $0x800
c002d936:	e8 8a 63 ff ff       	call   c0023cc5 <malloc>
c002d93b:	83 c4 10             	add    $0x10,%esp
c002d93e:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
c002d944:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
c002d94a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002d94d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d951:	75 1e                	jne    c002d971 <test_priority_fifo+0xc2>
c002d953:	83 ec 0c             	sub    $0xc,%esp
c002d956:	68 ed 2e 03 c0       	push   $0xc0032eed
c002d95b:	68 1e 2e 03 c0       	push   $0xc0032e1e
c002d960:	68 58 2f 03 c0       	push   $0xc0032f58
c002d965:	6a 32                	push   $0x32
c002d967:	68 38 2e 03 c0       	push   $0xc0032e38
c002d96c:	e8 b1 c6 ff ff       	call   c002a022 <debug_panic>
  lock_init (&lock);
c002d971:	83 ec 0c             	sub    $0xc,%esp
c002d974:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
c002d97a:	50                   	push   %eax
c002d97b:	e8 e2 56 ff ff       	call   c0023062 <lock_init>
c002d980:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002d983:	83 ec 0c             	sub    $0xc,%esp
c002d986:	6a 21                	push   $0x21
c002d988:	e8 07 35 ff ff       	call   c0020e94 <thread_set_priority>
c002d98d:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d990:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002d997:	eb 72                	jmp    c002da0b <test_priority_fifo+0x15c>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002d999:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d99c:	c1 e0 04             	shl    $0x4,%eax
c002d99f:	89 c2                	mov    %eax,%edx
c002d9a1:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002d9a7:	01 d0                	add    %edx,%eax
c002d9a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002d9ac:	ff 75 f0             	pushl  -0x10(%ebp)
c002d9af:	68 fc 2e 03 c0       	push   $0xc0032efc
c002d9b4:	6a 10                	push   $0x10
c002d9b6:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
c002d9bc:	50                   	push   %eax
c002d9bd:	e8 66 a1 ff ff       	call   c0027b28 <snprintf>
c002d9c2:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002d9c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d9c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d9cb:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002d9cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d9d0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002d9d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d9da:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
c002d9e0:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002d9e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d9e6:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
c002d9ec:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002d9ef:	ff 75 e8             	pushl  -0x18(%ebp)
c002d9f2:	68 07 db 02 c0       	push   $0xc002db07
c002d9f7:	6a 20                	push   $0x20
c002d9f9:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
c002d9ff:	50                   	push   %eax
c002da00:	e8 57 30 ff ff       	call   c0020a5c <thread_create>
c002da05:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002da08:	ff 45 f0             	incl   -0x10(%ebp)
c002da0b:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002da0f:	7e 88                	jle    c002d999 <test_priority_fifo+0xea>
    }

  thread_set_priority (PRI_DEFAULT);
c002da11:	83 ec 0c             	sub    $0xc,%esp
c002da14:	6a 1f                	push   $0x1f
c002da16:	e8 79 34 ff ff       	call   c0020e94 <thread_set_priority>
c002da1b:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002da1e:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
c002da24:	85 c0                	test   %eax,%eax
c002da26:	74 1e                	je     c002da46 <test_priority_fifo+0x197>
c002da28:	83 ec 0c             	sub    $0xc,%esp
c002da2b:	68 ff 2e 03 c0       	push   $0xc0032eff
c002da30:	68 1e 2e 03 c0       	push   $0xc0032e1e
c002da35:	68 58 2f 03 c0       	push   $0xc0032f58
c002da3a:	6a 44                	push   $0x44
c002da3c:	68 38 2e 03 c0       	push   $0xc0032e38
c002da41:	e8 dc c5 ff ff       	call   c002a022 <debug_panic>

  cnt = 0;
c002da46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002da4d:	e9 a3 00 00 00       	jmp    c002daf5 <test_priority_fifo+0x246>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002da52:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002da55:	8b 00                	mov    (%eax),%eax
c002da57:	85 c0                	test   %eax,%eax
c002da59:	78 0a                	js     c002da65 <test_priority_fifo+0x1b6>
c002da5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002da5e:	8b 00                	mov    (%eax),%eax
c002da60:	83 f8 0f             	cmp    $0xf,%eax
c002da63:	7e 1e                	jle    c002da83 <test_priority_fifo+0x1d4>
c002da65:	83 ec 0c             	sub    $0xc,%esp
c002da68:	68 14 2f 03 c0       	push   $0xc0032f14
c002da6d:	68 1e 2e 03 c0       	push   $0xc0032e1e
c002da72:	68 58 2f 03 c0       	push   $0xc0032f58
c002da77:	6a 4b                	push   $0x4b
c002da79:	68 38 2e 03 c0       	push   $0xc0032e38
c002da7e:	e8 9f c5 ff ff       	call   c002a022 <debug_panic>
      d = data + *output;
c002da83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002da86:	8b 00                	mov    (%eax),%eax
c002da88:	c1 e0 04             	shl    $0x4,%eax
c002da8b:	89 c2                	mov    %eax,%edx
c002da8d:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002da93:	01 d0                	add    %edx,%eax
c002da95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (cnt % THREAD_CNT == 0)
c002da98:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002da9b:	83 e0 0f             	and    $0xf,%eax
c002da9e:	85 c0                	test   %eax,%eax
c002daa0:	75 10                	jne    c002dab2 <test_priority_fifo+0x203>
        printf ("(priority-fifo) iteration:");
c002daa2:	83 ec 0c             	sub    $0xc,%esp
c002daa5:	68 39 2f 03 c0       	push   $0xc0032f39
c002daaa:	e8 a2 a0 ff ff       	call   c0027b51 <printf>
c002daaf:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002dab2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002dab5:	8b 00                	mov    (%eax),%eax
c002dab7:	83 ec 08             	sub    $0x8,%esp
c002daba:	50                   	push   %eax
c002dabb:	68 54 2f 03 c0       	push   $0xc0032f54
c002dac0:	e8 8c a0 ff ff       	call   c0027b51 <printf>
c002dac5:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002dac8:	ff 45 ec             	incl   -0x14(%ebp)
c002dacb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002dace:	83 e0 0f             	and    $0xf,%eax
c002dad1:	85 c0                	test   %eax,%eax
c002dad3:	75 0d                	jne    c002dae2 <test_priority_fifo+0x233>
        printf ("\n");
c002dad5:	83 ec 0c             	sub    $0xc,%esp
c002dad8:	6a 0a                	push   $0xa
c002dada:	e8 89 e7 ff ff       	call   c002c268 <putchar>
c002dadf:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002dae2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002dae5:	8b 40 04             	mov    0x4(%eax),%eax
c002dae8:	8d 50 01             	lea    0x1(%eax),%edx
c002daeb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002daee:	89 50 04             	mov    %edx,0x4(%eax)
  for (; output < op; output++) 
c002daf1:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002daf5:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
c002dafb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002dafe:	0f 82 4e ff ff ff    	jb     c002da52 <test_priority_fifo+0x1a3>
    }
}
c002db04:	90                   	nop
c002db05:	c9                   	leave  
c002db06:	c3                   	ret    

c002db07 <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002db07:	55                   	push   %ebp
c002db08:	89 e5                	mov    %esp,%ebp
c002db0a:	83 ec 18             	sub    $0x18,%esp
  struct simple_thread_data *data = data_;
c002db0d:	8b 45 08             	mov    0x8(%ebp),%eax
c002db10:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002db13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002db1a:	eb 40                	jmp    c002db5c <simple_thread_func+0x55>
    {
      lock_acquire (data->lock);
c002db1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002db1f:	8b 40 08             	mov    0x8(%eax),%eax
c002db22:	83 ec 0c             	sub    $0xc,%esp
c002db25:	50                   	push   %eax
c002db26:	e8 84 55 ff ff       	call   c00230af <lock_acquire>
c002db2b:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002db2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002db31:	8b 50 0c             	mov    0xc(%eax),%edx
c002db34:	8b 02                	mov    (%edx),%eax
c002db36:	8d 48 04             	lea    0x4(%eax),%ecx
c002db39:	89 0a                	mov    %ecx,(%edx)
c002db3b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002db3e:	8b 12                	mov    (%edx),%edx
c002db40:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002db42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002db45:	8b 40 08             	mov    0x8(%eax),%eax
c002db48:	83 ec 0c             	sub    $0xc,%esp
c002db4b:	50                   	push   %eax
c002db4c:	e8 8f 57 ff ff       	call   c00232e0 <lock_release>
c002db51:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002db54:	e8 28 32 ff ff       	call   c0020d81 <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002db59:	ff 45 f4             	incl   -0xc(%ebp)
c002db5c:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002db60:	7e ba                	jle    c002db1c <simple_thread_func+0x15>
    }
}
c002db62:	90                   	nop
c002db63:	c9                   	leave  
c002db64:	c3                   	ret    

c002db65 <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002db65:	55                   	push   %ebp
c002db66:	89 e5                	mov    %esp,%ebp
c002db68:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002db6b:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002db70:	83 f0 01             	xor    $0x1,%eax
c002db73:	84 c0                	test   %al,%al
c002db75:	75 1e                	jne    c002db95 <test_priority_preempt+0x30>
c002db77:	83 ec 0c             	sub    $0xc,%esp
c002db7a:	68 6c 2f 03 c0       	push   $0xc0032f6c
c002db7f:	68 7a 2f 03 c0       	push   $0xc0032f7a
c002db84:	68 50 30 03 c0       	push   $0xc0033050
c002db89:	6a 15                	push   $0x15
c002db8b:	68 94 2f 03 c0       	push   $0xc0032f94
c002db90:	e8 8d c4 ff ff       	call   c002a022 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002db95:	e8 73 33 ff ff       	call   c0020f0d <thread_get_priority>
c002db9a:	83 f8 1f             	cmp    $0x1f,%eax
c002db9d:	74 1e                	je     c002dbbd <test_priority_preempt+0x58>
c002db9f:	83 ec 0c             	sub    $0xc,%esp
c002dba2:	68 bc 2f 03 c0       	push   $0xc0032fbc
c002dba7:	68 7a 2f 03 c0       	push   $0xc0032f7a
c002dbac:	68 50 30 03 c0       	push   $0xc0033050
c002dbb1:	6a 18                	push   $0x18
c002dbb3:	68 94 2f 03 c0       	push   $0xc0032f94
c002dbb8:	e8 65 c4 ff ff       	call   c002a022 <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002dbbd:	6a 00                	push   $0x0
c002dbbf:	68 e6 db 02 c0       	push   $0xc002dbe6
c002dbc4:	6a 20                	push   $0x20
c002dbc6:	68 e2 2f 03 c0       	push   $0xc0032fe2
c002dbcb:	e8 8c 2e ff ff       	call   c0020a5c <thread_create>
c002dbd0:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002dbd3:	83 ec 0c             	sub    $0xc,%esp
c002dbd6:	68 f0 2f 03 c0       	push   $0xc0032ff0
c002dbdb:	e8 dd e7 ff ff       	call   c002c3bd <msg>
c002dbe0:	83 c4 10             	add    $0x10,%esp
}
c002dbe3:	90                   	nop
c002dbe4:	c9                   	leave  
c002dbe5:	c3                   	ret    

c002dbe6 <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002dbe6:	55                   	push   %ebp
c002dbe7:	89 e5                	mov    %esp,%ebp
c002dbe9:	83 ec 18             	sub    $0x18,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002dbec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dbf3:	eb 21                	jmp    c002dc16 <simple_thread_func+0x30>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002dbf5:	e8 81 30 ff ff       	call   c0020c7b <thread_name>
c002dbfa:	83 ec 04             	sub    $0x4,%esp
c002dbfd:	ff 75 f4             	pushl  -0xc(%ebp)
c002dc00:	50                   	push   %eax
c002dc01:	68 28 30 03 c0       	push   $0xc0033028
c002dc06:	e8 b2 e7 ff ff       	call   c002c3bd <msg>
c002dc0b:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002dc0e:	e8 6e 31 ff ff       	call   c0020d81 <thread_yield>
  for (i = 0; i < 5; i++) 
c002dc13:	ff 45 f4             	incl   -0xc(%ebp)
c002dc16:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002dc1a:	7e d9                	jle    c002dbf5 <simple_thread_func+0xf>
    }
  msg ("Thread %s done!", thread_name ());
c002dc1c:	e8 5a 30 ff ff       	call   c0020c7b <thread_name>
c002dc21:	83 ec 08             	sub    $0x8,%esp
c002dc24:	50                   	push   %eax
c002dc25:	68 3f 30 03 c0       	push   $0xc003303f
c002dc2a:	e8 8e e7 ff ff       	call   c002c3bd <msg>
c002dc2f:	83 c4 10             	add    $0x10,%esp
}
c002dc32:	90                   	nop
c002dc33:	c9                   	leave  
c002dc34:	c3                   	ret    

c002dc35 <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002dc35:	55                   	push   %ebp
c002dc36:	89 e5                	mov    %esp,%ebp
c002dc38:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002dc3b:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002dc40:	83 f0 01             	xor    $0x1,%eax
c002dc43:	84 c0                	test   %al,%al
c002dc45:	75 1e                	jne    c002dc65 <test_priority_sema+0x30>
c002dc47:	83 ec 0c             	sub    $0xc,%esp
c002dc4a:	68 68 30 03 c0       	push   $0xc0033068
c002dc4f:	68 76 30 03 c0       	push   $0xc0033076
c002dc54:	68 e8 30 03 c0       	push   $0xc00330e8
c002dc59:	6a 15                	push   $0x15
c002dc5b:	68 90 30 03 c0       	push   $0xc0033090
c002dc60:	e8 bd c3 ff ff       	call   c002a022 <debug_panic>

  sema_init (&sema, 0);
c002dc65:	83 ec 08             	sub    $0x8,%esp
c002dc68:	6a 00                	push   $0x0
c002dc6a:	68 bc a0 03 c0       	push   $0xc003a0bc
c002dc6f:	e8 08 51 ff ff       	call   c0022d7c <sema_init>
c002dc74:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002dc77:	83 ec 0c             	sub    $0xc,%esp
c002dc7a:	6a 00                	push   $0x0
c002dc7c:	e8 13 32 ff ff       	call   c0020e94 <thread_set_priority>
c002dc81:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002dc84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dc8b:	eb 4b                	jmp    c002dcd8 <test_priority_sema+0xa3>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002dc8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc90:	83 c0 03             	add    $0x3,%eax
c002dc93:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002dc98:	99                   	cltd   
c002dc99:	f7 f9                	idiv   %ecx
c002dc9b:	89 d0                	mov    %edx,%eax
c002dc9d:	ba 1e 00 00 00       	mov    $0x1e,%edx
c002dca2:	29 c2                	sub    %eax,%edx
c002dca4:	89 d0                	mov    %edx,%eax
c002dca6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002dca9:	ff 75 f0             	pushl  -0x10(%ebp)
c002dcac:	68 b4 30 03 c0       	push   $0xc00330b4
c002dcb1:	6a 10                	push   $0x10
c002dcb3:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002dcb6:	50                   	push   %eax
c002dcb7:	e8 6c 9e ff ff       	call   c0027b28 <snprintf>
c002dcbc:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002dcbf:	6a 00                	push   $0x0
c002dcc1:	68 13 dd 02 c0       	push   $0xc002dd13
c002dcc6:	ff 75 f0             	pushl  -0x10(%ebp)
c002dcc9:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002dccc:	50                   	push   %eax
c002dccd:	e8 8a 2d ff ff       	call   c0020a5c <thread_create>
c002dcd2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002dcd5:	ff 45 f4             	incl   -0xc(%ebp)
c002dcd8:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002dcdc:	7e af                	jle    c002dc8d <test_priority_sema+0x58>
    }

  for (i = 0; i < 10; i++) 
c002dcde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dce5:	eb 23                	jmp    c002dd0a <test_priority_sema+0xd5>
    {
      sema_up (&sema);
c002dce7:	83 ec 0c             	sub    $0xc,%esp
c002dcea:	68 bc a0 03 c0       	push   $0xc003a0bc
c002dcef:	e8 dd 51 ff ff       	call   c0022ed1 <sema_up>
c002dcf4:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c002dcf7:	83 ec 0c             	sub    $0xc,%esp
c002dcfa:	68 c0 30 03 c0       	push   $0xc00330c0
c002dcff:	e8 b9 e6 ff ff       	call   c002c3bd <msg>
c002dd04:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002dd07:	ff 45 f4             	incl   -0xc(%ebp)
c002dd0a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002dd0e:	7e d7                	jle    c002dce7 <test_priority_sema+0xb2>
    }
}
c002dd10:	90                   	nop
c002dd11:	c9                   	leave  
c002dd12:	c3                   	ret    

c002dd13 <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c002dd13:	55                   	push   %ebp
c002dd14:	89 e5                	mov    %esp,%ebp
c002dd16:	83 ec 08             	sub    $0x8,%esp
  sema_down (&sema);
c002dd19:	83 ec 0c             	sub    $0xc,%esp
c002dd1c:	68 bc a0 03 c0       	push   $0xc003a0bc
c002dd21:	e8 9d 50 ff ff       	call   c0022dc3 <sema_down>
c002dd26:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002dd29:	e8 4d 2f ff ff       	call   c0020c7b <thread_name>
c002dd2e:	83 ec 08             	sub    $0x8,%esp
c002dd31:	50                   	push   %eax
c002dd32:	68 d5 30 03 c0       	push   $0xc00330d5
c002dd37:	e8 81 e6 ff ff       	call   c002c3bd <msg>
c002dd3c:	83 c4 10             	add    $0x10,%esp
}
c002dd3f:	90                   	nop
c002dd40:	c9                   	leave  
c002dd41:	c3                   	ret    

c002dd42 <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002dd42:	55                   	push   %ebp
c002dd43:	89 e5                	mov    %esp,%ebp
c002dd45:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002dd48:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002dd4d:	83 f0 01             	xor    $0x1,%eax
c002dd50:	84 c0                	test   %al,%al
c002dd52:	75 1e                	jne    c002dd72 <test_priority_condvar+0x30>
c002dd54:	83 ec 0c             	sub    $0xc,%esp
c002dd57:	68 fc 30 03 c0       	push   $0xc00330fc
c002dd5c:	68 0a 31 03 c0       	push   $0xc003310a
c002dd61:	68 8c 31 03 c0       	push   $0xc003318c
c002dd66:	6a 16                	push   $0x16
c002dd68:	68 24 31 03 c0       	push   $0xc0033124
c002dd6d:	e8 b0 c2 ff ff       	call   c002a022 <debug_panic>

  lock_init (&lock);
c002dd72:	83 ec 0c             	sub    $0xc,%esp
c002dd75:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002dd7a:	e8 e3 52 ff ff       	call   c0023062 <lock_init>
c002dd7f:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c002dd82:	83 ec 0c             	sub    $0xc,%esp
c002dd85:	68 04 a1 03 c0       	push   $0xc003a104
c002dd8a:	e8 52 56 ff ff       	call   c00233e1 <cond_init>
c002dd8f:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c002dd92:	83 ec 0c             	sub    $0xc,%esp
c002dd95:	6a 00                	push   $0x0
c002dd97:	e8 f8 30 ff ff       	call   c0020e94 <thread_set_priority>
c002dd9c:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002dd9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dda6:	eb 4b                	jmp    c002ddf3 <test_priority_condvar+0xb1>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002dda8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ddab:	83 c0 07             	add    $0x7,%eax
c002ddae:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002ddb3:	99                   	cltd   
c002ddb4:	f7 f9                	idiv   %ecx
c002ddb6:	89 d0                	mov    %edx,%eax
c002ddb8:	ba 1e 00 00 00       	mov    $0x1e,%edx
c002ddbd:	29 c2                	sub    %eax,%edx
c002ddbf:	89 d0                	mov    %edx,%eax
c002ddc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002ddc4:	ff 75 f0             	pushl  -0x10(%ebp)
c002ddc7:	68 4b 31 03 c0       	push   $0xc003314b
c002ddcc:	6a 10                	push   $0x10
c002ddce:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ddd1:	50                   	push   %eax
c002ddd2:	e8 51 9d ff ff       	call   c0027b28 <snprintf>
c002ddd7:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c002ddda:	6a 00                	push   $0x0
c002dddc:	68 53 de 02 c0       	push   $0xc002de53
c002dde1:	ff 75 f0             	pushl  -0x10(%ebp)
c002dde4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002dde7:	50                   	push   %eax
c002dde8:	e8 6f 2c ff ff       	call   c0020a5c <thread_create>
c002dded:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002ddf0:	ff 45 f4             	incl   -0xc(%ebp)
c002ddf3:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002ddf7:	7e af                	jle    c002dda8 <test_priority_condvar+0x66>
    }

  for (i = 0; i < 10; i++) 
c002ddf9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002de00:	eb 48                	jmp    c002de4a <test_priority_condvar+0x108>
    {
      lock_acquire (&lock);
c002de02:	83 ec 0c             	sub    $0xc,%esp
c002de05:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002de0a:	e8 a0 52 ff ff       	call   c00230af <lock_acquire>
c002de0f:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c002de12:	83 ec 0c             	sub    $0xc,%esp
c002de15:	68 57 31 03 c0       	push   $0xc0033157
c002de1a:	e8 9e e5 ff ff       	call   c002c3bd <msg>
c002de1f:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c002de22:	83 ec 08             	sub    $0x8,%esp
c002de25:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002de2a:	68 04 a1 03 c0       	push   $0xc003a104
c002de2f:	e8 f8 56 ff ff       	call   c002352c <cond_signal>
c002de34:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c002de37:	83 ec 0c             	sub    $0xc,%esp
c002de3a:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002de3f:	e8 9c 54 ff ff       	call   c00232e0 <lock_release>
c002de44:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002de47:	ff 45 f4             	incl   -0xc(%ebp)
c002de4a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002de4e:	7e b2                	jle    c002de02 <test_priority_condvar+0xc0>
    }
}
c002de50:	90                   	nop
c002de51:	c9                   	leave  
c002de52:	c3                   	ret    

c002de53 <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002de53:	55                   	push   %ebp
c002de54:	89 e5                	mov    %esp,%ebp
c002de56:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread %s starting.", thread_name ());
c002de59:	e8 1d 2e ff ff       	call   c0020c7b <thread_name>
c002de5e:	83 ec 08             	sub    $0x8,%esp
c002de61:	50                   	push   %eax
c002de62:	68 64 31 03 c0       	push   $0xc0033164
c002de67:	e8 51 e5 ff ff       	call   c002c3bd <msg>
c002de6c:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002de6f:	83 ec 0c             	sub    $0xc,%esp
c002de72:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002de77:	e8 33 52 ff ff       	call   c00230af <lock_acquire>
c002de7c:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c002de7f:	83 ec 08             	sub    $0x8,%esp
c002de82:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002de87:	68 04 a1 03 c0       	push   $0xc003a104
c002de8c:	e8 8f 55 ff ff       	call   c0023420 <cond_wait>
c002de91:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002de94:	e8 e2 2d ff ff       	call   c0020c7b <thread_name>
c002de99:	83 ec 08             	sub    $0x8,%esp
c002de9c:	50                   	push   %eax
c002de9d:	68 78 31 03 c0       	push   $0xc0033178
c002dea2:	e8 16 e5 ff ff       	call   c002c3bd <msg>
c002dea7:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002deaa:	83 ec 0c             	sub    $0xc,%esp
c002dead:	68 e0 a0 03 c0       	push   $0xc003a0e0
c002deb2:	e8 29 54 ff ff       	call   c00232e0 <lock_release>
c002deb7:	83 c4 10             	add    $0x10,%esp
}
c002deba:	90                   	nop
c002debb:	c9                   	leave  
c002debc:	c3                   	ret    

c002debd <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002debd:	55                   	push   %ebp
c002debe:	89 e5                	mov    %esp,%ebp
c002dec0:	53                   	push   %ebx
c002dec1:	81 ec 64 01 00 00    	sub    $0x164,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002dec7:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002decc:	83 f0 01             	xor    $0x1,%eax
c002decf:	84 c0                	test   %al,%al
c002ded1:	75 1e                	jne    c002def1 <test_priority_donate_chain+0x34>
c002ded3:	83 ec 0c             	sub    $0xc,%esp
c002ded6:	68 a4 31 03 c0       	push   $0xc00331a4
c002dedb:	68 b2 31 03 c0       	push   $0xc00331b2
c002dee0:	68 bc 32 03 c0       	push   $0xc00332bc
c002dee5:	6a 34                	push   $0x34
c002dee7:	68 cc 31 03 c0       	push   $0xc00331cc
c002deec:	e8 31 c1 ff ff       	call   c002a022 <debug_panic>

  thread_set_priority (PRI_MIN);
c002def1:	83 ec 0c             	sub    $0xc,%esp
c002def4:	6a 00                	push   $0x0
c002def6:	e8 99 2f ff ff       	call   c0020e94 <thread_set_priority>
c002defb:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002defe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002df05:	eb 24                	jmp    c002df2b <test_priority_donate_chain+0x6e>
    lock_init (&locks[i]);
c002df07:	8d 8d f4 fe ff ff    	lea    -0x10c(%ebp),%ecx
c002df0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002df10:	89 d0                	mov    %edx,%eax
c002df12:	c1 e0 03             	shl    $0x3,%eax
c002df15:	01 d0                	add    %edx,%eax
c002df17:	c1 e0 02             	shl    $0x2,%eax
c002df1a:	01 c8                	add    %ecx,%eax
c002df1c:	83 ec 0c             	sub    $0xc,%esp
c002df1f:	50                   	push   %eax
c002df20:	e8 3d 51 ff ff       	call   c0023062 <lock_init>
c002df25:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002df28:	ff 45 f4             	incl   -0xc(%ebp)
c002df2b:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002df2f:	7e d6                	jle    c002df07 <test_priority_donate_chain+0x4a>

  lock_acquire (&locks[0]);
c002df31:	83 ec 0c             	sub    $0xc,%esp
c002df34:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c002df3a:	50                   	push   %eax
c002df3b:	e8 6f 51 ff ff       	call   c00230af <lock_acquire>
c002df40:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c002df43:	e8 33 2d ff ff       	call   c0020c7b <thread_name>
c002df48:	83 ec 08             	sub    $0x8,%esp
c002df4b:	50                   	push   %eax
c002df4c:	68 f8 31 03 c0       	push   $0xc00331f8
c002df51:	e8 67 e4 ff ff       	call   c002c3bd <msg>
c002df56:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c002df59:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002df60:	e9 f4 00 00 00       	jmp    c002e059 <test_priority_donate_chain+0x19c>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002df65:	ff 75 f4             	pushl  -0xc(%ebp)
c002df68:	68 05 32 03 c0       	push   $0xc0033205
c002df6d:	6a 10                	push   $0x10
c002df6f:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002df75:	50                   	push   %eax
c002df76:	e8 ad 9b ff ff       	call   c0027b28 <snprintf>
c002df7b:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c002df7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df81:	89 c2                	mov    %eax,%edx
c002df83:	01 d2                	add    %edx,%edx
c002df85:	01 d0                	add    %edx,%eax
c002df87:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002df8a:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002df8e:	7f 19                	jg     c002dfa9 <test_priority_donate_chain+0xec>
c002df90:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002df93:	89 d0                	mov    %edx,%eax
c002df95:	c1 e0 03             	shl    $0x3,%eax
c002df98:	01 d0                	add    %edx,%eax
c002df9a:	c1 e0 02             	shl    $0x2,%eax
c002df9d:	89 c2                	mov    %eax,%edx
c002df9f:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c002dfa5:	01 c2                	add    %eax,%edx
c002dfa7:	eb 05                	jmp    c002dfae <test_priority_donate_chain+0xf1>
c002dfa9:	ba 00 00 00 00       	mov    $0x0,%edx
c002dfae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dfb1:	89 94 c5 b8 fe ff ff 	mov    %edx,-0x148(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c002dfb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002dfbb:	89 d0                	mov    %edx,%eax
c002dfbd:	c1 e0 03             	shl    $0x3,%eax
c002dfc0:	01 d0                	add    %edx,%eax
c002dfc2:	c1 e0 02             	shl    $0x2,%eax
c002dfc5:	8d 50 dc             	lea    -0x24(%eax),%edx
c002dfc8:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c002dfce:	01 c2                	add    %eax,%edx
c002dfd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dfd3:	89 94 c5 b4 fe ff ff 	mov    %edx,-0x14c(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002dfda:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dfdd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002dfe4:	8d 85 b4 fe ff ff    	lea    -0x14c(%ebp),%eax
c002dfea:	01 d0                	add    %edx,%eax
c002dfec:	50                   	push   %eax
c002dfed:	68 99 e0 02 c0       	push   $0xc002e099
c002dff2:	ff 75 f0             	pushl  -0x10(%ebp)
c002dff5:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002dffb:	50                   	push   %eax
c002dffc:	e8 5b 2a ff ff       	call   c0020a5c <thread_create>
c002e001:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c002e004:	e8 04 2f ff ff       	call   c0020f0d <thread_get_priority>
c002e009:	89 c3                	mov    %eax,%ebx
c002e00b:	e8 6b 2c ff ff       	call   c0020c7b <thread_name>
c002e010:	53                   	push   %ebx
c002e011:	ff 75 f0             	pushl  -0x10(%ebp)
c002e014:	50                   	push   %eax
c002e015:	68 10 32 03 c0       	push   $0xc0033210
c002e01a:	e8 9e e3 ff ff       	call   c002c3bd <msg>
c002e01f:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002e022:	ff 75 f4             	pushl  -0xc(%ebp)
c002e025:	68 42 32 03 c0       	push   $0xc0033242
c002e02a:	6a 10                	push   $0x10
c002e02c:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e032:	50                   	push   %eax
c002e033:	e8 f0 9a ff ff       	call   c0027b28 <snprintf>
c002e038:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002e03b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e03e:	48                   	dec    %eax
c002e03f:	6a 00                	push   $0x0
c002e041:	68 57 e1 02 c0       	push   $0xc002e157
c002e046:	50                   	push   %eax
c002e047:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e04d:	50                   	push   %eax
c002e04e:	e8 09 2a ff ff       	call   c0020a5c <thread_create>
c002e053:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < NESTING_DEPTH; i++)
c002e056:	ff 45 f4             	incl   -0xc(%ebp)
c002e059:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c002e05d:	0f 8e 02 ff ff ff    	jle    c002df65 <test_priority_donate_chain+0xa8>
    }

  lock_release (&locks[0]);
c002e063:	83 ec 0c             	sub    $0xc,%esp
c002e066:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c002e06c:	50                   	push   %eax
c002e06d:	e8 6e 52 ff ff       	call   c00232e0 <lock_release>
c002e072:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002e075:	e8 93 2e ff ff       	call   c0020f0d <thread_get_priority>
c002e07a:	89 c3                	mov    %eax,%ebx
c002e07c:	e8 fa 2b ff ff       	call   c0020c7b <thread_name>
c002e081:	83 ec 04             	sub    $0x4,%esp
c002e084:	53                   	push   %ebx
c002e085:	50                   	push   %eax
c002e086:	68 50 32 03 c0       	push   $0xc0033250
c002e08b:	e8 2d e3 ff ff       	call   c002c3bd <msg>
c002e090:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002e093:	90                   	nop
c002e094:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e097:	c9                   	leave  
c002e098:	c3                   	ret    

c002e099 <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c002e099:	55                   	push   %ebp
c002e09a:	89 e5                	mov    %esp,%ebp
c002e09c:	53                   	push   %ebx
c002e09d:	83 ec 14             	sub    $0x14,%esp
  struct lock_pair *locks = locks_;
c002e0a0:	8b 45 08             	mov    0x8(%ebp),%eax
c002e0a3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c002e0a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0a9:	8b 40 04             	mov    0x4(%eax),%eax
c002e0ac:	85 c0                	test   %eax,%eax
c002e0ae:	74 12                	je     c002e0c2 <donor_thread_func+0x29>
    lock_acquire (locks->first);
c002e0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0b3:	8b 40 04             	mov    0x4(%eax),%eax
c002e0b6:	83 ec 0c             	sub    $0xc,%esp
c002e0b9:	50                   	push   %eax
c002e0ba:	e8 f0 4f ff ff       	call   c00230af <lock_acquire>
c002e0bf:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002e0c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0c5:	8b 00                	mov    (%eax),%eax
c002e0c7:	83 ec 0c             	sub    $0xc,%esp
c002e0ca:	50                   	push   %eax
c002e0cb:	e8 df 4f ff ff       	call   c00230af <lock_acquire>
c002e0d0:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c002e0d3:	e8 a3 2b ff ff       	call   c0020c7b <thread_name>
c002e0d8:	83 ec 08             	sub    $0x8,%esp
c002e0db:	50                   	push   %eax
c002e0dc:	68 6f 32 03 c0       	push   $0xc003326f
c002e0e1:	e8 d7 e2 ff ff       	call   c002c3bd <msg>
c002e0e6:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c002e0e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0ec:	8b 00                	mov    (%eax),%eax
c002e0ee:	83 ec 0c             	sub    $0xc,%esp
c002e0f1:	50                   	push   %eax
c002e0f2:	e8 e9 51 ff ff       	call   c00232e0 <lock_release>
c002e0f7:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c002e0fa:	e8 0e 2e ff ff       	call   c0020f0d <thread_get_priority>
c002e0ff:	89 c3                	mov    %eax,%ebx
c002e101:	e8 75 2b ff ff       	call   c0020c7b <thread_name>
c002e106:	53                   	push   %ebx
c002e107:	6a 15                	push   $0x15
c002e109:	50                   	push   %eax
c002e10a:	68 7c 32 03 c0       	push   $0xc003327c
c002e10f:	e8 a9 e2 ff ff       	call   c002c3bd <msg>
c002e114:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002e117:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e11a:	8b 40 04             	mov    0x4(%eax),%eax
c002e11d:	85 c0                	test   %eax,%eax
c002e11f:	74 12                	je     c002e133 <donor_thread_func+0x9a>
    lock_release (locks->first);
c002e121:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e124:	8b 40 04             	mov    0x4(%eax),%eax
c002e127:	83 ec 0c             	sub    $0xc,%esp
c002e12a:	50                   	push   %eax
c002e12b:	e8 b0 51 ff ff       	call   c00232e0 <lock_release>
c002e130:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002e133:	e8 d5 2d ff ff       	call   c0020f0d <thread_get_priority>
c002e138:	89 c3                	mov    %eax,%ebx
c002e13a:	e8 3c 2b ff ff       	call   c0020c7b <thread_name>
c002e13f:	83 ec 04             	sub    $0x4,%esp
c002e142:	53                   	push   %ebx
c002e143:	50                   	push   %eax
c002e144:	68 50 32 03 c0       	push   $0xc0033250
c002e149:	e8 6f e2 ff ff       	call   c002c3bd <msg>
c002e14e:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002e151:	90                   	nop
c002e152:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e155:	c9                   	leave  
c002e156:	c3                   	ret    

c002e157 <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002e157:	55                   	push   %ebp
c002e158:	89 e5                	mov    %esp,%ebp
c002e15a:	83 ec 08             	sub    $0x8,%esp
  msg ("%s finished.", thread_name ());
c002e15d:	e8 19 2b ff ff       	call   c0020c7b <thread_name>
c002e162:	83 ec 08             	sub    $0x8,%esp
c002e165:	50                   	push   %eax
c002e166:	68 ac 32 03 c0       	push   $0xc00332ac
c002e16b:	e8 4d e2 ff ff       	call   c002c3bd <msg>
c002e170:	83 c4 10             	add    $0x10,%esp
}
c002e173:	90                   	nop
c002e174:	c9                   	leave  
c002e175:	c3                   	ret    

c002e176 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002e176:	55                   	push   %ebp
c002e177:	89 e5                	mov    %esp,%ebp
c002e179:	53                   	push   %ebx
c002e17a:	83 ec 14             	sub    $0x14,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002e17d:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002e182:	84 c0                	test   %al,%al
c002e184:	75 1e                	jne    c002e1a4 <test_mlfqs_load_1+0x2e>
c002e186:	83 ec 0c             	sub    $0xc,%esp
c002e189:	68 d8 32 03 c0       	push   $0xc00332d8
c002e18e:	68 e5 32 03 c0       	push   $0xc00332e5
c002e193:	68 f4 34 03 c0       	push   $0xc00334f4
c002e198:	6a 18                	push   $0x18
c002e19a:	68 fc 32 03 c0       	push   $0xc00332fc
c002e19f:	e8 7e be ff ff       	call   c002a022 <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002e1a4:	83 ec 0c             	sub    $0xc,%esp
c002e1a7:	68 20 33 03 c0       	push   $0xc0033320
c002e1ac:	e8 0c e2 ff ff       	call   c002c3bd <msg>
c002e1b1:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002e1b4:	e8 71 63 ff ff       	call   c002452a <timer_ticks>
c002e1b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e1bc:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002e1bf:	e8 a7 2d ff ff       	call   c0020f6b <thread_get_load_avg>
c002e1c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c002e1c7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002e1cb:	79 1e                	jns    c002e1eb <test_mlfqs_load_1+0x75>
c002e1cd:	83 ec 0c             	sub    $0xc,%esp
c002e1d0:	68 4e 33 03 c0       	push   $0xc003334e
c002e1d5:	68 e5 32 03 c0       	push   $0xc00332e5
c002e1da:	68 f4 34 03 c0       	push   $0xc00334f4
c002e1df:	6a 20                	push   $0x20
c002e1e1:	68 fc 32 03 c0       	push   $0xc00332fc
c002e1e6:	e8 37 be ff ff       	call   c002a022 <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002e1eb:	83 ec 08             	sub    $0x8,%esp
c002e1ee:	ff 75 f4             	pushl  -0xc(%ebp)
c002e1f1:	ff 75 f0             	pushl  -0x10(%ebp)
c002e1f4:	e8 66 63 ff ff       	call   c002455f <timer_elapsed>
c002e1f9:	83 c4 10             	add    $0x10,%esp
c002e1fc:	6a 00                	push   $0x0
c002e1fe:	6a 64                	push   $0x64
c002e200:	52                   	push   %edx
c002e201:	50                   	push   %eax
c002e202:	e8 0f b7 ff ff       	call   c0029916 <__divdi3>
c002e207:	83 c4 10             	add    $0x10,%esp
c002e20a:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c002e20d:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c002e211:	7e 5a                	jle    c002e26d <test_mlfqs_load_1+0xf7>
        fail ("load average is %d.%02d "
c002e213:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e216:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e21b:	f7 eb                	imul   %ebx
c002e21d:	c1 fa 05             	sar    $0x5,%edx
c002e220:	89 d8                	mov    %ebx,%eax
c002e222:	c1 f8 1f             	sar    $0x1f,%eax
c002e225:	89 d1                	mov    %edx,%ecx
c002e227:	29 c1                	sub    %eax,%ecx
c002e229:	89 c8                	mov    %ecx,%eax
c002e22b:	c1 e0 02             	shl    $0x2,%eax
c002e22e:	01 c8                	add    %ecx,%eax
c002e230:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e237:	01 d0                	add    %edx,%eax
c002e239:	c1 e0 02             	shl    $0x2,%eax
c002e23c:	89 d9                	mov    %ebx,%ecx
c002e23e:	29 c1                	sub    %eax,%ecx
c002e240:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e243:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e248:	f7 eb                	imul   %ebx
c002e24a:	c1 fa 05             	sar    $0x5,%edx
c002e24d:	89 d8                	mov    %ebx,%eax
c002e24f:	c1 f8 1f             	sar    $0x1f,%eax
c002e252:	29 c2                	sub    %eax,%edx
c002e254:	89 d0                	mov    %edx,%eax
c002e256:	ff 75 e8             	pushl  -0x18(%ebp)
c002e259:	51                   	push   %ecx
c002e25a:	50                   	push   %eax
c002e25b:	68 5c 33 03 c0       	push   $0xc003335c
c002e260:	e8 9c e1 ff ff       	call   c002c401 <fail>
c002e265:	83 c4 10             	add    $0x10,%esp
c002e268:	e9 52 ff ff ff       	jmp    c002e1bf <test_mlfqs_load_1+0x49>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002e26d:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002e271:	7f 1f                	jg     c002e292 <test_mlfqs_load_1+0x11c>
        break;
      else if (elapsed > 45)
c002e273:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c002e277:	0f 8e 42 ff ff ff    	jle    c002e1bf <test_mlfqs_load_1+0x49>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002e27d:	83 ec 0c             	sub    $0xc,%esp
c002e280:	68 a8 33 03 c0       	push   $0xc00333a8
c002e285:	e8 77 e1 ff ff       	call   c002c401 <fail>
c002e28a:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002e28d:	e9 2d ff ff ff       	jmp    c002e1bf <test_mlfqs_load_1+0x49>
        break;
c002e292:	90                   	nop
    }

  if (elapsed < 38)
c002e293:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c002e297:	7f 13                	jg     c002e2ac <test_mlfqs_load_1+0x136>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002e299:	83 ec 08             	sub    $0x8,%esp
c002e29c:	ff 75 e8             	pushl  -0x18(%ebp)
c002e29f:	68 e0 33 03 c0       	push   $0xc00333e0
c002e2a4:	e8 58 e1 ff ff       	call   c002c401 <fail>
c002e2a9:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002e2ac:	83 ec 08             	sub    $0x8,%esp
c002e2af:	ff 75 e8             	pushl  -0x18(%ebp)
c002e2b2:	68 14 34 03 c0       	push   $0xc0033414
c002e2b7:	e8 01 e1 ff ff       	call   c002c3bd <msg>
c002e2bc:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c002e2bf:	83 ec 0c             	sub    $0xc,%esp
c002e2c2:	68 40 34 03 c0       	push   $0xc0033440
c002e2c7:	e8 f1 e0 ff ff       	call   c002c3bd <msg>
c002e2cc:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c002e2cf:	83 ec 08             	sub    $0x8,%esp
c002e2d2:	6a 00                	push   $0x0
c002e2d4:	68 e8 03 00 00       	push   $0x3e8
c002e2d9:	e8 a0 62 ff ff       	call   c002457e <timer_sleep>
c002e2de:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c002e2e1:	e8 85 2c ff ff       	call   c0020f6b <thread_get_load_avg>
c002e2e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c002e2e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002e2ed:	79 10                	jns    c002e2ff <test_mlfqs_load_1+0x189>
    fail ("load average fell below 0");
c002e2ef:	83 ec 0c             	sub    $0xc,%esp
c002e2f2:	68 70 34 03 c0       	push   $0xc0033470
c002e2f7:	e8 05 e1 ff ff       	call   c002c401 <fail>
c002e2fc:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002e2ff:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002e303:	7e 10                	jle    c002e315 <test_mlfqs_load_1+0x19f>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002e305:	83 ec 0c             	sub    $0xc,%esp
c002e308:	68 8c 34 03 c0       	push   $0xc003348c
c002e30d:	e8 ef e0 ff ff       	call   c002c401 <fail>
c002e312:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002e315:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e318:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e31d:	f7 eb                	imul   %ebx
c002e31f:	c1 fa 05             	sar    $0x5,%edx
c002e322:	89 d8                	mov    %ebx,%eax
c002e324:	c1 f8 1f             	sar    $0x1f,%eax
c002e327:	29 c2                	sub    %eax,%edx
c002e329:	89 d1                	mov    %edx,%ecx
c002e32b:	89 c8                	mov    %ecx,%eax
c002e32d:	c1 e0 02             	shl    $0x2,%eax
c002e330:	01 c8                	add    %ecx,%eax
c002e332:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e339:	01 d0                	add    %edx,%eax
c002e33b:	c1 e0 02             	shl    $0x2,%eax
c002e33e:	29 c3                	sub    %eax,%ebx
c002e340:	89 d9                	mov    %ebx,%ecx
c002e342:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e345:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e34a:	f7 eb                	imul   %ebx
c002e34c:	c1 fa 05             	sar    $0x5,%edx
c002e34f:	89 d8                	mov    %ebx,%eax
c002e351:	c1 f8 1f             	sar    $0x1f,%eax
c002e354:	29 c2                	sub    %eax,%edx
c002e356:	89 d0                	mov    %edx,%eax
c002e358:	83 ec 04             	sub    $0x4,%esp
c002e35b:	51                   	push   %ecx
c002e35c:	50                   	push   %eax
c002e35d:	68 c4 34 03 c0       	push   $0xc00334c4
c002e362:	e8 56 e0 ff ff       	call   c002c3bd <msg>
c002e367:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c002e36a:	e8 e9 e0 ff ff       	call   c002c458 <pass>
}
c002e36f:	90                   	nop
c002e370:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e373:	c9                   	leave  
c002e374:	c3                   	ret    

c002e375 <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002e375:	55                   	push   %ebp
c002e376:	89 e5                	mov    %esp,%ebp
c002e378:	53                   	push   %ebx
c002e379:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002e37c:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002e381:	84 c0                	test   %al,%al
c002e383:	75 1e                	jne    c002e3a3 <test_mlfqs_load_60+0x2e>
c002e385:	83 ec 0c             	sub    $0xc,%esp
c002e388:	68 08 35 03 c0       	push   $0xc0033508
c002e38d:	68 15 35 03 c0       	push   $0xc0033515
c002e392:	68 c8 35 03 c0       	push   $0xc00335c8
c002e397:	6a 77                	push   $0x77
c002e399:	68 2c 35 03 c0       	push   $0xc003352c
c002e39e:	e8 7f bc ff ff       	call   c002a022 <debug_panic>

  start_time = timer_ticks ();
c002e3a3:	e8 82 61 ff ff       	call   c002452a <timer_ticks>
c002e3a8:	a3 18 a1 03 c0       	mov    %eax,0xc003a118
c002e3ad:	89 15 1c a1 03 c0    	mov    %edx,0xc003a11c
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002e3b3:	83 ec 08             	sub    $0x8,%esp
c002e3b6:	6a 3c                	push   $0x3c
c002e3b8:	68 50 35 03 c0       	push   $0xc0033550
c002e3bd:	e8 fb df ff ff       	call   c002c3bd <msg>
c002e3c2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002e3c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e3cc:	eb 2e                	jmp    c002e3fc <test_mlfqs_load_60+0x87>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002e3ce:	ff 75 f4             	pushl  -0xc(%ebp)
c002e3d1:	68 72 35 03 c0       	push   $0xc0033572
c002e3d6:	6a 10                	push   $0x10
c002e3d8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e3db:	50                   	push   %eax
c002e3dc:	e8 47 97 ff ff       	call   c0027b28 <snprintf>
c002e3e1:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002e3e4:	6a 00                	push   $0x0
c002e3e6:	68 0c e5 02 c0       	push   $0xc002e50c
c002e3eb:	6a 1f                	push   $0x1f
c002e3ed:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e3f0:	50                   	push   %eax
c002e3f1:	e8 66 26 ff ff       	call   c0020a5c <thread_create>
c002e3f6:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002e3f9:	ff 45 f4             	incl   -0xc(%ebp)
c002e3fc:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002e400:	7e cc                	jle    c002e3ce <test_mlfqs_load_60+0x59>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002e402:	a1 18 a1 03 c0       	mov    0xc003a118,%eax
c002e407:	8b 15 1c a1 03 c0    	mov    0xc003a11c,%edx
c002e40d:	83 ec 08             	sub    $0x8,%esp
c002e410:	52                   	push   %edx
c002e411:	50                   	push   %eax
c002e412:	e8 48 61 ff ff       	call   c002455f <timer_elapsed>
c002e417:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c002e41a:	6a 00                	push   $0x0
c002e41c:	6a 64                	push   $0x64
c002e41e:	52                   	push   %edx
c002e41f:	50                   	push   %eax
c002e420:	e8 f1 b4 ff ff       	call   c0029916 <__divdi3>
c002e425:	83 c4 10             	add    $0x10,%esp
c002e428:	83 ec 04             	sub    $0x4,%esp
c002e42b:	52                   	push   %edx
c002e42c:	50                   	push   %eax
c002e42d:	68 7c 35 03 c0       	push   $0xc003357c
c002e432:	e8 86 df ff ff       	call   c002c3bd <msg>
c002e437:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 90; i++) 
c002e43a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e441:	e9 b6 00 00 00       	jmp    c002e4fc <test_mlfqs_load_60+0x187>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002e446:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e449:	8d 50 05             	lea    0x5(%eax),%edx
c002e44c:	89 d0                	mov    %edx,%eax
c002e44e:	c1 e0 02             	shl    $0x2,%eax
c002e451:	01 d0                	add    %edx,%eax
c002e453:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e45a:	01 d0                	add    %edx,%eax
c002e45c:	c1 e0 03             	shl    $0x3,%eax
c002e45f:	89 c1                	mov    %eax,%ecx
c002e461:	89 c3                	mov    %eax,%ebx
c002e463:	c1 fb 1f             	sar    $0x1f,%ebx
c002e466:	a1 18 a1 03 c0       	mov    0xc003a118,%eax
c002e46b:	8b 15 1c a1 03 c0    	mov    0xc003a11c,%edx
c002e471:	01 c8                	add    %ecx,%eax
c002e473:	11 da                	adc    %ebx,%edx
c002e475:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e478:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002e47b:	e8 aa 60 ff ff       	call   c002452a <timer_ticks>
c002e480:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002e483:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e486:	29 c1                	sub    %eax,%ecx
c002e488:	19 d3                	sbb    %edx,%ebx
c002e48a:	89 c8                	mov    %ecx,%eax
c002e48c:	89 da                	mov    %ebx,%edx
c002e48e:	83 ec 08             	sub    $0x8,%esp
c002e491:	52                   	push   %edx
c002e492:	50                   	push   %eax
c002e493:	e8 e6 60 ff ff       	call   c002457e <timer_sleep>
c002e498:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002e49b:	e8 cb 2a ff ff       	call   c0020f6b <thread_get_load_avg>
c002e4a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002e4a3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e4a6:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e4ab:	f7 eb                	imul   %ebx
c002e4ad:	c1 fa 05             	sar    $0x5,%edx
c002e4b0:	89 d8                	mov    %ebx,%eax
c002e4b2:	c1 f8 1f             	sar    $0x1f,%eax
c002e4b5:	89 d1                	mov    %edx,%ecx
c002e4b7:	29 c1                	sub    %eax,%ecx
c002e4b9:	89 c8                	mov    %ecx,%eax
c002e4bb:	c1 e0 02             	shl    $0x2,%eax
c002e4be:	01 c8                	add    %ecx,%eax
c002e4c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e4c7:	01 d0                	add    %edx,%eax
c002e4c9:	c1 e0 02             	shl    $0x2,%eax
c002e4cc:	29 c3                	sub    %eax,%ebx
c002e4ce:	89 d9                	mov    %ebx,%ecx
c002e4d0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e4d3:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e4d8:	f7 eb                	imul   %ebx
c002e4da:	c1 fa 05             	sar    $0x5,%edx
c002e4dd:	89 d8                	mov    %ebx,%eax
c002e4df:	c1 f8 1f             	sar    $0x1f,%eax
c002e4e2:	29 c2                	sub    %eax,%edx
c002e4e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e4e7:	01 c0                	add    %eax,%eax
c002e4e9:	51                   	push   %ecx
c002e4ea:	52                   	push   %edx
c002e4eb:	50                   	push   %eax
c002e4ec:	68 a0 35 03 c0       	push   $0xc00335a0
c002e4f1:	e8 c7 de ff ff       	call   c002c3bd <msg>
c002e4f6:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c002e4f9:	ff 45 f4             	incl   -0xc(%ebp)
c002e4fc:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002e500:	0f 8e 40 ff ff ff    	jle    c002e446 <test_mlfqs_load_60+0xd1>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002e506:	90                   	nop
c002e507:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e50a:	c9                   	leave  
c002e50b:	c3                   	ret    

c002e50c <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c002e50c:	55                   	push   %ebp
c002e50d:	89 e5                	mov    %esp,%ebp
c002e50f:	53                   	push   %ebx
c002e510:	83 ec 24             	sub    $0x24,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
c002e513:	c7 45 f0 e8 03 00 00 	movl   $0x3e8,-0x10(%ebp)
c002e51a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c002e521:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e524:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e527:	05 70 17 00 00       	add    $0x1770,%eax
c002e52c:	83 d2 00             	adc    $0x0,%edx
c002e52f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e532:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c002e535:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e538:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e53b:	05 70 17 00 00       	add    $0x1770,%eax
c002e540:	83 d2 00             	adc    $0x0,%edx
c002e543:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002e546:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  thread_set_nice (20);
c002e549:	83 ec 0c             	sub    $0xc,%esp
c002e54c:	6a 14                	push   $0x14
c002e54e:	e8 ca 29 ff ff       	call   c0020f1d <thread_set_nice>
c002e553:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002e556:	a1 18 a1 03 c0       	mov    0xc003a118,%eax
c002e55b:	8b 15 1c a1 03 c0    	mov    0xc003a11c,%edx
c002e561:	83 ec 08             	sub    $0x8,%esp
c002e564:	52                   	push   %edx
c002e565:	50                   	push   %eax
c002e566:	e8 f4 5f ff ff       	call   c002455f <timer_elapsed>
c002e56b:	83 c4 10             	add    $0x10,%esp
c002e56e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c002e571:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002e574:	29 c1                	sub    %eax,%ecx
c002e576:	19 d3                	sbb    %edx,%ebx
c002e578:	89 c8                	mov    %ecx,%eax
c002e57a:	89 da                	mov    %ebx,%edx
c002e57c:	83 ec 08             	sub    $0x8,%esp
c002e57f:	52                   	push   %edx
c002e580:	50                   	push   %eax
c002e581:	e8 f8 5f ff ff       	call   c002457e <timer_sleep>
c002e586:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002e589:	eb 01                	jmp    c002e58c <load_thread+0x80>
    continue;
c002e58b:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c002e58c:	a1 18 a1 03 c0       	mov    0xc003a118,%eax
c002e591:	8b 15 1c a1 03 c0    	mov    0xc003a11c,%edx
c002e597:	83 ec 08             	sub    $0x8,%esp
c002e59a:	52                   	push   %edx
c002e59b:	50                   	push   %eax
c002e59c:	e8 be 5f ff ff       	call   c002455f <timer_elapsed>
c002e5a1:	83 c4 10             	add    $0x10,%esp
c002e5a4:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002e5a7:	7c e2                	jl     c002e58b <load_thread+0x7f>
c002e5a9:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002e5ac:	7f 05                	jg     c002e5b3 <load_thread+0xa7>
c002e5ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002e5b1:	72 d8                	jb     c002e58b <load_thread+0x7f>
  timer_sleep (exit_time - timer_elapsed (start_time));
c002e5b3:	a1 18 a1 03 c0       	mov    0xc003a118,%eax
c002e5b8:	8b 15 1c a1 03 c0    	mov    0xc003a11c,%edx
c002e5be:	83 ec 08             	sub    $0x8,%esp
c002e5c1:	52                   	push   %edx
c002e5c2:	50                   	push   %eax
c002e5c3:	e8 97 5f ff ff       	call   c002455f <timer_elapsed>
c002e5c8:	83 c4 10             	add    $0x10,%esp
c002e5cb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002e5ce:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e5d1:	29 c1                	sub    %eax,%ecx
c002e5d3:	19 d3                	sbb    %edx,%ebx
c002e5d5:	89 c8                	mov    %ecx,%eax
c002e5d7:	89 da                	mov    %ebx,%edx
c002e5d9:	83 ec 08             	sub    $0x8,%esp
c002e5dc:	52                   	push   %edx
c002e5dd:	50                   	push   %eax
c002e5de:	e8 9b 5f ff ff       	call   c002457e <timer_sleep>
c002e5e3:	83 c4 10             	add    $0x10,%esp
}
c002e5e6:	90                   	nop
c002e5e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e5ea:	c9                   	leave  
c002e5eb:	c3                   	ret    

c002e5ec <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002e5ec:	55                   	push   %ebp
c002e5ed:	89 e5                	mov    %esp,%ebp
c002e5ef:	53                   	push   %ebx
c002e5f0:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002e5f3:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002e5f8:	84 c0                	test   %al,%al
c002e5fa:	75 21                	jne    c002e61d <test_mlfqs_load_avg+0x31>
c002e5fc:	83 ec 0c             	sub    $0xc,%esp
c002e5ff:	68 dc 35 03 c0       	push   $0xc00335dc
c002e604:	68 e9 35 03 c0       	push   $0xc00335e9
c002e609:	68 98 36 03 c0       	push   $0xc0033698
c002e60e:	68 82 00 00 00       	push   $0x82
c002e613:	68 00 36 03 c0       	push   $0xc0033600
c002e618:	e8 05 ba ff ff       	call   c002a022 <debug_panic>

  start_time = timer_ticks ();
c002e61d:	e8 08 5f ff ff       	call   c002452a <timer_ticks>
c002e622:	a3 20 a1 03 c0       	mov    %eax,0xc003a120
c002e627:	89 15 24 a1 03 c0    	mov    %edx,0xc003a124
  msg ("Starting %d load threads...", THREAD_CNT);
c002e62d:	83 ec 08             	sub    $0x8,%esp
c002e630:	6a 3c                	push   $0x3c
c002e632:	68 25 36 03 c0       	push   $0xc0033625
c002e637:	e8 81 dd ff ff       	call   c002c3bd <msg>
c002e63c:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002e63f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e646:	eb 30                	jmp    c002e678 <test_mlfqs_load_avg+0x8c>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002e648:	ff 75 f4             	pushl  -0xc(%ebp)
c002e64b:	68 41 36 03 c0       	push   $0xc0033641
c002e650:	6a 10                	push   $0x10
c002e652:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e655:	50                   	push   %eax
c002e656:	e8 cd 94 ff ff       	call   c0027b28 <snprintf>
c002e65b:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002e65e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e661:	50                   	push   %eax
c002e662:	68 95 e7 02 c0       	push   $0xc002e795
c002e667:	6a 1f                	push   $0x1f
c002e669:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e66c:	50                   	push   %eax
c002e66d:	e8 ea 23 ff ff       	call   c0020a5c <thread_create>
c002e672:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002e675:	ff 45 f4             	incl   -0xc(%ebp)
c002e678:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002e67c:	7e ca                	jle    c002e648 <test_mlfqs_load_avg+0x5c>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002e67e:	a1 20 a1 03 c0       	mov    0xc003a120,%eax
c002e683:	8b 15 24 a1 03 c0    	mov    0xc003a124,%edx
c002e689:	83 ec 08             	sub    $0x8,%esp
c002e68c:	52                   	push   %edx
c002e68d:	50                   	push   %eax
c002e68e:	e8 cc 5e ff ff       	call   c002455f <timer_elapsed>
c002e693:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c002e696:	6a 00                	push   $0x0
c002e698:	6a 64                	push   $0x64
c002e69a:	52                   	push   %edx
c002e69b:	50                   	push   %eax
c002e69c:	e8 75 b2 ff ff       	call   c0029916 <__divdi3>
c002e6a1:	83 c4 10             	add    $0x10,%esp
c002e6a4:	83 ec 04             	sub    $0x4,%esp
c002e6a7:	52                   	push   %edx
c002e6a8:	50                   	push   %eax
c002e6a9:	68 4c 36 03 c0       	push   $0xc003364c
c002e6ae:	e8 0a dd ff ff       	call   c002c3bd <msg>
c002e6b3:	83 c4 10             	add    $0x10,%esp
  thread_set_nice (-20);
c002e6b6:	83 ec 0c             	sub    $0xc,%esp
c002e6b9:	6a ec                	push   $0xffffffec
c002e6bb:	e8 5d 28 ff ff       	call   c0020f1d <thread_set_nice>
c002e6c0:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c002e6c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e6ca:	e9 b6 00 00 00       	jmp    c002e785 <test_mlfqs_load_avg+0x199>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002e6cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e6d2:	8d 50 05             	lea    0x5(%eax),%edx
c002e6d5:	89 d0                	mov    %edx,%eax
c002e6d7:	c1 e0 02             	shl    $0x2,%eax
c002e6da:	01 d0                	add    %edx,%eax
c002e6dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e6e3:	01 d0                	add    %edx,%eax
c002e6e5:	c1 e0 03             	shl    $0x3,%eax
c002e6e8:	89 c1                	mov    %eax,%ecx
c002e6ea:	89 c3                	mov    %eax,%ebx
c002e6ec:	c1 fb 1f             	sar    $0x1f,%ebx
c002e6ef:	a1 20 a1 03 c0       	mov    0xc003a120,%eax
c002e6f4:	8b 15 24 a1 03 c0    	mov    0xc003a124,%edx
c002e6fa:	01 c8                	add    %ecx,%eax
c002e6fc:	11 da                	adc    %ebx,%edx
c002e6fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e701:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002e704:	e8 21 5e ff ff       	call   c002452a <timer_ticks>
c002e709:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002e70c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e70f:	29 c1                	sub    %eax,%ecx
c002e711:	19 d3                	sbb    %edx,%ebx
c002e713:	89 c8                	mov    %ecx,%eax
c002e715:	89 da                	mov    %ebx,%edx
c002e717:	83 ec 08             	sub    $0x8,%esp
c002e71a:	52                   	push   %edx
c002e71b:	50                   	push   %eax
c002e71c:	e8 5d 5e ff ff       	call   c002457e <timer_sleep>
c002e721:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002e724:	e8 42 28 ff ff       	call   c0020f6b <thread_get_load_avg>
c002e729:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002e72c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e72f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e734:	f7 eb                	imul   %ebx
c002e736:	c1 fa 05             	sar    $0x5,%edx
c002e739:	89 d8                	mov    %ebx,%eax
c002e73b:	c1 f8 1f             	sar    $0x1f,%eax
c002e73e:	89 d1                	mov    %edx,%ecx
c002e740:	29 c1                	sub    %eax,%ecx
c002e742:	89 c8                	mov    %ecx,%eax
c002e744:	c1 e0 02             	shl    $0x2,%eax
c002e747:	01 c8                	add    %ecx,%eax
c002e749:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e750:	01 d0                	add    %edx,%eax
c002e752:	c1 e0 02             	shl    $0x2,%eax
c002e755:	29 c3                	sub    %eax,%ebx
c002e757:	89 d9                	mov    %ebx,%ecx
c002e759:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e75c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e761:	f7 eb                	imul   %ebx
c002e763:	c1 fa 05             	sar    $0x5,%edx
c002e766:	89 d8                	mov    %ebx,%eax
c002e768:	c1 f8 1f             	sar    $0x1f,%eax
c002e76b:	29 c2                	sub    %eax,%edx
c002e76d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e770:	01 c0                	add    %eax,%eax
c002e772:	51                   	push   %ecx
c002e773:	52                   	push   %edx
c002e774:	50                   	push   %eax
c002e775:	68 70 36 03 c0       	push   $0xc0033670
c002e77a:	e8 3e dc ff ff       	call   c002c3bd <msg>
c002e77f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c002e782:	ff 45 f4             	incl   -0xc(%ebp)
c002e785:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002e789:	0f 8e 40 ff ff ff    	jle    c002e6cf <test_mlfqs_load_avg+0xe3>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002e78f:	90                   	nop
c002e790:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e793:	c9                   	leave  
c002e794:	c3                   	ret    

c002e795 <load_thread>:

static void
load_thread (void *seq_no_) 
{
c002e795:	55                   	push   %ebp
c002e796:	89 e5                	mov    %esp,%ebp
c002e798:	56                   	push   %esi
c002e799:	53                   	push   %ebx
c002e79a:	83 ec 10             	sub    $0x10,%esp
  int seq_no = (int) seq_no_;
c002e79d:	8b 45 08             	mov    0x8(%ebp),%eax
c002e7a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002e7a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e7a6:	8d 50 0a             	lea    0xa(%eax),%edx
c002e7a9:	89 d0                	mov    %edx,%eax
c002e7ab:	c1 e0 02             	shl    $0x2,%eax
c002e7ae:	01 d0                	add    %edx,%eax
c002e7b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e7b7:	01 d0                	add    %edx,%eax
c002e7b9:	c1 e0 02             	shl    $0x2,%eax
c002e7bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002e7bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e7c2:	05 70 17 00 00       	add    $0x1770,%eax
c002e7c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c002e7ca:	c7 45 e8 e0 2e 00 00 	movl   $0x2ee0,-0x18(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002e7d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e7d4:	89 c3                	mov    %eax,%ebx
c002e7d6:	89 c6                	mov    %eax,%esi
c002e7d8:	c1 fe 1f             	sar    $0x1f,%esi
c002e7db:	a1 20 a1 03 c0       	mov    0xc003a120,%eax
c002e7e0:	8b 15 24 a1 03 c0    	mov    0xc003a124,%edx
c002e7e6:	83 ec 08             	sub    $0x8,%esp
c002e7e9:	52                   	push   %edx
c002e7ea:	50                   	push   %eax
c002e7eb:	e8 6f 5d ff ff       	call   c002455f <timer_elapsed>
c002e7f0:	83 c4 10             	add    $0x10,%esp
c002e7f3:	29 c3                	sub    %eax,%ebx
c002e7f5:	19 d6                	sbb    %edx,%esi
c002e7f7:	89 d8                	mov    %ebx,%eax
c002e7f9:	89 f2                	mov    %esi,%edx
c002e7fb:	83 ec 08             	sub    $0x8,%esp
c002e7fe:	52                   	push   %edx
c002e7ff:	50                   	push   %eax
c002e800:	e8 79 5d ff ff       	call   c002457e <timer_sleep>
c002e805:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002e808:	eb 01                	jmp    c002e80b <load_thread+0x76>
    continue;
c002e80a:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c002e80b:	a1 20 a1 03 c0       	mov    0xc003a120,%eax
c002e810:	8b 15 24 a1 03 c0    	mov    0xc003a124,%edx
c002e816:	83 ec 08             	sub    $0x8,%esp
c002e819:	52                   	push   %edx
c002e81a:	50                   	push   %eax
c002e81b:	e8 3f 5d ff ff       	call   c002455f <timer_elapsed>
c002e820:	83 c4 10             	add    $0x10,%esp
c002e823:	89 c1                	mov    %eax,%ecx
c002e825:	89 d3                	mov    %edx,%ebx
c002e827:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e82a:	99                   	cltd   
c002e82b:	39 d3                	cmp    %edx,%ebx
c002e82d:	7c db                	jl     c002e80a <load_thread+0x75>
c002e82f:	39 d3                	cmp    %edx,%ebx
c002e831:	7f 04                	jg     c002e837 <load_thread+0xa2>
c002e833:	39 c1                	cmp    %eax,%ecx
c002e835:	72 d3                	jb     c002e80a <load_thread+0x75>
  timer_sleep (exit_time - timer_elapsed (start_time));
c002e837:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e83a:	89 c3                	mov    %eax,%ebx
c002e83c:	89 c6                	mov    %eax,%esi
c002e83e:	c1 fe 1f             	sar    $0x1f,%esi
c002e841:	a1 20 a1 03 c0       	mov    0xc003a120,%eax
c002e846:	8b 15 24 a1 03 c0    	mov    0xc003a124,%edx
c002e84c:	83 ec 08             	sub    $0x8,%esp
c002e84f:	52                   	push   %edx
c002e850:	50                   	push   %eax
c002e851:	e8 09 5d ff ff       	call   c002455f <timer_elapsed>
c002e856:	83 c4 10             	add    $0x10,%esp
c002e859:	29 c3                	sub    %eax,%ebx
c002e85b:	19 d6                	sbb    %edx,%esi
c002e85d:	89 d8                	mov    %ebx,%eax
c002e85f:	89 f2                	mov    %esi,%edx
c002e861:	83 ec 08             	sub    $0x8,%esp
c002e864:	52                   	push   %edx
c002e865:	50                   	push   %eax
c002e866:	e8 13 5d ff ff       	call   c002457e <timer_sleep>
c002e86b:	83 c4 10             	add    $0x10,%esp
}
c002e86e:	90                   	nop
c002e86f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002e872:	5b                   	pop    %ebx
c002e873:	5e                   	pop    %esi
c002e874:	5d                   	pop    %ebp
c002e875:	c3                   	ret    

c002e876 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002e876:	55                   	push   %ebp
c002e877:	89 e5                	mov    %esp,%ebp
c002e879:	57                   	push   %edi
c002e87a:	56                   	push   %esi
c002e87b:	53                   	push   %ebx
c002e87c:	83 ec 2c             	sub    $0x2c,%esp
  int64_t start_time;
  int last_elapsed = 0;
c002e87f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c002e886:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002e88b:	84 c0                	test   %al,%al
c002e88d:	75 1e                	jne    c002e8ad <test_mlfqs_recent_1+0x37>
c002e88f:	83 ec 0c             	sub    $0xc,%esp
c002e892:	68 ac 36 03 c0       	push   $0xc00336ac
c002e897:	68 b9 36 03 c0       	push   $0xc00336b9
c002e89c:	68 7c 37 03 c0       	push   $0xc003377c
c002e8a1:	6a 73                	push   $0x73
c002e8a3:	68 d0 36 03 c0       	push   $0xc00336d0
c002e8a8:	e8 75 b7 ff ff       	call   c002a022 <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002e8ad:	83 ec 0c             	sub    $0xc,%esp
c002e8b0:	68 f8 36 03 c0       	push   $0xc00336f8
c002e8b5:	e8 03 db ff ff       	call   c002c3bd <msg>
c002e8ba:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c002e8bd:	e8 68 5c ff ff       	call   c002452a <timer_ticks>
c002e8c2:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e8c5:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002e8c8:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e8cb:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002e8ce:	83 c0 63             	add    $0x63,%eax
c002e8d1:	83 d2 00             	adc    $0x0,%edx
c002e8d4:	6a 00                	push   $0x0
c002e8d6:	6a 64                	push   $0x64
c002e8d8:	52                   	push   %edx
c002e8d9:	50                   	push   %eax
c002e8da:	e8 37 b0 ff ff       	call   c0029916 <__divdi3>
c002e8df:	83 c4 10             	add    $0x10,%esp
c002e8e2:	2b 45 d8             	sub    -0x28(%ebp),%eax
c002e8e5:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c002e8e8:	05 e8 03 00 00       	add    $0x3e8,%eax
c002e8ed:	83 d2 00             	adc    $0x0,%edx
c002e8f0:	83 ec 08             	sub    $0x8,%esp
c002e8f3:	52                   	push   %edx
c002e8f4:	50                   	push   %eax
c002e8f5:	e8 84 5c ff ff       	call   c002457e <timer_sleep>
c002e8fa:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002e8fd:	e8 90 26 ff ff       	call   c0020f92 <thread_get_recent_cpu>
c002e902:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002e907:	7f a4                	jg     c002e8ad <test_mlfqs_recent_1+0x37>

  start_time = timer_ticks ();
c002e909:	e8 1c 5c ff ff       	call   c002452a <timer_ticks>
c002e90e:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e911:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002e914:	83 ec 08             	sub    $0x8,%esp
c002e917:	ff 75 dc             	pushl  -0x24(%ebp)
c002e91a:	ff 75 d8             	pushl  -0x28(%ebp)
c002e91d:	e8 3d 5c ff ff       	call   c002455f <timer_elapsed>
c002e922:	83 c4 10             	add    $0x10,%esp
c002e925:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002e928:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e92b:	b9 c8 00 00 00       	mov    $0xc8,%ecx
c002e930:	99                   	cltd   
c002e931:	f7 f9                	idiv   %ecx
c002e933:	89 d0                	mov    %edx,%eax
c002e935:	85 c0                	test   %eax,%eax
c002e937:	0f 85 db 00 00 00    	jne    c002ea18 <test_mlfqs_recent_1+0x1a2>
c002e93d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e940:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002e943:	0f 8e cf 00 00 00    	jle    c002ea18 <test_mlfqs_recent_1+0x1a2>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002e949:	e8 44 26 ff ff       	call   c0020f92 <thread_get_recent_cpu>
c002e94e:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c002e951:	e8 15 26 ff ff       	call   c0020f6b <thread_get_load_avg>
c002e956:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002e959:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002e95c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e961:	f7 e9                	imul   %ecx
c002e963:	c1 fa 05             	sar    $0x5,%edx
c002e966:	89 c8                	mov    %ecx,%eax
c002e968:	c1 f8 1f             	sar    $0x1f,%eax
c002e96b:	29 c2                	sub    %eax,%edx
c002e96d:	89 d0                	mov    %edx,%eax
c002e96f:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002e972:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002e975:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e97a:	f7 e9                	imul   %ecx
c002e97c:	c1 fa 05             	sar    $0x5,%edx
c002e97f:	89 c8                	mov    %ecx,%eax
c002e981:	c1 f8 1f             	sar    $0x1f,%eax
c002e984:	89 d3                	mov    %edx,%ebx
c002e986:	29 c3                	sub    %eax,%ebx
c002e988:	89 d8                	mov    %ebx,%eax
c002e98a:	c1 e0 02             	shl    $0x2,%eax
c002e98d:	01 d8                	add    %ebx,%eax
c002e98f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e996:	01 d0                	add    %edx,%eax
c002e998:	c1 e0 02             	shl    $0x2,%eax
c002e99b:	89 cb                	mov    %ecx,%ebx
c002e99d:	29 c3                	sub    %eax,%ebx
c002e99f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002e9a2:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e9a7:	f7 e9                	imul   %ecx
c002e9a9:	c1 fa 05             	sar    $0x5,%edx
c002e9ac:	89 c8                	mov    %ecx,%eax
c002e9ae:	c1 f8 1f             	sar    $0x1f,%eax
c002e9b1:	89 d7                	mov    %edx,%edi
c002e9b3:	29 c7                	sub    %eax,%edi
c002e9b5:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002e9b8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e9bd:	f7 ee                	imul   %esi
c002e9bf:	c1 fa 05             	sar    $0x5,%edx
c002e9c2:	89 f0                	mov    %esi,%eax
c002e9c4:	c1 f8 1f             	sar    $0x1f,%eax
c002e9c7:	89 d1                	mov    %edx,%ecx
c002e9c9:	29 c1                	sub    %eax,%ecx
c002e9cb:	89 c8                	mov    %ecx,%eax
c002e9cd:	c1 e0 02             	shl    $0x2,%eax
c002e9d0:	01 c8                	add    %ecx,%eax
c002e9d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e9d9:	01 d0                	add    %edx,%eax
c002e9db:	c1 e0 02             	shl    $0x2,%eax
c002e9de:	29 c6                	sub    %eax,%esi
c002e9e0:	89 f1                	mov    %esi,%ecx
c002e9e2:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002e9e5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002e9ea:	f7 ee                	imul   %esi
c002e9ec:	c1 fa 05             	sar    $0x5,%edx
c002e9ef:	89 f0                	mov    %esi,%eax
c002e9f1:	c1 f8 1f             	sar    $0x1f,%eax
c002e9f4:	29 c2                	sub    %eax,%edx
c002e9f6:	89 d0                	mov    %edx,%eax
c002e9f8:	83 ec 08             	sub    $0x8,%esp
c002e9fb:	53                   	push   %ebx
c002e9fc:	57                   	push   %edi
c002e9fd:	51                   	push   %ecx
c002e9fe:	50                   	push   %eax
c002e9ff:	ff 75 c8             	pushl  -0x38(%ebp)
c002ea02:	68 3c 37 03 c0       	push   $0xc003373c
c002ea07:	e8 b1 d9 ff ff       	call   c002c3bd <msg>
c002ea0c:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002ea0f:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c002ea16:	7f 0b                	jg     c002ea23 <test_mlfqs_recent_1+0x1ad>
            break;
        } 
      last_elapsed = elapsed;
c002ea18:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ea1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
c002ea1e:	e9 f1 fe ff ff       	jmp    c002e914 <test_mlfqs_recent_1+0x9e>
            break;
c002ea23:	90                   	nop
    }
}
c002ea24:	90                   	nop
c002ea25:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002ea28:	5b                   	pop    %ebx
c002ea29:	5e                   	pop    %esi
c002ea2a:	5f                   	pop    %edi
c002ea2b:	5d                   	pop    %ebp
c002ea2c:	c3                   	ret    

c002ea2d <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002ea2d:	55                   	push   %ebp
c002ea2e:	89 e5                	mov    %esp,%ebp
c002ea30:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 0);
c002ea33:	83 ec 04             	sub    $0x4,%esp
c002ea36:	6a 00                	push   $0x0
c002ea38:	6a 00                	push   $0x0
c002ea3a:	6a 02                	push   $0x2
c002ea3c:	e8 54 00 00 00       	call   c002ea95 <test_mlfqs_fair>
c002ea41:	83 c4 10             	add    $0x10,%esp
}
c002ea44:	90                   	nop
c002ea45:	c9                   	leave  
c002ea46:	c3                   	ret    

c002ea47 <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002ea47:	55                   	push   %ebp
c002ea48:	89 e5                	mov    %esp,%ebp
c002ea4a:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (20, 0, 0);
c002ea4d:	83 ec 04             	sub    $0x4,%esp
c002ea50:	6a 00                	push   $0x0
c002ea52:	6a 00                	push   $0x0
c002ea54:	6a 14                	push   $0x14
c002ea56:	e8 3a 00 00 00       	call   c002ea95 <test_mlfqs_fair>
c002ea5b:	83 c4 10             	add    $0x10,%esp
}
c002ea5e:	90                   	nop
c002ea5f:	c9                   	leave  
c002ea60:	c3                   	ret    

c002ea61 <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002ea61:	55                   	push   %ebp
c002ea62:	89 e5                	mov    %esp,%ebp
c002ea64:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 5);
c002ea67:	83 ec 04             	sub    $0x4,%esp
c002ea6a:	6a 05                	push   $0x5
c002ea6c:	6a 00                	push   $0x0
c002ea6e:	6a 02                	push   $0x2
c002ea70:	e8 20 00 00 00       	call   c002ea95 <test_mlfqs_fair>
c002ea75:	83 c4 10             	add    $0x10,%esp
}
c002ea78:	90                   	nop
c002ea79:	c9                   	leave  
c002ea7a:	c3                   	ret    

c002ea7b <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002ea7b:	55                   	push   %ebp
c002ea7c:	89 e5                	mov    %esp,%ebp
c002ea7e:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (10, 0, 1);
c002ea81:	83 ec 04             	sub    $0x4,%esp
c002ea84:	6a 01                	push   $0x1
c002ea86:	6a 00                	push   $0x0
c002ea88:	6a 0a                	push   $0xa
c002ea8a:	e8 06 00 00 00       	call   c002ea95 <test_mlfqs_fair>
c002ea8f:	83 c4 10             	add    $0x10,%esp
}
c002ea92:	90                   	nop
c002ea93:	c9                   	leave  
c002ea94:	c3                   	ret    

c002ea95 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002ea95:	55                   	push   %ebp
c002ea96:	89 e5                	mov    %esp,%ebp
c002ea98:	81 ec 78 01 00 00    	sub    $0x178,%esp
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002ea9e:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002eaa3:	84 c0                	test   %al,%al
c002eaa5:	75 1e                	jne    c002eac5 <test_mlfqs_fair+0x30>
c002eaa7:	83 ec 0c             	sub    $0xc,%esp
c002eaaa:	68 90 37 03 c0       	push   $0xc0033790
c002eaaf:	68 9d 37 03 c0       	push   $0xc003379d
c002eab4:	68 dc 38 03 c0       	push   $0xc00338dc
c002eab9:	6a 49                	push   $0x49
c002eabb:	68 b4 37 03 c0       	push   $0xc00337b4
c002eac0:	e8 5d b5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002eac5:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c002eac9:	7e 1e                	jle    c002eae9 <test_mlfqs_fair+0x54>
c002eacb:	83 ec 0c             	sub    $0xc,%esp
c002eace:	68 d5 37 03 c0       	push   $0xc00337d5
c002ead3:	68 9d 37 03 c0       	push   $0xc003379d
c002ead8:	68 dc 38 03 c0       	push   $0xc00338dc
c002eadd:	6a 4a                	push   $0x4a
c002eadf:	68 b4 37 03 c0       	push   $0xc00337b4
c002eae4:	e8 39 b5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (nice_min >= -10);
c002eae9:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c002eaed:	7d 1e                	jge    c002eb0d <test_mlfqs_fair+0x78>
c002eaef:	83 ec 0c             	sub    $0xc,%esp
c002eaf2:	68 f2 37 03 c0       	push   $0xc00337f2
c002eaf7:	68 9d 37 03 c0       	push   $0xc003379d
c002eafc:	68 dc 38 03 c0       	push   $0xc00338dc
c002eb01:	6a 4b                	push   $0x4b
c002eb03:	68 b4 37 03 c0       	push   $0xc00337b4
c002eb08:	e8 15 b5 ff ff       	call   c002a022 <debug_panic>
  ASSERT (nice_step >= 0);
c002eb0d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002eb11:	79 1e                	jns    c002eb31 <test_mlfqs_fair+0x9c>
c002eb13:	83 ec 0c             	sub    $0xc,%esp
c002eb16:	68 02 38 03 c0       	push   $0xc0033802
c002eb1b:	68 9d 37 03 c0       	push   $0xc003379d
c002eb20:	68 dc 38 03 c0       	push   $0xc00338dc
c002eb25:	6a 4c                	push   $0x4c
c002eb27:	68 b4 37 03 c0       	push   $0xc00337b4
c002eb2c:	e8 f1 b4 ff ff       	call   c002a022 <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002eb31:	8b 45 08             	mov    0x8(%ebp),%eax
c002eb34:	48                   	dec    %eax
c002eb35:	0f af 45 10          	imul   0x10(%ebp),%eax
c002eb39:	89 c2                	mov    %eax,%edx
c002eb3b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002eb3e:	01 d0                	add    %edx,%eax
c002eb40:	83 f8 14             	cmp    $0x14,%eax
c002eb43:	7e 1e                	jle    c002eb63 <test_mlfqs_fair+0xce>
c002eb45:	83 ec 0c             	sub    $0xc,%esp
c002eb48:	68 14 38 03 c0       	push   $0xc0033814
c002eb4d:	68 9d 37 03 c0       	push   $0xc003379d
c002eb52:	68 dc 38 03 c0       	push   $0xc00338dc
c002eb57:	6a 4d                	push   $0x4d
c002eb59:	68 b4 37 03 c0       	push   $0xc00337b4
c002eb5e:	e8 bf b4 ff ff       	call   c002a022 <debug_panic>

  thread_set_nice (-20);
c002eb63:	83 ec 0c             	sub    $0xc,%esp
c002eb66:	6a ec                	push   $0xffffffec
c002eb68:	e8 b0 23 ff ff       	call   c0020f1d <thread_set_nice>
c002eb6d:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002eb70:	e8 b5 59 ff ff       	call   c002452a <timer_ticks>
c002eb75:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002eb78:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c002eb7b:	83 ec 08             	sub    $0x8,%esp
c002eb7e:	ff 75 08             	pushl  0x8(%ebp)
c002eb81:	68 42 38 03 c0       	push   $0xc0033842
c002eb86:	e8 32 d8 ff ff       	call   c002c3bd <msg>
c002eb8b:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c002eb8e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002eb91:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002eb94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002eb9b:	eb 6d                	jmp    c002ec0a <test_mlfqs_fair+0x175>
    {
      struct thread_info *ti = &info[i];
c002eb9d:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002eba3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002eba6:	c1 e2 04             	shl    $0x4,%edx
c002eba9:	01 d0                	add    %edx,%eax
c002ebab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c002ebae:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002ebb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002ebb4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002ebb7:	89 01                	mov    %eax,(%ecx)
c002ebb9:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c002ebbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002ebbf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c002ebc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002ebc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ebcc:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c002ebcf:	ff 75 f0             	pushl  -0x10(%ebp)
c002ebd2:	68 59 38 03 c0       	push   $0xc0033859
c002ebd7:	6a 10                	push   $0x10
c002ebd9:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002ebdf:	50                   	push   %eax
c002ebe0:	e8 43 8f ff ff       	call   c0027b28 <snprintf>
c002ebe5:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002ebe8:	ff 75 e4             	pushl  -0x1c(%ebp)
c002ebeb:	68 94 ec 02 c0       	push   $0xc002ec94
c002ebf0:	6a 1f                	push   $0x1f
c002ebf2:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002ebf8:	50                   	push   %eax
c002ebf9:	e8 5e 1e ff ff       	call   c0020a5c <thread_create>
c002ebfe:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c002ec01:	8b 45 10             	mov    0x10(%ebp),%eax
c002ec04:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002ec07:	ff 45 f0             	incl   -0x10(%ebp)
c002ec0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ec0d:	3b 45 08             	cmp    0x8(%ebp),%eax
c002ec10:	7c 8b                	jl     c002eb9d <test_mlfqs_fair+0x108>
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002ec12:	83 ec 08             	sub    $0x8,%esp
c002ec15:	ff 75 ec             	pushl  -0x14(%ebp)
c002ec18:	ff 75 e8             	pushl  -0x18(%ebp)
c002ec1b:	e8 3f 59 ff ff       	call   c002455f <timer_elapsed>
c002ec20:	83 c4 10             	add    $0x10,%esp
c002ec23:	83 ec 04             	sub    $0x4,%esp
c002ec26:	52                   	push   %edx
c002ec27:	50                   	push   %eax
c002ec28:	68 64 38 03 c0       	push   $0xc0033864
c002ec2d:	e8 8b d7 ff ff       	call   c002c3bd <msg>
c002ec32:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002ec35:	83 ec 0c             	sub    $0xc,%esp
c002ec38:	68 88 38 03 c0       	push   $0xc0033888
c002ec3d:	e8 7b d7 ff ff       	call   c002c3bd <msg>
c002ec42:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c002ec45:	83 ec 08             	sub    $0x8,%esp
c002ec48:	6a 00                	push   $0x0
c002ec4a:	68 a0 0f 00 00       	push   $0xfa0
c002ec4f:	e8 2a 59 ff ff       	call   c002457e <timer_sleep>
c002ec54:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002ec57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002ec5e:	eb 29                	jmp    c002ec89 <test_mlfqs_fair+0x1f4>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002ec60:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ec63:	c1 e0 04             	shl    $0x4,%eax
c002ec66:	8d 4d f8             	lea    -0x8(%ebp),%ecx
c002ec69:	01 c8                	add    %ecx,%eax
c002ec6b:	2d 4c 01 00 00       	sub    $0x14c,%eax
c002ec70:	8b 00                	mov    (%eax),%eax
c002ec72:	83 ec 04             	sub    $0x4,%esp
c002ec75:	50                   	push   %eax
c002ec76:	ff 75 f0             	pushl  -0x10(%ebp)
c002ec79:	68 bf 38 03 c0       	push   $0xc00338bf
c002ec7e:	e8 3a d7 ff ff       	call   c002c3bd <msg>
c002ec83:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002ec86:	ff 45 f0             	incl   -0x10(%ebp)
c002ec89:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ec8c:	3b 45 08             	cmp    0x8(%ebp),%eax
c002ec8f:	7c cf                	jl     c002ec60 <test_mlfqs_fair+0x1cb>
}
c002ec91:	90                   	nop
c002ec92:	c9                   	leave  
c002ec93:	c3                   	ret    

c002ec94 <load_thread>:

static void
load_thread (void *ti_) 
{
c002ec94:	55                   	push   %ebp
c002ec95:	89 e5                	mov    %esp,%ebp
c002ec97:	56                   	push   %esi
c002ec98:	53                   	push   %ebx
c002ec99:	83 ec 40             	sub    $0x40,%esp
  struct thread_info *ti = ti_;
c002ec9c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ec9f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c002eca2:	c7 45 e0 f4 01 00 00 	movl   $0x1f4,-0x20(%ebp)
c002eca9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c002ecb0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002ecb3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002ecb6:	05 b8 0b 00 00       	add    $0xbb8,%eax
c002ecbb:	83 d2 00             	adc    $0x0,%edx
c002ecbe:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002ecc1:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int64_t last_time = 0;
c002ecc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002eccb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  thread_set_nice (ti->nice);
c002ecd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ecd5:	8b 40 0c             	mov    0xc(%eax),%eax
c002ecd8:	83 ec 0c             	sub    $0xc,%esp
c002ecdb:	50                   	push   %eax
c002ecdc:	e8 3c 22 ff ff       	call   c0020f1d <thread_set_nice>
c002ece1:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002ece4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ece7:	8b 50 04             	mov    0x4(%eax),%edx
c002ecea:	8b 00                	mov    (%eax),%eax
c002ecec:	83 ec 08             	sub    $0x8,%esp
c002ecef:	52                   	push   %edx
c002ecf0:	50                   	push   %eax
c002ecf1:	e8 69 58 ff ff       	call   c002455f <timer_elapsed>
c002ecf6:	83 c4 10             	add    $0x10,%esp
c002ecf9:	89 45 c0             	mov    %eax,-0x40(%ebp)
c002ecfc:	89 55 c4             	mov    %edx,-0x3c(%ebp)
c002ecff:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002ed02:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002ed05:	2b 45 c0             	sub    -0x40(%ebp),%eax
c002ed08:	1b 55 c4             	sbb    -0x3c(%ebp),%edx
c002ed0b:	83 ec 08             	sub    $0x8,%esp
c002ed0e:	52                   	push   %edx
c002ed0f:	50                   	push   %eax
c002ed10:	e8 69 58 ff ff       	call   c002457e <timer_sleep>
c002ed15:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c002ed18:	eb 42                	jmp    c002ed5c <load_thread+0xc8>
    {
      int64_t cur_time = timer_ticks ();
c002ed1a:	e8 0b 58 ff ff       	call   c002452a <timer_ticks>
c002ed1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002ed22:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (cur_time != last_time)
c002ed25:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002ed28:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002ed2b:	89 c1                	mov    %eax,%ecx
c002ed2d:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002ed30:	89 cb                	mov    %ecx,%ebx
c002ed32:	89 d0                	mov    %edx,%eax
c002ed34:	33 45 f4             	xor    -0xc(%ebp),%eax
c002ed37:	89 c6                	mov    %eax,%esi
c002ed39:	89 f0                	mov    %esi,%eax
c002ed3b:	09 d8                	or     %ebx,%eax
c002ed3d:	85 c0                	test   %eax,%eax
c002ed3f:	74 0f                	je     c002ed50 <load_thread+0xbc>
        ti->tick_count++;
c002ed41:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ed44:	8b 40 08             	mov    0x8(%eax),%eax
c002ed47:	8d 50 01             	lea    0x1(%eax),%edx
c002ed4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ed4d:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c002ed50:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002ed53:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002ed56:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ed59:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (ti->start_time) < spin_time) 
c002ed5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ed5f:	8b 50 04             	mov    0x4(%eax),%edx
c002ed62:	8b 00                	mov    (%eax),%eax
c002ed64:	83 ec 08             	sub    $0x8,%esp
c002ed67:	52                   	push   %edx
c002ed68:	50                   	push   %eax
c002ed69:	e8 f1 57 ff ff       	call   c002455f <timer_elapsed>
c002ed6e:	83 c4 10             	add    $0x10,%esp
c002ed71:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002ed74:	7c a4                	jl     c002ed1a <load_thread+0x86>
c002ed76:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002ed79:	7f 05                	jg     c002ed80 <load_thread+0xec>
c002ed7b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c002ed7e:	72 9a                	jb     c002ed1a <load_thread+0x86>
    }
}
c002ed80:	90                   	nop
c002ed81:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002ed84:	5b                   	pop    %ebx
c002ed85:	5e                   	pop    %esi
c002ed86:	5d                   	pop    %ebp
c002ed87:	c3                   	ret    

c002ed88 <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002ed88:	55                   	push   %ebp
c002ed89:	89 e5                	mov    %esp,%ebp
c002ed8b:	83 ec 38             	sub    $0x38,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002ed8e:	a0 30 a1 03 c0       	mov    0xc003a130,%al
c002ed93:	84 c0                	test   %al,%al
c002ed95:	75 1e                	jne    c002edb5 <test_mlfqs_block+0x2d>
c002ed97:	83 ec 0c             	sub    $0xc,%esp
c002ed9a:	68 ec 38 03 c0       	push   $0xc00338ec
c002ed9f:	68 f9 38 03 c0       	push   $0xc00338f9
c002eda4:	68 58 3a 03 c0       	push   $0xc0033a58
c002eda9:	6a 1c                	push   $0x1c
c002edab:	68 10 39 03 c0       	push   $0xc0033910
c002edb0:	e8 6d b2 ff ff       	call   c002a022 <debug_panic>

  msg ("Main thread acquiring lock.");
c002edb5:	83 ec 0c             	sub    $0xc,%esp
c002edb8:	68 32 39 03 c0       	push   $0xc0033932
c002edbd:	e8 fb d5 ff ff       	call   c002c3bd <msg>
c002edc2:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c002edc5:	83 ec 0c             	sub    $0xc,%esp
c002edc8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002edcb:	50                   	push   %eax
c002edcc:	e8 91 42 ff ff       	call   c0023062 <lock_init>
c002edd1:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002edd4:	83 ec 0c             	sub    $0xc,%esp
c002edd7:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002edda:	50                   	push   %eax
c002eddb:	e8 cf 42 ff ff       	call   c00230af <lock_acquire>
c002ede0:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002ede3:	83 ec 0c             	sub    $0xc,%esp
c002ede6:	68 50 39 03 c0       	push   $0xc0033950
c002edeb:	e8 cd d5 ff ff       	call   c002c3bd <msg>
c002edf0:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002edf3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002edf6:	50                   	push   %eax
c002edf7:	68 8d ee 02 c0       	push   $0xc002ee8d
c002edfc:	6a 1f                	push   $0x1f
c002edfe:	68 8a 39 03 c0       	push   $0xc003398a
c002ee03:	e8 54 1c ff ff       	call   c0020a5c <thread_create>
c002ee08:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c002ee0b:	83 ec 08             	sub    $0x8,%esp
c002ee0e:	6a 00                	push   $0x0
c002ee10:	68 c4 09 00 00       	push   $0x9c4
c002ee15:	e8 64 57 ff ff       	call   c002457e <timer_sleep>
c002ee1a:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c002ee1d:	83 ec 0c             	sub    $0xc,%esp
c002ee20:	68 90 39 03 c0       	push   $0xc0033990
c002ee25:	e8 93 d5 ff ff       	call   c002c3bd <msg>
c002ee2a:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002ee2d:	e8 f8 56 ff ff       	call   c002452a <timer_ticks>
c002ee32:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ee35:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002ee38:	eb 01                	jmp    c002ee3b <test_mlfqs_block+0xb3>
    continue;
c002ee3a:	90                   	nop
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002ee3b:	83 ec 08             	sub    $0x8,%esp
c002ee3e:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee41:	ff 75 f0             	pushl  -0x10(%ebp)
c002ee44:	e8 16 57 ff ff       	call   c002455f <timer_elapsed>
c002ee49:	83 c4 10             	add    $0x10,%esp
c002ee4c:	85 d2                	test   %edx,%edx
c002ee4e:	78 ea                	js     c002ee3a <test_mlfqs_block+0xb2>
c002ee50:	85 d2                	test   %edx,%edx
c002ee52:	7f 07                	jg     c002ee5b <test_mlfqs_block+0xd3>
c002ee54:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002ee59:	76 df                	jbe    c002ee3a <test_mlfqs_block+0xb2>

  msg ("Main thread releasing lock.");
c002ee5b:	83 ec 0c             	sub    $0xc,%esp
c002ee5e:	68 b6 39 03 c0       	push   $0xc00339b6
c002ee63:	e8 55 d5 ff ff       	call   c002c3bd <msg>
c002ee68:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002ee6b:	83 ec 0c             	sub    $0xc,%esp
c002ee6e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002ee71:	50                   	push   %eax
c002ee72:	e8 69 44 ff ff       	call   c00232e0 <lock_release>
c002ee77:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c002ee7a:	83 ec 0c             	sub    $0xc,%esp
c002ee7d:	68 d4 39 03 c0       	push   $0xc00339d4
c002ee82:	e8 36 d5 ff ff       	call   c002c3bd <msg>
c002ee87:	83 c4 10             	add    $0x10,%esp
}
c002ee8a:	90                   	nop
c002ee8b:	c9                   	leave  
c002ee8c:	c3                   	ret    

c002ee8d <block_thread>:

static void
block_thread (void *lock_) 
{
c002ee8d:	55                   	push   %ebp
c002ee8e:	89 e5                	mov    %esp,%ebp
c002ee90:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ee93:	8b 45 08             	mov    0x8(%ebp),%eax
c002ee96:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002ee99:	83 ec 0c             	sub    $0xc,%esp
c002ee9c:	68 04 3a 03 c0       	push   $0xc0033a04
c002eea1:	e8 17 d5 ff ff       	call   c002c3bd <msg>
c002eea6:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002eea9:	e8 7c 56 ff ff       	call   c002452a <timer_ticks>
c002eeae:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002eeb1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002eeb4:	eb 01                	jmp    c002eeb7 <block_thread+0x2a>
    continue;
c002eeb6:	90                   	nop
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002eeb7:	83 ec 08             	sub    $0x8,%esp
c002eeba:	ff 75 ec             	pushl  -0x14(%ebp)
c002eebd:	ff 75 e8             	pushl  -0x18(%ebp)
c002eec0:	e8 9a 56 ff ff       	call   c002455f <timer_elapsed>
c002eec5:	83 c4 10             	add    $0x10,%esp
c002eec8:	85 d2                	test   %edx,%edx
c002eeca:	78 ea                	js     c002eeb6 <block_thread+0x29>
c002eecc:	85 d2                	test   %edx,%edx
c002eece:	7f 07                	jg     c002eed7 <block_thread+0x4a>
c002eed0:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002eed5:	76 df                	jbe    c002eeb6 <block_thread+0x29>

  msg ("Block thread acquiring lock...");
c002eed7:	83 ec 0c             	sub    $0xc,%esp
c002eeda:	68 2c 3a 03 c0       	push   $0xc0033a2c
c002eedf:	e8 d9 d4 ff ff       	call   c002c3bd <msg>
c002eee4:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002eee7:	83 ec 0c             	sub    $0xc,%esp
c002eeea:	ff 75 f4             	pushl  -0xc(%ebp)
c002eeed:	e8 bd 41 ff ff       	call   c00230af <lock_acquire>
c002eef2:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c002eef5:	83 ec 0c             	sub    $0xc,%esp
c002eef8:	68 4b 3a 03 c0       	push   $0xc0033a4b
c002eefd:	e8 bb d4 ff ff       	call   c002c3bd <msg>
c002ef02:	83 c4 10             	add    $0x10,%esp
}
c002ef05:	90                   	nop
c002ef06:	c9                   	leave  
c002ef07:	c3                   	ret    
